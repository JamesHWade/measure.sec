---
title: "Tutorial: Triple Detection from Raw Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial: Triple Detection from Raw Data}

  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## What You'll Learn

This tutorial walks through a **complete triple detection SEC workflow** from raw instrument data. By the end, you will be able to:
1. **Determine inter-detector delays** using a narrow standard
2. **Align detector signals** so peaks match across RI, UV, and MALS
3. **Calculate absolute molecular weight** from MALS + concentration
4. **Validate results** against known values

**Time to complete**: ~30 minutes

## Prerequisites

- Completed [Getting Started](getting-started.html) tutorial
- Familiarity with conventional SEC calibration
- Basic understanding of light scattering (optional but helpful)

## Why Triple Detection?

**Conventional calibration** requires standards of the same polymer type as your sample. But what if:

- You're analyzing an unknown polymer?
- No standards exist for your polymer type?
- You need absolute MW, not relative to standards?

**Triple detection** solves this by using light scattering (MALS) to measure MW directly. The "triple" refers to:

1. **RI detector** → concentration
2. **UV detector** → chromophore content (optional)
3. **MALS detector** → absolute molecular weight

## Setup

```{r setup}
library(measure)
library(measure.sec)
library(recipes)
library(dplyr)
library(tidyr)
library(ggplot2)
```

## The Raw Data Challenge

When you export data from an SEC system with multiple detectors, the signals are **NOT aligned**. Each detector is at a different position in the flow path, so they see the same molecules at different times.

```{r load-data}
# Load raw multi-detector data
data(sec_raw_multidetector)

# View samples
sec_raw_multidetector |>
  distinct(sample_id, description, mw, dn_dc) |>
  print()
```

Let's visualize the delay standard to see the misalignment:

```{r plot-misaligned, fig.height=5}
# Extract delay standard
delay_std <- sec_raw_multidetector |>
  filter(sample_id == "PS-DelayStd")

# Normalize each signal for comparison
delay_plot <- delay_std |>
  mutate(
    ri_norm = ri_mv / max(ri_mv),
    uv_norm = (uv_au * 1000) / max(uv_au * 1000),  # Scale AU to visible range
    mals_norm = mals_mv / max(mals_mv)
  ) |>
  select(time_min, RI = ri_norm, UV = uv_norm, MALS = mals_norm) |>
  pivot_longer(-time_min, names_to = "detector", values_to = "signal")

ggplot(delay_plot, aes(time_min, signal, color = detector)) +
  geom_line(linewidth = 0.8) +
  scale_color_manual(values = c("RI" = "#2E86AB", "UV" = "#A23B72", "MALS" = "#F18F01")) +
  labs(
    x = "Time (min)",
    y = "Normalized Signal",
    title = "Raw Multi-Detector Data: Peaks Are NOT Aligned!",
    subtitle = "UV leads RI, MALS lags RI - this must be corrected before analysis",
    color = "Detector"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

Notice how:

- **UV peak** appears first (UV detector is before RI in flow path)
- **RI peak** is in the middle (reference detector)
- **MALS peak** appears last (MALS detector is after RI in flow path)

If we don't correct this, we'll match the wrong MW to each concentration point!

## Step 1: Determine Inter-Detector Delays

The delay standard (a narrow PS standard) helps us measure the time offset between detectors. We find the peak maximum in each detector and calculate the difference.

```{r find-delays}
# Find peak time for each detector
find_peak_time <- function(time, signal) {
  # Simple peak finding: maximum after smoothing
  smoothed <- stats::filter(signal, rep(1/5, 5), sides = 2)
  smoothed[is.na(smoothed)] <- signal[is.na(smoothed)]
  time[which.max(smoothed)]
}

# Calculate peak times
ri_peak <- find_peak_time(delay_std$time_min, delay_std$ri_mv)
uv_peak <- find_peak_time(delay_std$time_min, delay_std$uv_au)
mals_peak <- find_peak_time(delay_std$time_min, delay_std$mals_mv)

cat("Peak retention times:\n")
cat("  RI:   ", round(ri_peak, 3), "min\n")
cat("  UV:   ", round(uv_peak, 3), "min\n")
cat("  MALS: ", round(mals_peak, 3), "min\n")

# Calculate delays relative to RI (the reference)
delay_uv <- ri_peak - uv_peak    # Positive = UV needs to shift later
delay_mals <- ri_peak - mals_peak  # Negative = MALS needs to shift earlier

cat("\nDelays relative to RI:\n")
cat("  UV delay:   ", round(delay_uv, 4), "min (shift UV signal later)\n")
cat("  MALS delay: ", round(delay_mals, 4), "min (shift MALS signal earlier)\n")

# Convert to volume (using flow rate of 1.0 mL/min)
flow_rate <- 1.0
cat("\nDelay volumes:\n")
cat("  UV:   ", round(delay_uv * flow_rate, 3), "mL\n")
cat("  MALS: ", round(delay_mals * flow_rate, 3), "mL\n")
```

## Step 2: Apply Delay Correction

Now we align all signals to the RI reference. The `step_sec_detector_delay()` function handles this:

```{r apply-delays}
# Process delay standard with correction
# Note: delay_volumes are in mL; our delays are in minutes, so convert
# Using flow_rate = 1.0 mL/min, time in min = volume in mL
rec_aligned <- recipe(
  ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,
  data = delay_std
) |>
  update_role(sample_id, new_role = "id") |>
  # Convert each detector to measure format
  step_measure_input_long(ri_mv, location = vars(time_min), col_name = "ri") |>
  step_measure_input_long(uv_au, location = vars(time_min), col_name = "uv") |>
  step_measure_input_long(mals_mv, location = vars(time_min), col_name = "mals") |>
  # Apply baseline correction
  step_sec_baseline(measures = c("ri", "uv", "mals")) |>
  # Correct inter-detector delays
  # delay_volumes: positive = detector sees sample AFTER reference
  step_sec_detector_delay(
    reference = "ri",
    targets = c("uv", "mals"),
    delay_volumes = c(uv = -delay_uv, mals = -delay_mals)  # Negate to get correction direction
  )

aligned <- prep(rec_aligned) |> bake(new_data = NULL)
```

```{r plot-aligned, fig.height=5}
# Extract and normalize aligned signals
ri_chrom <- aligned$ri[[1]]
uv_chrom <- aligned$uv[[1]]
mals_chrom <- aligned$mals[[1]]

# Normalize each signal
ri_norm <- ri_chrom$value / max(ri_chrom$value, na.rm = TRUE)
uv_norm <- uv_chrom$value / max(abs(uv_chrom$value), na.rm = TRUE)
mals_norm <- mals_chrom$value / max(mals_chrom$value, na.rm = TRUE)

# Build plot data
aligned_plot <- tibble(
  location = rep(ri_chrom$location, 3),
  signal = c(ri_norm, uv_norm, mals_norm),
  detector = rep(c("RI", "UV", "MALS"), each = length(ri_norm))
)

ggplot(aligned_plot, aes(location, signal, color = detector)) +
  geom_line(linewidth = 0.8) +
  scale_color_manual(values = c("RI" = "#2E86AB", "UV" = "#A23B72", "MALS" = "#F18F01")) +
  labs(
    x = "Time (min)",
    y = "Normalized Signal",
    title = "After Delay Correction: Peaks Are Now Aligned!",
    subtitle = "All detectors see the same molecules at the same time",
    color = "Detector"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

The peaks now align across all detectors.

## Step 3: Process Unknown Samples

Let's analyze the unknown samples using our determined delays:

```{r process-sample}
# Select a sample
sample_1 <- sec_raw_multidetector |>
  filter(sample_id == "Sample-1")

# Full triple detection recipe
rec_triple <- recipe(
  ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,
  data = sample_1
) |>
  update_role(sample_id, new_role = "id") |>
  # Convert to measure format
  step_measure_input_long(ri_mv, location = vars(time_min), col_name = "ri") |>
  step_measure_input_long(uv_au, location = vars(time_min), col_name = "uv") |>
  step_measure_input_long(mals_mv, location = vars(time_min), col_name = "mals") |>
  # Baseline correction
  step_sec_baseline(measures = c("ri", "uv", "mals")) |>
  # Delay correction
  step_sec_detector_delay(
    reference = "ri",
    targets = c("uv", "mals"),
    delay_volumes = c(uv = -delay_uv, mals = -delay_mals)
  ) |>
  # Process RI for concentration
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc")

result_sample <- prep(rec_triple) |> bake(new_data = NULL)

# View the processed data
result_sample |>
  select(sample_id, ri, uv, mals, dn_dc)
```

## Step 4: Calculate Absolute MW from MALS

In a full workflow, you would use `step_sec_mals()` to calculate molecular weight from the light scattering signal combined with concentration. The basic relationship is:

$$M_w = \frac{R_\theta}{K^* \cdot c \cdot P(\theta)}$$

Where:
- $R_\theta$ = excess Rayleigh ratio (from MALS signal)
- $K^*$ = optical constant (depends on dn/dc, wavelength)
- $c$ = concentration (from RI)
- $P(\theta)$ = form factor (angular dependence)

```{r mals-concept, echo=FALSE, fig.height=4}
# Conceptual plot showing MALS MW determination
concept_data <- tibble(
  elution_time = seq(8, 14, by = 0.1),
  concentration = dnorm(elution_time, mean = 11, sd = 0.8),
  mals_signal = dnorm(elution_time, mean = 11, sd = 0.8) *
                (10^(6 - 0.5 * (elution_time - 8)))  # MW decreases with elution
) |>
  mutate(
    mw = ifelse(concentration > 0.01, mals_signal / concentration * 1e5, NA)
  )

p1 <- ggplot(concept_data, aes(elution_time)) +
  geom_line(aes(y = concentration, color = "Concentration (RI)"), linewidth = 1) +
  geom_line(aes(y = mals_signal / 1e4, color = "MALS Signal"), linewidth = 1) +
  scale_color_manual(values = c("Concentration (RI)" = "#2E86AB", "MALS Signal" = "#F18F01")) +
  labs(x = "Elution Time (min)", y = "Signal", color = "") +
  theme_minimal() +
  theme(legend.position = "bottom")

p2 <- ggplot(concept_data |> filter(!is.na(mw)), aes(elution_time, mw)) +
  geom_line(color = "#A23B72", linewidth = 1) +
  scale_y_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  labs(x = "Elution Time (min)", y = "MW (Da)",
       title = "MW Calculated Point-by-Point") +
  theme_minimal()

p1
p2
```

## Complete Multi-Sample Analysis

Let's process all samples and compare results to known values:

```{r analyze-all}
analyze_sample <- function(sample_data) {
  sample_id <- unique(sample_data$sample_id)
  known_mw <- unique(sample_data$mw)

  rec <- recipe(
    ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,
    data = sample_data
  ) |>
    update_role(sample_id, new_role = "id") |>
    step_measure_input_long(ri_mv, location = vars(time_min), col_name = "ri") |>
    step_measure_input_long(mals_mv, location = vars(time_min), col_name = "mals") |>
    step_sec_baseline(measures = c("ri", "mals")) |>
    step_sec_detector_delay(
      reference = "ri",
      targets = "mals",
      delay_volumes = c(mals = -delay_mals)
    ) |>
    step_sec_ri(measures = "ri", dn_dc_column = "dn_dc")

  result <- prep(rec) |> bake(new_data = NULL)

  # Extract peak info for summary
  ri_chrom <- result$ri[[1]]
  peak_idx <- which.max(ri_chrom$value)
  peak_time <- ri_chrom$location[peak_idx]

  tibble(
    sample_id = sample_id,
    known_mw = known_mw,
    peak_time = peak_time,
    dn_dc = unique(sample_data$dn_dc)
  )
}

# Analyze all samples
all_results <- sec_raw_multidetector |>
  group_by(sample_id) |>
  group_split() |>
  purrr::map(analyze_sample) |>
  bind_rows()

print(all_results)
```

## Comparison: Overlay All Processed Chromatograms

```{r overlay-plot, fig.height=5}
# Process all samples for plotting
process_for_plot <- function(sample_data) {
  sid <- unique(sample_data$sample_id)
  known_mw <- unique(sample_data$mw)

  rec <- recipe(
    ri_mv + time_min + dn_dc ~ sample_id,
    data = sample_data
  ) |>
    update_role(sample_id, new_role = "id") |>
    step_measure_input_long(ri_mv, location = vars(time_min), col_name = "ri") |>
    step_sec_baseline(measures = "ri")

  result <- prep(rec) |> bake(new_data = NULL)
  chrom <- result$ri[[1]]

  tibble(
    location = chrom$location,
    value = chrom$value,
    sample_id = sid,
    mw = known_mw,
    label = paste0(sid, "\n(", scales::comma(known_mw), " Da)")
  )
}

plot_data <- sec_raw_multidetector |>
  group_by(sample_id) |>
  group_split() |>
  purrr::map(process_for_plot) |>
  bind_rows()

ggplot(plot_data, aes(location, value, color = label)) +
  geom_line(linewidth = 0.8) +
  scale_color_viridis_d(option = "turbo") +
  labs(
    x = "Elution Time (min)",
    y = "RI Signal (baseline corrected)",
    title = "Processed Multi-Detector Samples",
    subtitle = "Higher MW samples elute earlier",
    color = "Sample"
  ) +
  theme_minimal() +
  theme(legend.position = "right")
```

## When to Use Triple Detection vs Conventional Calibration

| Scenario | Recommended Method |
|----------|-------------------|
| Known polymer with available standards | Conventional calibration |
| Unknown polymer type | Triple detection |
| Need absolute MW for regulatory submission | Triple detection |
| Branching analysis | Triple detection (with viscometer) |
| Routine QC of known products | Conventional calibration |
| Copolymers with variable composition | Triple detection |

## Troubleshooting Common Issues

| Problem | Possible Cause | Solution |
|---------|---------------|----------|
| MALS signal very noisy | Low concentration or small molecules | Increase injection, use LALS/RALS |
| MW values too high | Aggregates or dust in sample | Filter sample, check for aggregates |
| MW values too low | Incorrect dn/dc | Measure dn/dc or use literature value |
| Peaks still misaligned | Wrong delay values | Re-run delay determination |
| Negative MW at edges | Low S/N ratio | Use integration limits to exclude edges |

## Summary

You've completed a triple detection workflow:

1. **Identified the delay problem** - raw detector signals are not aligned
2. **Determined delays** using a narrow standard
3. **Applied corrections** with `step_sec_detector_delay()`
4. **Processed samples** through the complete workflow

### Key Takeaways

- **Always determine delays** with a narrow standard before analyzing unknowns
- **RI is typically the reference** detector (delay = 0)
- **UV leads, MALS lags** in most instrument configurations
- **Delay values depend on** flow rate, tubing length, and flow cell volumes
- **Re-check delays** if you change any plumbing or flow rates

## Next Steps

| Topic | Resource |
|-------|----------|
| MALS theory and angular analysis | [MALS Detection Guide](mals-detection.html) |
| Single-angle alternatives | [LALS/RALS Detection](lals-rals-detection.html) |
| Adding viscometer for [η] | [Multi-Detector SEC](triple-detection.html) |
| Conventional calibration | [Conventional Calibration Tutorial](tutorial-conventional-calibration.html) |

## Session Info

```{r session-info}
sessionInfo()
```
