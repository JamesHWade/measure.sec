---
title: "Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Overview

Multi-Angle Light Scattering (MALS) is a powerful technique that provides **absolute molecular weight** without calibration standards. Unlike conventional calibration (which gives MW relative to polymer standards), MALS measures the actual molecular weight of your sample based on fundamental light scattering physics.
This vignette covers:

1. How MALS measures absolute molecular weight
2. Key parameters: dn/dc, wavelength, angles

3. Zimm, Debye, and Berry formalisms
4. Radius of gyration (Rg) from angular dependence
5. Practical workflows with `step_sec_mals()`

## Setup

```{r setup}
library(measure)
library(measure.sec)
library(recipes)
library(dplyr)
library(ggplot2)
```

## How MALS Works

### The Light Scattering Principle

When light passes through a polymer solution, molecules scatter light in all directions. The intensity of scattered light depends on:

- **Molecular weight**: Larger molecules scatter more light
- **Concentration**: More molecules = more scattering
- **Scattering angle**: Angular dependence reveals molecular size

The fundamental relationship is the **Rayleigh-Debye equation**:

$$\frac{Kc}{R(\theta)} = \frac{1}{M_w \cdot P(\theta)} + 2A_2 c$$

Where:

| Symbol | Meaning |
|--------|---------|
| K | Optical constant (depends on dn/dc, wavelength, solvent) |
| c | Concentration (g/mL) |
| R(θ) | Excess Rayleigh ratio (scattered intensity) |
| Mw | Weight-average molecular weight |
| P(θ) | Particle scattering function (angular dependence) |
| A₂ | Second virial coefficient |

### The Optical Constant K

The optical constant depends on your experimental setup:

$$K = \frac{4\pi^2 n_0^2 (dn/dc)^2}{N_A \lambda^4}$$

Where:

- **n₀**: Solvent refractive index
- **dn/dc**: Refractive index increment of the polymer
- **λ**: Laser wavelength
- **Nₐ**: Avogadro's number

```{r optical-constant-concept, echo = FALSE, fig.width=7, fig.height=4}
# Show how K depends on dn/dc
dn_dc_values <- seq(0.05, 0.25, by = 0.01)
wavelength <- 658  # nm
solvent_ri <- 1.333  # water

# Calculate K for each dn/dc
lambda_cm <- wavelength * 1e-7
NA_val <- 6.022e23
K_values <- 4 * pi^2 * solvent_ri^2 * dn_dc_values^2 / (NA_val * lambda_cm^4)

k_data <- tibble(
  dn_dc = dn_dc_values,
  K = K_values * 1e7  # Scale for plotting
)

ggplot(k_data, aes(dn_dc, K)) +
  geom_line(linewidth = 1.2, color = "#2E86AB") +
  geom_vline(xintercept = 0.185, linetype = "dashed", color = "#A23B72") +
  annotate("text", x = 0.185, y = max(k_data$K) * 0.9,
           label = "PS in THF\n(0.185)", hjust = -0.1, color = "#A23B72") +
  geom_vline(xintercept = 0.084, linetype = "dashed", color = "#E8751A") +
  annotate("text", x = 0.084, y = max(k_data$K) * 0.7,
           label = "PMMA\n(0.084)", hjust = 1.1, color = "#E8751A") +
  labs(
    x = "dn/dc (mL/g)",
    y = expression("K (×10"^-7*" mol·cm²/g²)"),
    title = "Optical Constant Depends on dn/dc",
    subtitle = "Higher dn/dc = stronger scattering signal"
  ) +
  theme_minimal()
```

**Key insight**: Accurate dn/dc is critical. A 10% error in dn/dc causes a ~20% error in MW.

## Why Use MALS?

### Conventional Calibration Limitations

Conventional (relative) calibration has significant limitations:

```{r calibration-comparison, echo = FALSE, fig.width=7, fig.height=5}
# Demonstrate the problem with conventional calibration
polymers <- tibble(
  polymer = c("PS", "PMMA", "PEG", "Branched PE"),
  true_mw = c(100000, 100000, 100000, 100000),
  conv_mw_ps = c(100000, 130000, 85000, 120000),  # PS calibration
  description = c("Reference", "Appears larger", "Appears smaller", "Appears larger")
)

plot_data <- polymers |>
  tidyr::pivot_longer(
    cols = c(true_mw, conv_mw_ps),
    names_to = "method",
    values_to = "mw"
  ) |>
  mutate(
    method = case_when(
      method == "true_mw" ~ "True MW (MALS)",
      method == "conv_mw_ps" ~ "Conventional (PS cal)"
    )
  )

ggplot(plot_data, aes(polymer, mw / 1000, fill = method)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("True MW (MALS)" = "#2E86AB", "Conventional (PS cal)" = "#A23B72")) +
  labs(
    x = NULL,
    y = "Molecular Weight (kDa)",
    fill = "Method",
    title = "Conventional Calibration vs MALS",
    subtitle = "All polymers have true MW = 100 kDa"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

| Polymer Type | Conventional Cal | MALS |
|--------------|------------------|------|
| Same as standards | Accurate | Accurate |
| Different chemistry | **Biased** | Accurate |
| Branched | **Biased** | Accurate |
| Copolymers | **Biased** | Accurate |

**MALS is essential when**:
- Analyzing polymers different from your calibration standards
- Studying branched or star polymers
- Characterizing copolymers
- Absolute MW is required for regulatory submissions

## Angular Dependence and Rg

### Why Multiple Angles?

Large molecules (Rg > λ/20) scatter light differently at different angles. This angular dependence reveals the **radius of gyration (Rg)** - a measure of molecular size.

```{r angular-dependence, echo = FALSE, fig.width=8, fig.height=4}
# Simulate angular dependence for different sized molecules
angles <- seq(15, 165, by = 5)
sin2_half <- sin(angles * pi / 360)^2

# Small molecule (Rg << lambda): flat
small_rg <- rep(1.0, length(angles))

# Medium molecule
medium_rg <- 1 + 0.5 * sin2_half

# Large molecule
large_rg <- 1 + 1.5 * sin2_half

angular_data <- tibble(
  sin2_half = rep(sin2_half, 3),
  kc_r = c(small_rg, medium_rg, large_rg),
  size = rep(c("Small (Rg < 10 nm)", "Medium (Rg ~ 30 nm)", "Large (Rg > 50 nm)"),
             each = length(angles))
)

ggplot(angular_data, aes(sin2_half, kc_r, color = size)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2, alpha = 0.5) +
  scale_color_manual(values = c(
    "Small (Rg < 10 nm)" = "#2E86AB",
    "Medium (Rg ~ 30 nm)" = "#A23B72",
    "Large (Rg > 50 nm)" = "#E8751A"
  )) +
  labs(
    x = expression(sin^2*(theta/2)),
    y = "Kc/R(θ) (normalized)",
    color = "Molecule Size",
    title = "Angular Dependence in MALS",
    subtitle = "Larger molecules show steeper slope → higher Rg"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Calculating Rg

From the Zimm equation, the slope of Kc/R(θ) vs sin²(θ/2) gives Rg:

$$\frac{Kc}{R(\theta)} = \frac{1}{M_w}\left(1 + \frac{16\pi^2 n_0^2}{3\lambda^2}R_g^2 \sin^2(\theta/2)\right)$$

The y-intercept gives 1/Mw, and the slope gives Rg².

## Formalisms for Angular Extrapolation

### Zimm, Debye, and Berry

Three common approaches for angular extrapolation:

| Formalism | Plot | Best For |
|-----------|------|----------|
| **Zimm** | Kc/R vs sin²(θ/2) | Random coils, most polymers |
| **Debye** | Kc/R vs sin²(θ/2) | Similar to Zimm |
| **Berry** | √(Kc/R) vs sin²(θ/2) | Very large particles, aggregates |

```{r formalisms-concept, echo = FALSE, fig.width=8, fig.height=4}
# Show how different formalisms handle the same data
sin2_vals <- seq(0, 1, by = 0.1)
n_pts <- length(sin2_vals)

# Simulated data with curvature (large particle)
true_kc_r <- 1 + 1.5 * sin2_vals + 0.3 * sin2_vals^2  # Curved data

formalism_data <- tibble(
  sin2 = rep(sin2_vals, 2),
  y_value = c(
    true_kc_r,        # Zimm
    sqrt(true_kc_r)   # Berry
  ),
  display = rep(c("Zimm", "Berry"), each = n_pts)
)

ggplot(formalism_data, aes(sin2, y_value, color = display)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +
  scale_color_manual(values = c("Zimm" = "#2E86AB", "Berry" = "#A23B72")) +
  facet_wrap(~display, scales = "free_y") +
  labs(
    x = expression(sin^2*(theta/2)),
    y = "Transformed value",
    color = "Formalism",
    title = "Choosing the Right Formalism",
    subtitle = "Berry linearizes curved data from large particles"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

**Choosing a formalism:**

- **Start with Zimm** - works for most polymers
- **Use Berry** if Zimm plot shows significant curvature
- **Berry is essential** for Rg > 50 nm or aggregates

## Example Dataset

```{r data}
data(sec_triple_detect, package = "measure.sec")

# Select samples with MALS data
mals_samples <- sec_triple_detect |>
  filter(sample_type == "sample")

glimpse(mals_samples)
```

## MALS Workflow with measure.sec

### Basic MALS Analysis

```{r mals-workflow}
# Complete MALS workflow for absolute MW
rec_mals <- recipe(
  ri_signal + mals_signal + elution_time + dn_dc ~ sample_id,
  data = mals_samples
) |>
  update_role(sample_id, new_role = "id") |>
  # Convert signals to measure format
  step_measure_input_long(ri_signal, location = vars(elution_time), col_name = "ri") |>
  step_measure_input_long(mals_signal, location = vars(elution_time), col_name = "mals") |>
  # Baseline correction
  step_sec_baseline(measures = c("ri", "mals")) |>
  # Process RI for concentration
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc") |>
  # Convert RI to concentration
  step_sec_concentration(
    measures = "ri",
    detector = "ri",
    injection_volume = 100,       # µL
    sample_concentration = 2.0    # mg/mL
  ) |>
  # MALS processing for absolute MW
  step_sec_mals(
    mals_col = "mals",
    dn_dc_column = "dn_dc",
    wavelength = 658,             # nm (common MALS laser)
    solvent_ri = 1.407,           # THF
    angles = 90                   # Single angle for this example
  )

prepped_mals <- prep(rec_mals)
result_mals <- bake(prepped_mals, new_data = NULL)

# View results
result_mals |>
  select(sample_id, ri, mals, mw_mals) |>
  head(3)
```

### Key Parameters

| Parameter | Description | Typical Values |
|-----------|-------------|----------------|
| `dn_dc` | Refractive index increment | 0.185 (PS/THF), 0.084 (PMMA/THF) |
| `wavelength` | Laser wavelength (nm) | 658, 690, 785 |
| `solvent_ri` | Solvent refractive index | 1.333 (water), 1.407 (THF) |
| `angles` | Detection angle(s) | 90 (single), c(35, 50, 75, 90, 105, 120, 145) (multi) |
| `formalism` | Extrapolation method | "zimm", "debye", "berry" |

## The Critical Role of dn/dc

### What is dn/dc?

The refractive index increment (dn/dc) is the change in solution refractive index per unit concentration:

$$\frac{dn}{dc} = \frac{n_{solution} - n_{solvent}}{c}$$

### Typical dn/dc Values

| Polymer | Solvent | dn/dc (mL/g) |
|---------|---------|--------------|
| Polystyrene | THF | 0.185 |
| PMMA | THF | 0.084 |
| PEG/PEO | Water | 0.135 |
| Proteins | Aqueous buffer | ~0.185 |
| DNA | Aqueous | ~0.170 |

### Measuring dn/dc

For accurate MALS, measure dn/dc using:

1. **Differential refractometer** with known concentrations
2. **Batch-mode measurement** (most accurate)
3. **Online measurement** during SEC (convenient but less accurate)

**Warning**: Using literature dn/dc values can introduce 5-20% error in MW.

## Multi-Angle Detection

### Setting Up Multi-Angle Analysis

For Rg determination, provide multiple detection angles:

```{r multi-angle, eval = FALSE}
# Multi-angle MALS for MW and Rg
step_sec_mals(
  mals_col = "mals",
  dn_dc = 0.185,
  wavelength = 658,
  solvent_ri = 1.407,
  angles = c(35, 50, 75, 90, 105, 120, 145),  # Typical MALS detector angles
  formalism = "zimm"                           # Try "berry" for large particles
)
```

### Interpreting Rg Results

| Rg Range | Interpretation |
|----------|----------------|
| < 10 nm | Small molecules, Rg may be unreliable |
| 10-50 nm | Typical random coil polymers |
| 50-100 nm | Large polymers, branched structures |
| > 100 nm | Very large or aggregated species |

## Conformation Analysis

### Rg vs MW Relationship

The relationship between Rg and MW reveals polymer conformation:

$$R_g = K \cdot M_w^\nu$$

Where ν (the scaling exponent) indicates conformation:

| ν Value | Conformation |
|---------|--------------|
| 0.33 | Hard sphere |
| 0.5-0.6 | Random coil (theta conditions) |
| 0.6-0.7 | Random coil (good solvent) |
| 1.0 | Rigid rod |

```{r conformation-concept, echo = FALSE, fig.width=7, fig.height=5}
# Illustrate Rg vs MW for different conformations
mw_vals <- 10^seq(4, 7, by = 0.1)
n_mw <- length(mw_vals)

conformations <- tibble(
  mw = rep(mw_vals, 3),
  conformation = rep(c("Sphere (ν=0.33)", "Random coil (ν=0.59)", "Rod (ν=1.0)"), each = n_mw),
  rg = c(
    0.1 * mw_vals^0.33,    # Sphere
    0.02 * mw_vals^0.59,   # Random coil
    0.001 * mw_vals^1.0    # Rod
  )
)

ggplot(conformations, aes(mw, rg, color = conformation)) +
  geom_line(linewidth = 1.2) +
  scale_x_log10(labels = scales::label_scientific()) +
  scale_y_log10() +
  scale_color_manual(values = c(
    "Sphere (ν=0.33)" = "#2E86AB",
    "Random coil (ν=0.59)" = "#A23B72",
    "Rod (ν=1.0)" = "#E8751A"
  )) +
  labs(
    x = "Molecular Weight (Da)",
    y = "Radius of Gyration (nm)",
    color = "Conformation",
    title = "Conformation from Rg vs MW Plot",
    subtitle = "Slope on log-log plot = scaling exponent ν"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

## Troubleshooting

### Common MALS Issues

| Problem | Possible Causes | Solutions |
|---------|-----------------|-----------|
| Noisy MW data | Low concentration, dust | Increase conc, filter samples |
| Negative MW | Baseline issues | Improve baseline, check alignment |
| MW too high | Aggregates, dust | Filter samples, check for aggregation |
| MW too low | Wrong dn/dc | Measure dn/dc accurately |
| Inconsistent Rg | Poor signal, few angles | Use more angles, increase concentration |

### Signal-to-Noise Requirements

MALS requires good signal-to-noise for accurate results:

- **Minimum concentration**: 0.5-1 mg/mL for most polymers
- **Higher for low MW**: Small molecules scatter less
- **Lower for very high MW**: Large molecules scatter strongly

### Detector Alignment

Ensure proper detector alignment:

1. **Inter-detector delay** - Correct for time offset between RI and MALS
2. **Normalization** - Calibrate MALS using toluene or known standard
3. **Angle calibration** - Verify detector angles are accurate

## When to Use MALS vs Conventional Calibration

| Scenario | Recommendation |
|----------|----------------|
| Routine QC of known polymer | Conventional cal is faster and sufficient |
| Different polymer from standards | **Use MALS** |
| Branched or complex architecture | **Use MALS** |
| Absolute MW required | **Use MALS** |
| Characterizing new materials | **Use MALS** |
| Regulatory submissions | **Use MALS** for accuracy |

## See Also

- [Getting Started](getting-started.html) - Basic SEC workflow
- [LALS and RALS Detection](lals-rals-detection.html) - Simpler light scattering alternatives
- [Multi-Detector SEC](triple-detection.html) - RI + Viscometer + LS workflows
- [System Suitability](system-suitability.html) - QC metrics for MALS

## Session Info

```{r session-info}
sessionInfo()
```
