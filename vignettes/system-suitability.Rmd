---
title: "System Suitability and QC"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{System Suitability and QC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Overview

System Suitability Testing (SST) ensures your SEC system is performing adequately before analyzing samples. This guide shows you how to:
1. Extract peak parameters from chromatogram data
2. Calculate key SST metrics (resolution, plate count, asymmetry)
3. Run comprehensive system suitability tests
4. Track column performance over time

## Quick Reference: Typical Acceptance Criteria

| Parameter | Symbol | Typical Limit | Notes |
|-----------|--------|---------------|-------|
| Resolution | Rs | >= 1.5 | Between critical pair |
| Plate count | N | >= 5,000 | For main peak |
| Tailing factor | Tf | 0.8 - 1.5 | USP method at 5% height |
| Mass recovery | % | 95 - 105% | Detected vs. injected |
| Retention RSD | %RSD | <= 1.0% | Across replicates |
| Area RSD | %RSD | <= 2.0% | Across replicates |

## Setup

```{r setup}
library(measure)
library(measure.sec)
library(dplyr)
library(ggplot2)
```

## Starting from Chromatogram Data

In real-world SST, you start with a chromatogram from your SEC system. Let's use the `sec_protein` dataset which contains UV detection data from a protein SEC analysis with multiple species.

### Visualize the Chromatogram

```{r chromatogram-plot, fig.height=4}
# Load protein SEC data
data(sec_protein)

# Look at the reference standard
reference <- sec_protein |>
  filter(sample_id == "mAb-Reference")

# Plot the chromatogram
ggplot(reference, aes(x = elution_time, y = uv_280_signal)) +
  geom_line(color = "#2E86AB", linewidth = 0.8) +
  labs(
    x = "Elution Time (min)",
    y = "UV 280 nm Signal (AU)",
    title = "Protein SEC Chromatogram",
    subtitle = "mAb Reference Standard"
  ) +
  theme_minimal()
```

### Understanding Peak Parameters

Your chromatography software typically reports a **peak table** with these key parameters:

| Parameter | What It Measures | How It's Determined |
|-----------|------------------|---------------------|
| **Retention time** | When peak apex elutes | Time at maximum signal |
| **Peak width** | How broad the peak is | Width at baseline or half-height |
| **Peak area** | Amount of material | Integrated signal |
| **Leading width** | Front half-width | Distance from front edge to apex |
| **Tailing width** | Back half-width | Distance from apex to back edge |

For this example, let's define peak parameters based on the chromatogram above. In practice, these come from your integration software:

```{r define-peaks}
# Peak parameters from integration (typical protein SEC)
# These represent what your software would report
peaks <- data.frame(
  name = c("HMW", "Dimer", "Monomer", "Fragment"),
  retention = c(6.8, 8.2, 10.5, 13.1),   # minutes
  width = c(0.35, 0.28, 0.42, 0.38),      # width at half height (for SST)
  width_base = c(0.70, 0.56, 0.84, 0.76), # width at baseline
  area = c(0.8, 1.2, 96.5, 1.5),          # % of total
  height = c(0.018, 0.025, 0.350, 0.022)  # AU
)

peaks
```

## How QC Metrics Are Calculated

### Resolution: Measuring Peak Separation

Resolution quantifies how well two adjacent peaks are separated. It uses **retention times** and **peak widths** from your peak table.

```{r resolution-explained, fig.height=3.5}
# Extract parameters for dimer and monomer peaks
dimer <- peaks |> filter(name == "Dimer")
monomer <- peaks |> filter(name == "Monomer")

# Show the calculation
cat("Dimer retention:", dimer$retention, "min\n")
cat("Monomer retention:", monomer$retention, "min\n")
cat("Dimer baseline width:", dimer$width_base, "min\n")
cat("Monomer baseline width:", monomer$width_base, "min\n")
cat("\n")

# USP Resolution formula: Rs = 2(t2 - t1) / (w1 + w2)
Rs <- measure_sec_resolution(
  retention_1 = dimer$retention,
  retention_2 = monomer$retention,
  width_1 = dimer$width_base,
  width_2 = monomer$width_base,
  method = "usp"
)

cat("Resolution (USP) = 2 ×", monomer$retention - dimer$retention,
    "/ (", dimer$width_base, "+", monomer$width_base, ")\n")
cat("                 =", round(Rs, 2), "\n")
```

**Interpretation:**
- Rs < 1.0: Peaks overlap significantly
- Rs = 1.5: Baseline separation (~99.7% resolved)
- Rs > 2.0: Complete separation with baseline gap

### Plate Count: Measuring Column Efficiency

Plate count measures how sharp your peaks are. Sharper peaks = more plates = better efficiency. It uses **retention time** and **peak width**.

```{r plates-explained}
# For the monomer peak (main peak)
cat("Monomer retention:", monomer$retention, "min\n")
cat("Monomer half-height width:", monomer$width, "min\n")
cat("\n")

# USP formula for half-height: N = 5.54 × (tR / w0.5)²
N <- measure_sec_plate_count(
  retention = monomer$retention,
  width = monomer$width,
  width_type = "half_height"
)

cat("Plate count = 5.54 × (", monomer$retention, "/", monomer$width, ")²\n")
cat("            = 5.54 ×", round((monomer$retention / monomer$width)^2, 1), "\n")
cat("            =", round(N), "plates\n")
```

**What affects plate count:**
- Column packing quality
- Flow rate (too fast = lower N)
- Sample overloading
- Extra-column dispersion (tubing, fittings)

### Peak Asymmetry: Checking Peak Shape

Asymmetry measures whether a peak is symmetric (ideal) or tailing/fronting. It compares the **leading half-width** to the **tailing half-width** at a specific height.

```{r asymmetry-explained, fig.height=3}
# For asymmetry, we need leading and tailing half-widths
# (measured at 5% height for USP, 10% height for EP)
# Let's assume slight tailing for the monomer:
leading_width <- 0.20   # front half-width at 5% height
tailing_width <- 0.24   # back half-width at 5% height

cat("Leading half-width (at 5%):", leading_width, "min\n")
cat("Tailing half-width (at 5%):", tailing_width, "min\n")
cat("\n")

# USP Tailing Factor: Tf = (a + b) / 2a
Tf <- measure_sec_asymmetry(
  leading = leading_width,
  tailing = tailing_width,
  method = "usp"
)

cat("Tailing factor = (", leading_width, "+", tailing_width, ") / (2 ×", leading_width, ")\n")
cat("               =", round(Tf, 2), "\n")
cat("\nInterpretation: Tf =", round(Tf, 2))
if (Tf >= 0.8 && Tf <= 1.5) {
  cat(" → Pass (acceptable range 0.8-1.5)\n")
} else {
  cat(" → Investigate\n")
}
```

### Mass Recovery: Verifying Complete Detection

Recovery checks that all injected sample was detected. This requires knowing the **injected mass** and comparing to **detected mass** from integration.

```{r recovery-explained}
# Typical protein SEC injection
injected_mass <- 0.050   # mg (50 µg)
detected_mass <- 0.048   # mg from integration area and response factor

recovery <- measure_sec_recovery(
  detected_mass = detected_mass,
  injected_mass = injected_mass
)

cat("Injected mass:", injected_mass * 1000, "µg\n")
cat("Detected mass:", detected_mass * 1000, "µg\n")
cat("Recovery:", round(recovery, 1), "%\n")
```

**Low recovery causes:**
- Sample adsorption to column/tubing
- Aggregation during analysis
- Detector calibration drift
- Baseline integration errors

## Running Comprehensive SST

Once you understand how each metric is calculated, you can run a complete SST evaluation.

### Basic System Suitability Test

```{r sst-basic}
# Use the peak table we defined earlier
sst <- measure_sec_suitability(
  peaks = peaks,
  reference_peaks = c("Dimer", "Monomer"),  # Critical pair for resolution
  column_length = 30  # cm
)

print(sst)
```

### SST with Custom (Stricter) Criteria

For validated biopharmaceutical methods:

```{r sst-strict}
strict_criteria <- list(
  resolution_min = 2.0,
  plate_count_min = 8000,
  tailing_min = 0.9,
  tailing_max = 1.3,
  recovery_min = 97,
  recovery_max = 103,
  retention_rsd_max = 0.5,
  area_rsd_max = 1.0
)

sst_strict <- measure_sec_suitability(
  peaks = peaks,
  reference_peaks = c("Dimer", "Monomer"),
  criteria = strict_criteria
)

print(sst_strict)
```

### SST with Replicate Injections

For precision assessment, your peak table includes multiple injections:

```{r sst-replicates}
# 6 replicate injections of the same sample
peaks_reps <- data.frame(
  name = rep(c("Dimer", "Monomer"), each = 6),
  replicate = rep(1:6, 2),
  retention = c(
    8.22, 8.21, 8.23, 8.20, 8.22, 8.21,  # Dimer
    10.50, 10.51, 10.49, 10.52, 10.50, 10.51   # Monomer
  ),
  width = c(
    0.28, 0.27, 0.28, 0.28, 0.29, 0.28,
    0.42, 0.41, 0.42, 0.41, 0.42, 0.42
  ),
  area = c(
    1.2, 1.3, 1.2, 1.1, 1.2, 1.2,
    96.5, 96.2, 96.7, 96.4, 96.5, 96.6
  )
)

sst_reps <- measure_sec_suitability(
  peaks = peaks_reps,
  reference_peaks = c("Dimer", "Monomer")
)

summary(sst_reps)
```

## Tracking Column Performance Over Time

Use SST data from daily runs to monitor column aging.

### Column Performance Log

```{r tracking-data}
# SST results collected over several months
set.seed(42)
dates <- seq(as.Date("2024-01-01"), as.Date("2024-06-01"), by = "week")
n_weeks <- length(dates)

# Simulated gradual column degradation
column_log <- tibble(
  date = dates,
  plates = seq(25000, 19500, length.out = n_weeks) + rnorm(n_weeks, 0, 300),
  resolution = seq(2.5, 1.95, length.out = n_weeks) + rnorm(n_weeks, 0, 0.05),
  asymmetry = seq(1.02, 1.25, length.out = n_weeks) + rnorm(n_weeks, 0, 0.02)
)
```

### Visualizing Trends

```{r tracking-plot, fig.width=8, fig.height=5}
ggplot(column_log, aes(date)) +
  geom_line(aes(y = plates / 10000), color = "#2E86AB", linewidth = 1) +
  geom_point(aes(y = plates / 10000), color = "#2E86AB", size = 2) +
  geom_line(aes(y = resolution), color = "#A23B72", linewidth = 1) +
  geom_point(aes(y = resolution), color = "#A23B72", size = 2) +
  geom_hline(yintercept = 1.5, linetype = "dashed", color = "#A23B72", alpha = 0.7) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "#2E86AB", alpha = 0.7) +
  annotate("text", x = as.Date("2024-01-15"), y = 1.55,
           label = "Rs limit (1.5)", color = "#A23B72", size = 3) +
  annotate("text", x = as.Date("2024-01-15"), y = 1.05,
           label = "N limit (10k)", color = "#2E86AB", size = 3) +
  scale_y_continuous(
    name = "Resolution",
    sec.axis = sec_axis(~ . * 10000, name = "Theoretical Plates")
  ) +
  labs(
    x = "Date",
    title = "Column Performance Tracking",
    subtitle = "Resolution (pink) and plate count (blue) over time"
  ) +
  theme_minimal() +
  theme(
    axis.title.y.left = element_text(color = "#A23B72"),
    axis.title.y.right = element_text(color = "#2E86AB")
  )
```

### Predicting Column Replacement

```{r lifetime}
min_plates <- 10000
min_resolution <- 1.5

column_log <- column_log |>
  mutate(
    plates_ok = plates > min_plates,
    resolution_ok = resolution > min_resolution,
    overall_ok = plates_ok & resolution_ok
  )

first_failure <- which(!column_log$overall_ok)[1]

if (!is.na(first_failure)) {
  cat("Column replacement needed at week:", first_failure, "\n")
  cat("Date:", format(column_log$date[first_failure]), "\n")
  cat("Resolution at failure:", round(column_log$resolution[first_failure], 2), "\n")
  cat("Plates at failure:", round(column_log$plates[first_failure]), "\n")
} else {
  cat("Column still within specifications\n")
}
```

## Troubleshooting Guide

### Low Resolution

| Cause | Check | Fix |
|-------|-------|-----|
| Column degradation | Plate count trending down | Replace column |
| Overloading | Peak width increases with load | Reduce injection |
| Mobile phase | Buffer age, contamination | Fresh mobile phase |

### Peak Tailing (Tf > 1.5)

| Cause | Check | Fix |
|-------|-------|-----|
| Column void | Retention time shifted | Replace column |
| Secondary interactions | Peaks worse for some analytes | Adjust pH/salt |
| System dead volume | All peaks affected | Check fittings |

### Low Plate Count

| Cause | Check | Fix |
|-------|-------|-----|
| Column degradation | Compare to new column | Replace column |
| Flow rate too high | N decreases with flow | Optimize flow |
| Temperature instability | N varies run-to-run | Thermostat column |

### Low Recovery (< 95%)

| Cause | Check | Fix |
|-------|-------|-----|
| Adsorption | Worse for sticky proteins | Increase ionic strength |
| Aggregation | HMW increases over run | Fresh sample, lower concentration |
| Integration error | Baseline drift | Reintegrate |

## Regulatory References

### USP <621>

| Parameter | Requirement |
|-----------|-------------|
| Resolution | Rs >= 2.0 (unless specified) |
| Tailing | T <= 2.0 |
| RSD (n >= 5) | <= 2.0% for areas |

### ICH Q2(R1)

- **Precision**: %RSD of replicate injections
- **Accuracy**: Recovery from spiked samples
- **Specificity**: Resolution from impurities

### SST Frequency

| Situation | SST Level |
|-----------|-----------|
| Start of sequence | Full SST |
| Every 10-20 injections | Bracketing standard |
| After mobile phase change | Full SST |
| After column change | Full SST + qualification |

## Session Info

```{r session-info}
sessionInfo()
```
