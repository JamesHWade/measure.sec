---
title: "Size Exclusion Chromatography Analysis with measure.sec"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Size Exclusion Chromatography Analysis with measure.sec}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

Size Exclusion Chromatography (SEC), also known as Gel Permeation Chromatography (GPC), is a fundamental technique for characterizing the molecular weight distribution of polymers, proteins, and other macromolecules. The **measure.sec** package extends the [measure](https://github.com/JamesHWade/measure) package with specialized preprocessing steps for SEC/GPC data analysis.
This vignette demonstrates how to:

1. Process multi-detector SEC data (RI, UV/DAD, MALS, LALS, RALS, DLS)
2. Calculate molecular weight averages and distributions
3. Analyze copolymer composition
4. Quantify protein aggregates
5. Perform quality control checks

## Setup

```{r setup}
library(measure)
library(measure.sec)
library(recipes)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
```

## The measure.sec Data Model

The package uses the **measure** framework, where chromatographic signals are stored as nested tibbles. Each sample has a `measure_tbl` containing:

- `location`: Elution time or volume
- `value`: Detector response

Multiple samples are combined into a `measure_list` column.

## Example Dataset

The package includes `sec_triple_detect`, a synthetic dataset representing multi-detector SEC analysis:

```{r data}
data(sec_triple_detect, package = "measure.sec")

# Overview of the dataset
glimpse(sec_triple_detect)

# Sample types included
sec_triple_detect |>
  distinct(sample_id, sample_type, polymer_type) |>
  print(n = 12)
```

## Basic Workflow: Single Detector Analysis

Let's start with a simple RI detector workflow for polystyrene standards:

```{r basic-workflow, eval = FALSE}
# Filter to PS standards
ps_standards <- sec_triple_detect |>
  filter(polymer_type == "polystyrene")

# Create the preprocessing recipe
# Note: The formula specifies which columns to use and sample_id as grouping
rec <- recipe(
  ri_signal + elution_time + dn_dc + known_mw ~ sample_id,
  data = ps_standards
) |>
  update_role(sample_id, new_role = "id") |>
  # Convert to measure format
  step_measure_input_long(
    ri_signal,
    location = vars(elution_time),
    col_name = "ri"
  ) |>
  # Apply baseline correction
  step_sec_baseline(measures = "ri") |>
  # Process RI detector with dn/dc
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc") |>
  # Calculate molecular weight averages
  step_sec_mw_averages(mw_column = "known_mw")

# Prep and bake
prepped <- prep(rec)
result <- bake(prepped, new_data = NULL)

# View results
result |>
  select(sample_id, Mn, Mw, Mz, dispersity)
```

## Conventional Calibration

Conventional (relative) calibration uses narrow molecular weight standards to establish the relationship between elution time and molecular weight. This is the most common approach for routine polymer analysis.

### Calibration Standards

The package includes comprehensive polystyrene and PMMA calibration standards:
```{r calibration-data}
# Load polystyrene calibration standards
data(sec_ps_standards, package = "measure.sec")

# View the standards (16 standards from 162 Da to 3.15 MDa)
sec_ps_standards |>
  select(standard_name, mp, log_mp, retention_time, dispersity) |>
  print(n = 8)
```

### Visualizing the Calibration Curve

Before fitting, it's good practice to visualize the standards:

```{r calibration-plot, fig.width=7, fig.height=5}
ggplot(sec_ps_standards, aes(retention_time, log_mp)) +
  geom_point(size = 3, color = "#2E86AB") +
  geom_smooth(
    method = "lm",
    formula = y ~ poly(x, 3),
    se = TRUE,
    color = "#A23B72",
    fill = "#A23B72",
    alpha = 0.2
  ) +
  labs(
    x = "Retention Time (min)",
    y = expression(log[10](M[p])),
    title = "Polystyrene Calibration Curve",
    subtitle = "Cubic polynomial fit with 95% confidence band"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title = element_text(size = 11)
  )
```

### Building a Calibration Curve

Use `step_sec_conventional_cal()` to fit the calibration and apply it to samples:

```{r conventional-cal, eval = FALSE}
# Prepare standards for the step (needs 'retention' and 'log_mw' columns)
ps_cal <- sec_ps_standards |>
  select(retention = retention_time, log_mw = log_mp)

# Filter to a polystyrene sample for demonstration
ps_sample <- sec_triple_detect |>
  filter(sample_id == "PS-50K")

# Build the calibration recipe
# Note: Use explicit formula with sample_id as the grouping variable
rec_cal <- recipe(
  ri_signal + elution_time + dn_dc ~ sample_id,
  data = ps_sample
) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_input_long(
    ri_signal,
    location = vars(elution_time),
    col_name = "ri"
  ) |>
  step_sec_baseline(measures = "ri") |>
  step_sec_conventional_cal(
    standards = ps_cal,
    fit_type = "cubic",
    output_col = "log_mw",
    extrapolation = "none"
  ) |>
  step_sec_mw_averages(measures = "log_mw")

# Prep and bake
prepped <- prep(rec_cal)
result <- bake(prepped, new_data = NULL)

# View molecular weight results
result |>
  select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity)
```

### Assessing Calibration Quality

The `tidy()` method provides comprehensive diagnostics for evaluating calibration quality:

```{r calibration-diagnostics, eval = FALSE}
# Get calibration diagnostics
diagnostics <- tidy(prepped, number = 3)  # step_sec_conventional_cal is step 3

# Overview metrics
diagnostics |>
  select(fit_type, n_standards, r_squared, rmse_log_mw, max_abs_pct_deviation)

# Access per-standard residuals
std_results <- diagnostics$standard_results[[1]]
std_results |>
  select(
    location,
    actual_log_mw,
    predicted_log_mw,
    residual_log_mw,
    pct_deviation
  )
```

**Key quality metrics:**

| Metric | Good Value | Description |
|--------|------------|-------------|
| R² | > 0.999 | Coefficient of determination |
| RMSE | < 0.02 | Root mean square error in log(MW) |
| Max % Deviation | < 5% | Largest deviation at any standard |
| Dispersity | < 1.10 | Standards should be narrow |

### Comparing Fit Types

Different polynomial orders may be appropriate depending on column behavior:

```{r compare-fits, fig.width=8, fig.height=5}
# Compare linear, quadratic, and cubic fits
library(tidyr)

fits <- tibble(
  fit_type = c("Linear", "Quadratic", "Cubic"),
  degree = c(1, 2, 3)
) |>
  mutate(
    predictions = map(degree, function(d) {
      model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)
      tibble(
        retention_time = seq(11, 21, by = 0.1),
        log_mp = predict(model, newdata = tibble(retention_time = seq(11, 21, by = 0.1)))
      )
    }),
    r_squared = map_dbl(degree, function(d) {
      model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)
      summary(model)$r.squared
    })
  )

fit_curves <- fits |>
  unnest(predictions)

ggplot() +
  geom_point(
    data = sec_ps_standards,
    aes(retention_time, log_mp),
    size = 3,
    alpha = 0.7
  ) +
  geom_line(
    data = fit_curves,
    aes(retention_time, log_mp, color = fit_type),
    linewidth = 1
  ) +
  scale_color_manual(
    values = c("Linear" = "#E8751A", "Quadratic" = "#2E86AB", "Cubic" = "#A23B72")
  ) +
  labs(
    x = "Retention Time (min)",
    y = expression(log[10](M[p])),
    color = "Fit Type",
    title = "Calibration Curve Fit Comparison",
    subtitle = sprintf(
      "R²: Linear=%.5f, Quadratic=%.5f, Cubic=%.5f",
      fits$r_squared[1], fits$r_squared[2], fits$r_squared[3]
    )
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold")
  )
```

### Polymer-Specific Calibration

Conventional calibration is polymer-specific because different polymers have different hydrodynamic volumes at the same molecular weight:

```{r polymer-comparison, fig.width=7, fig.height=5}
data(sec_pmma_standards, package = "measure.sec")

# Combine PS and PMMA for comparison
combined <- bind_rows(
  sec_ps_standards |> mutate(polymer = "Polystyrene"),
  sec_pmma_standards |> mutate(polymer = "PMMA")
)

ggplot(combined, aes(retention_time, log_mp, color = polymer, shape = polymer)) +
  geom_point(size = 3) +
  geom_smooth(
    method = "lm",
    formula = y ~ poly(x, 3),
    se = FALSE,
    linewidth = 1
  ) +
  scale_color_manual(values = c("Polystyrene" = "#2E86AB", "PMMA" = "#A23B72")) +
  labs(
    x = "Retention Time (min)",
    y = expression(log[10](M[p])),
    color = "Polymer",
    shape = "Polymer",
    title = "PS vs PMMA Calibration Curves",
    subtitle = "At same MW, PMMA elutes later (smaller hydrodynamic volume in THF)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold")
  )
```

**Key insight:** Using a PS calibration for PMMA samples will underestimate molecular weight. For cross-polymer analysis, use universal calibration with Mark-Houwink parameters.

## Multi-Detector SEC Workflow

For more accurate molecular weight determination, multi-detector SEC uses RI for concentration and MALS for absolute molecular weight:

```{r multi-detector, eval = FALSE}
# Multi-detector SEC workflow for absolute molecular weight
# Note: MALS processing requires additional detector configuration
rec_multi <- recipe(
  ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef ~ sample_id,
  data = sec_triple_detect
) |>
  update_role(sample_id, new_role = "id") |>
  # Convert each detector to measure format
  step_measure_input_long(
    ri_signal,
    location = vars(elution_time),
    col_name = "ri"
  ) |>
  step_measure_input_long(
    uv_signal,
    location = vars(elution_time),
    col_name = "uv"
  ) |>
  step_measure_input_long(
    mals_signal,
    location = vars(elution_time),
    col_name = "mals"
  ) |>
  # Correct inter-detector delays
  step_sec_detector_delay(
    reference = "ri",
    delay_volumes = c(uv = -0.05, mals = 0.10)
  ) |>
  # Apply baseline correction
  step_sec_baseline(measures = c("ri", "uv", "mals")) |>
  # Process detectors
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc") |>
  step_sec_uv(measures = "uv", extinction_column = "extinction_coef") |>
  step_sec_mals(measures = "mals", dn_dc_column = "dn_dc") |>
  # Convert to concentration
  step_sec_concentration(measures = "ri", detector = "ri") |>
  # Calculate MW averages from MALS-derived MW
  step_sec_mw_averages(mw_column = "mw_mals")

prepped_multi <- prep(rec_multi)
result_multi <- bake(prepped_multi, new_data = NULL)
```

## Copolymer Composition Analysis

The UV/RI ratio can reveal compositional heterogeneity across the molecular weight distribution:

```{r composition, eval = FALSE}
# Filter to copolymer samples
copolymers <- sec_triple_detect |>
  filter(polymer_type == "copolymer")

rec_comp <- recipe(
  ri_signal + uv_signal + elution_time ~ sample_id,
  data = copolymers
) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_input_long(ri_signal, location = vars(elution_time), col_name = "ri") |>
  step_measure_input_long(uv_signal, location = vars(elution_time), col_name = "uv") |>
  step_sec_baseline(measures = c("ri", "uv")) |>
  # Calculate UV/RI ratio
  step_sec_uv_ri_ratio(uv_col = "uv", ri_col = "ri", smooth = TRUE) |>
  # Calculate composition (requires known response factors)
  step_sec_composition(
    uv_col = "uv",
    ri_col = "ri",
    component_a_uv = 1.0,   # UV response factor for component A
    component_a_ri = 0.185, # RI response factor for component A
    component_b_uv = 0.1,   # UV response factor for component B
    component_b_ri = 0.084  # RI response factor for component B
  )

prepped_comp <- prep(rec_comp)
result_comp <- bake(prepped_comp, new_data = NULL)

# The result contains:
# - uv_ri_ratio: Point-by-point UV/RI ratio
# - composition_a: Weight fraction of component A at each point
```

## Protein SEC: Aggregate Quantitation

For protein therapeutics, SEC is used to quantify high molecular weight species (HMWS/aggregates) and low molecular weight species (LMWS/fragments):

```{r protein-sec, eval = FALSE}
# Create protein-like data (using UV at 280 nm)
protein_data <- sec_triple_detect |>
  filter(sample_type == "sample") |>
  head(1)

rec_protein <- recipe(
  uv_signal + elution_time ~ sample_id,
  data = protein_data
) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_input_long(uv_signal, location = vars(elution_time), col_name = "uv") |>
  step_sec_baseline(measures = "uv") |>
  # Quantify aggregates with manual peak boundaries
  step_sec_aggregates(
    measures = "uv",
    monomer_start = 10,  # Monomer peak start time
    monomer_end = 14,    # Monomer peak end time
    method = "manual"
  )

prepped_protein <- prep(rec_protein)
result_protein <- bake(prepped_protein, new_data = NULL)

# Results include:
# - purity_hmws: % high MW species (before monomer)
# - purity_monomer: % main peak
# - purity_lmws: % low MW species (after monomer)
result_protein |>
  select(sample_id, purity_hmws, purity_monomer, purity_lmws)
```

## Molecular Weight Distribution

Generate differential and cumulative molecular weight distributions:
```{r mwd, eval = FALSE}
rec_mwd <- recipe(
  ri_signal + elution_time + dn_dc + known_mw ~ sample_id,
  data = sec_triple_detect
) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_input_long(ri_signal, location = vars(elution_time), col_name = "ri") |>
  step_sec_baseline(measures = "ri") |>
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc") |>
  # Add MW distribution curves
  step_sec_mw_distribution(
    signal_col = "ri",
    mw_column = "known_mw",
    output_type = "both"  # "differential", "cumulative", or "both"
  )

prepped_mwd <- prep(rec_mwd)
result_mwd <- bake(prepped_mwd, new_data = NULL)

# The result contains:
# - mwd_differential: dw/d(logM) vs logM
# - mwd_cumulative: cumulative weight fraction vs logM
```

## Quality Control Functions

The package provides functions for chromatographic system suitability testing:

### Peak Resolution

```{r resolution}
# Calculate USP resolution between two peaks
Rs <- measure_sec_resolution(
  retention_1 = 8.5,
  retention_2 = 10.0,
  width_1 = 0.3,
  width_2 = 0.35,
  method = "usp"
)

cat("Resolution (Rs):", round(Rs, 2), "\n")
```

### Plate Count

```{r plates}
# Calculate theoretical plates
N <- measure_sec_plate_count(
  retention = 10.0,
  width = 0.25,
  width_type = "half_height"
)

cat("Theoretical plates:", round(N), "\n")
```

### System Suitability

```{r sst}
# Comprehensive system suitability testing
peaks <- data.frame(
  name = c("dimer", "monomer"),
  retention = c(8.5, 10.0),
  width = c(0.3, 0.35),
  area = c(5, 95)
)

sst <- measure_sec_suitability(
  peaks = peaks,
  reference_peaks = c("dimer", "monomer")
)

print(sst)
```

## Polymer Analysis: Mark-Houwink Parameters

Estimate Mark-Houwink parameters from intrinsic viscosity data:

```{r mark-houwink}
# Molecular weight and intrinsic viscosity data
mw <- c(10000, 25000, 50000, 100000, 250000)
iv <- 0.0001 * mw^0.7  # Simulated data

mh <- measure_mh_parameters(mw, iv)
print(mh)
```

## Branching Analysis

Calculate branching indices for branched polymers:

```{r branching, eval = FALSE}
# Compare branched polymer to linear reference
mw <- c(100000, 200000, 500000)
rg_branched <- c(10, 15, 25)
rg_linear <- c(12, 18, 32)

g <- measure_branching_index(
  mw = mw,
  rg = rg_branched,
  reference = data.frame(mw = mw, rg = rg_linear),
  method = "g"
)

print(g)
# g < 1 indicates branching (smaller Rg than linear)
```

## Exporting Results

### Slice-by-Slice Data

Extract point-by-point chromatographic data:

```{r slice-table, eval = FALSE}
slices <- measure_sec_slice_table(
  result,
  measures = c("ri", "mw"),
  sample_id = "sample_id",
  pivot = TRUE  # Wide format with one column per measure
)

head(slices)
```

### Summary Table

Generate a summary table for reporting:

```{r summary-table, eval = FALSE}
summary <- measure_sec_summary_table(
  result,
  sample_id = "sample_id",
  digits = 0
)

print(summary)
```

## Complete Workflow Example

Here's a complete workflow for analyzing polymer standards:

```{r complete-workflow, eval = FALSE}
library(measure)
library(measure.sec)
library(recipes)

# Load data
data(sec_triple_detect, package = "measure.sec")

# Create comprehensive recipe with explicit formula
rec_complete <- recipe(
  ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef + known_mw + polymer_type ~ sample_id,
  data = sec_triple_detect
) |>
  update_role(sample_id, new_role = "id") |>
  # Input conversion
  step_measure_input_long(ri_signal, location = vars(elution_time), col_name = "ri") |>
  step_measure_input_long(uv_signal, location = vars(elution_time), col_name = "uv") |>
  step_measure_input_long(mals_signal, location = vars(elution_time), col_name = "mals") |>
  # Preprocessing
  step_sec_detector_delay(reference = "ri", delay_volumes = c(uv = -0.05, mals = 0.10)) |>
  step_sec_baseline(measures = c("ri", "uv", "mals")) |>
  # Detector processing
  step_sec_ri(measures = "ri", dn_dc_column = "dn_dc") |>
  step_sec_uv(measures = "uv", extinction_column = "extinction_coef") |>
  step_sec_mals(measures = "mals", dn_dc_column = "dn_dc") |>
  step_sec_concentration(measures = "ri", detector = "ri") |>
  # Molecular weight calculations
  step_sec_mw_averages(mw_column = "known_mw") |>
  step_sec_mw_fractions(mw_column = "known_mw", cutoffs = c(10000, 100000)) |>
  # Composition analysis
  step_sec_uv_ri_ratio(uv_col = "uv", ri_col = "ri")

# Process
prepped_complete <- prep(rec_complete)
result_complete <- bake(prepped_complete, new_data = NULL)

# View molecular weight results
result_complete |>
  select(sample_id, polymer_type, Mn, Mw, Mz, dispersity) |>
  print(n = 12)

# Generate summary
summary <- measure_sec_summary_table(result_complete, sample_id = "sample_id")
print(summary)
```

## Available Steps Reference

| Step | Category | Description |
|------|----------|-------------|
| `step_sec_detector_delay()` | Preprocessing | Correct inter-detector delays |
| `step_sec_baseline()` | Preprocessing | SEC-optimized baseline correction |
| `step_sec_ri()` | Detector | RI detector with dn/dc |
| `step_sec_uv()` | Detector | UV detector with extinction coefficient |
| `step_sec_dad()` | Detector | Diode array detector (multi-wavelength UV) |
| `step_sec_mals()` | Detector | Multi-angle light scattering |
| `step_sec_lals()` | Detector | Low-angle light scattering |
| `step_sec_rals()` | Detector | Right-angle light scattering |
| `step_sec_dls()` | Detector | Dynamic light scattering |
| `step_sec_viscometer()` | Detector | Differential viscometer |
| `step_sec_concentration()` | Calculation | Signal to concentration |
| `step_sec_intrinsic_visc()` | Calculation | Intrinsic viscosity |
| `step_sec_mw_averages()` | MW | Mn, Mw, Mz, dispersity |
| `step_sec_mw_fractions()` | MW | MW fractions above/below cutoffs |
| `step_sec_mw_distribution()` | MW | Differential/cumulative MWD |
| `step_sec_conventional_cal()` | Calibration | Narrow standard calibration |
| `step_sec_universal_cal()` | Calibration | Universal calibration |
| `step_sec_uv_ri_ratio()` | Composition | UV/RI ratio |
| `step_sec_composition()` | Composition | Copolymer composition |
| `step_sec_aggregates()` | Protein | HMWS/monomer/LMWS quantitation |

## See Also

For focused how-to guides on specific workflows:

- [Getting Started](getting-started.html) - Introduction and basic workflow
- [Multi-Detector SEC](triple-detection.html) - MALS, viscometer, and absolute MW
- [Protein SEC Analysis](protein-sec.html) - Biopharm aggregate/fragment analysis
- [Copolymer Composition](copolymer-analysis.html) - UV/RI ratio methods
- [Calibration Management](calibration-management.html) - Save/load calibrations
- [System Suitability](system-suitability.html) - QC metrics and SST

## Session Info

```{r session-info}
sessionInfo()
```
