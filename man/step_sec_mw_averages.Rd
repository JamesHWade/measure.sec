% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_sec_mw_averages.R
\name{step_sec_mw_averages}
\alias{step_sec_mw_averages}
\title{Calculate Molecular Weight Averages for SEC/GPC}
\usage{
step_sec_mw_averages(
  recipe,
  measures = NULL,
  calibration = NULL,
  integration_range = NULL,
  output_cols = c("mn", "mw", "mz", "mp", "dispersity"),
  include_uncertainty = FALSE,
  calibration_error = NULL,
  prefix = "mw_",
  role = "predictor",
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("sec_mw_averages")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{measures}{An optional character vector of measure column names.}

\item{calibration}{Calibration method for converting x-axis to log(MW).
Can be:
\itemize{
\item \code{NULL} (default): Assumes x-axis is already log10(MW)
\item A numeric vector of length 2: Linear calibration \code{c(slope, intercept)}
where \code{log10(MW) = slope * x + intercept}
\item \code{"auto"}: Estimate from data range (assumes typical polymer range)
}}

\item{integration_range}{Optional numeric vector \code{c(min, max)} specifying
the x-axis range for integration. If \code{NULL}, uses full range.}

\item{output_cols}{Character vector of metrics to calculate. Default
includes all: \code{c("mn", "mw", "mz", "mp", "dispersity")}.}

\item{include_uncertainty}{Logical. If \code{TRUE}, calculates and outputs
uncertainty estimates for MW averages. Requires \code{calibration_error} to
be specified. Default is \code{FALSE}.}

\item{calibration_error}{Calibration error (RMSE) in log10(MW) units for
uncertainty propagation. Required when \code{include_uncertainty = TRUE}.
Can be obtained from \code{tidy()} output of \code{step_sec_conventional_cal()}.}

\item{prefix}{Prefix for output column names. Default is \code{"mw_"}.}

\item{role}{Role for generated columns. Default is \code{"predictor"}.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_sec_mw_averages()} creates a \emph{specification} of a recipe step that
calculates molecular weight averages from size exclusion chromatography data.
}
\details{
This step calculates standard molecular weight averages from SEC/GPC data:\tabular{lll}{
   Metric \tab Formula \tab Description \cr
   Mn \tab sum(w) / sum(w/M) \tab Number-average molecular weight \cr
   Mw \tab sum(wM) / sum(w) \tab Weight-average molecular weight \cr
   Mz \tab sum(wM^2) / sum(wM) \tab Z-average molecular weight \cr
   Mp \tab M at peak maximum \tab Peak molecular weight \cr
   D \tab Mw/Mn \tab Dispersity (polydispersity index) \cr
}


The detector signal is assumed to be proportional to weight concentration.
For RI detection, this is typically valid. For UV detection, response factors
may need to be applied first.

\strong{Uncertainty Propagation:}

When \code{include_uncertainty = TRUE}, the step calculates uncertainty estimates
based on calibration error propagation. The uncertainties account for:
\itemize{
\item Calibration curve fit error (RMSE in log10 MW units)
\item MW distribution width effects on different averages
}

The propagation follows:
\itemize{
\item Mn uncertainty is enhanced for wide distributions (most sensitive to low MW)
\item Mw uncertainty equals the relative calibration error
\item Mz uncertainty is enhanced for high MW sensitivity
\item Dispersity uncertainty from error propagation of Mw/Mn
}

\strong{Prerequisites:}
\itemize{
\item Data should be baseline corrected
\item X-axis should represent retention time/volume or log(MW)
\item Integration limits should exclude solvent peaks
}
}
\examples{
\dontrun{
library(recipes)
library(measure)

# Assuming x-axis is already calibrated to log10(MW)
rec <- recipe(~., data = sec_triple_detect) |>
  step_measure_input_wide(starts_with("signal_")) |>
  step_sec_baseline() |>
  step_sec_mw_averages() |>
  prep()

# With uncertainty propagation (calibration_error from tidy() of calibration step)
rec_with_unc <- recipe(~., data = sec_triple_detect) |>
  step_measure_input_wide(starts_with("signal_")) |>
  step_sec_baseline() |>
  step_sec_mw_averages(
    include_uncertainty = TRUE,
    calibration_error = 0.02  # RMSE in log10(MW)
  ) |>
  prep()
}
}
\seealso{
Other sec-chromatography: 
\code{\link{step_sec_band_broadening}()},
\code{\link{step_sec_baseline}()},
\code{\link{step_sec_detector_delay}()},
\code{\link{step_sec_exclude_regions}()},
\code{\link{step_sec_integration_window}()},
\code{\link{step_sec_mw_distribution}()},
\code{\link{step_sec_mw_fractions}()},
\code{\link{step_sec_peaks_deconvolve}()},
\code{\link{step_sec_peaks_detect}()},
\code{\link{step_sec_peaks_refine}()}
}
\concept{sec-chromatography}
