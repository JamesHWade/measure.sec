% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_sec_peaks_refine.R
\name{step_sec_peaks_refine}
\alias{step_sec_peaks_refine}
\title{Refine SEC/GPC Peak Boundaries}
\usage{
step_sec_peaks_refine(
  recipe,
  method = "height_fraction",
  cutoff = 0.005,
  peaks_col = ".peaks",
  measures_col = ".measures",
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("sec_peaks_refine")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{method}{Boundary refinement method. Currently only
\code{"height_fraction"} is supported:
\itemize{
\item \code{"height_fraction"} (default): Set boundaries where the corrected signal
drops below \code{cutoff * apex_height}.
}}

\item{cutoff}{Numeric threshold for the chosen method. For
\code{"height_fraction"}, this is the fraction of apex height below which
the signal is considered outside the peak. Default is \code{0.005} (0.5\%).
Common values:
\itemize{
\item \code{0.005}: 0.5\% of peak height (Empower default, most common)
\item \code{0.01}: 1\% (more aggressive trimming)
\item \code{0.001}: 0.1\% (looser, closer to baseline-return)
}}

\item{peaks_col}{Name of the peaks column to refine. Default is \code{".peaks"}.}

\item{measures_col}{Name of the measure column containing the
baseline-corrected signal. Default is \code{".measures"}. If not found,
the first available measure column is used automatically.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked?}

\item{id}{A character string that is unique to this step to identify it.}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of any existing operations. The \code{.peaks} column will be updated
with refined \code{left_base} and \code{right_base} values. Two new columns are
added to each \code{peaks_tbl}: \code{original_left_base} and \code{original_right_base}
preserving the boundaries from \code{\link[=step_sec_peaks_detect]{step_sec_peaks_detect()}}.
}
\description{
\code{step_sec_peaks_refine()} creates a \emph{specification} of a recipe step that
tightens peak boundaries set by \code{\link[=step_sec_peaks_detect]{step_sec_peaks_detect()}}. The default
\code{"height_fraction"} method sets boundaries where the corrected signal drops
below a fraction of each peak's apex height, matching the approach used by
industry GPC software (e.g., Waters Empower's 0.5\% default).
}
\details{
Wide peak boundaries from baseline-return detection cause systematic errors
in molecular weight calculations:
\itemize{
\item \strong{Mn bias}: Low-signal noise at high elution volumes contributes small
M_i values, pulling Mn downward.
\item \strong{PDI inflation}: With Mw stable but Mn depressed, dispersity (Mw/Mn)
increases artificially.
\item \strong{Noise integration}: Baseline noise fluctuating around zero gets included
when \code{corrected > 0}.
}

The \code{"height_fraction"} method addresses this by walking inward from each
boundary until the signal exceeds a fraction of the peak's apex height.

This step should run after \code{\link[=step_sec_baseline]{step_sec_baseline()}} and
\code{\link[=step_sec_peaks_detect]{step_sec_peaks_detect()}}. The signal in \code{measures_col} should be
baseline-corrected for best results.

\strong{Edge cases handled:}
\itemize{
\item Peak with apex height <= 0: boundaries unchanged
\item Fewer than 5 data points within boundaries: boundaries unchanged
\item No points above threshold: boundaries unchanged
\item Refined boundaries are guaranteed to never be wider than originals
}
}
\section{Tidying}{
When you \code{\link[recipes:tidy.recipe]{tidy()}} this step, a tibble with columns
\code{method}, \code{cutoff}, \code{peaks_col}, \code{measures_col}, and \code{id} is returned.
}

\examples{
\dontrun{
library(recipes)
library(measure)

# Refine peaks with default 0.5\% height fraction
rec <- recipe(~., data = sec_data) |>
  step_measure_input_long(ri_signal, location = vars(elution_volume)) |>
  step_sec_baseline() |>
  step_sec_peaks_detect() |>
  step_sec_peaks_refine() |>
  prep()

# More aggressive trimming at 1\%
rec <- recipe(~., data = sec_data) |>
  step_measure_input_long(ri_signal, location = vars(elution_volume)) |>
  step_sec_baseline() |>
  step_sec_peaks_detect() |>
  step_sec_peaks_refine(cutoff = 0.01) |>
  prep()

# Looser boundaries at 0.1\%
rec <- recipe(~., data = sec_data) |>
  step_measure_input_long(ri_signal, location = vars(elution_volume)) |>
  step_sec_baseline() |>
  step_sec_peaks_detect() |>
  step_sec_peaks_refine(cutoff = 0.001) |>
  prep()
}
}
\seealso{
\code{\link[=step_sec_peaks_detect]{step_sec_peaks_detect()}} for peak detection,
\code{\link[=step_sec_baseline]{step_sec_baseline()}} for baseline correction.

Other sec-chromatography: 
\code{\link{step_sec_band_broadening}()},
\code{\link{step_sec_baseline}()},
\code{\link{step_sec_detector_delay}()},
\code{\link{step_sec_exclude_regions}()},
\code{\link{step_sec_integration_window}()},
\code{\link{step_sec_mw_averages}()},
\code{\link{step_sec_mw_distribution}()},
\code{\link{step_sec_mw_fractions}()},
\code{\link{step_sec_peaks_deconvolve}()},
\code{\link{step_sec_peaks_detect}()}
}
\concept{sec-chromatography}
