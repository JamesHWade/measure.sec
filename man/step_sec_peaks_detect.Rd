% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_sec_peaks_detect.R
\name{step_sec_peaks_detect}
\alias{step_sec_peaks_detect}
\title{SEC/GPC Peak Detection}
\usage{
step_sec_peaks_detect(
  recipe,
  measures = NULL,
  algorithm = "finderskeepers",
  min_height = 1,
  min_distance = 0,
  loess_span = 0.01,
  ist_points = 50L,
  ist_nonlinearity = 5,
  snr_threshold = FALSE,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("sec_peaks_detect")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{measures}{An optional character vector of measure column names to
process. If \code{NULL} (the default), all measure columns (columns with class
\code{measure_list}) will be processed.}

\item{algorithm}{Peak detection algorithm. Currently only \code{"finderskeepers"}
(the default) is supported. This SEC-optimized algorithm uses LOESS
smoothing with Iterative Soft Thresholding and changepoint detection.
For other algorithms, use \code{\link[measure:step_measure_peaks_detect]{measure::step_measure_peaks_detect()}} directly.}

\item{min_height}{Minimum peak height. For \code{"finderskeepers"}, this is the
minimum height above baseline. For other algorithms with \code{snr_threshold = TRUE},
this is interpreted as a signal-to-noise ratio. Default is \code{1}.}

\item{min_distance}{Minimum distance between peaks in location units (e.g., mL).
Only used for non-finderskeepers algorithms. Default is \code{0}.}

\item{loess_span}{LOESS smoothing span for \code{finderskeepers}. A value between 0
and 1 controlling the smoothness of the fit. Default is \code{0.01} (minimal
smoothing to preserve peak shapes).}

\item{ist_points}{Number of threshold levels for Iterative Soft Thresholding.
Default is \code{50}. Higher values give finer threshold resolution.}

\item{ist_nonlinearity}{Nonlinearity parameter for IST threshold spacing.
Default is \code{5}. Higher values concentrate thresholds near the baseline.}

\item{snr_threshold}{Logical. For non-finderskeepers algorithms, if \code{TRUE},
\code{min_height} is interpreted as a signal-to-noise ratio. Default is \code{FALSE}.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked?}

\item{id}{A character string that is unique to this step to identify it.}
}
\value{
An updated version of \code{recipe} with the new step added to the

sequence of any existing operations. A new \code{.peaks} column will be added
containing detected peaks for each sample.
}
\description{
\code{step_sec_peaks_detect()} creates a \emph{specification} of a recipe step that
detects peaks in SEC/GPC chromatography data. The default algorithm is
\code{finderskeepers}, which uses LOESS smoothing with Iterative Soft Thresholding
(IST) and changepoint analysis for automatic threshold detection.
}
\details{
The \code{finderskeepers} algorithm is specifically designed for SEC/GPC data:

1
. \strong{LOESS smoothing}: Applies local polynomial regression to reduce noise
while preserving peak shapes (controlled by \code{loess_span})
2. \strong{Iterative Soft Thresholding (IST)}: Creates a series of thresholds with
nonlinear spacing to detect changes in peak structure
3. \strong{Changepoint detection}: Uses \code{changepoint::cpt.mean()} to automatically
determine the optimal threshold for peak/baseline separation
4. \strong{Peak boundary detection}: Identifies peak start, apex, and end points

This approach is robust to baseline drift and varying peak heights, making it
well-suited for polymer SEC chromatograms.

\strong{Peak properties stored:}
\itemize{
\item \code{peak_id}: Integer identifier
\item \code{location}: X-axis position of peak apex (elution volume)
\item \code{height}: Peak height above baseline
\item \code{left_base}, \code{right_base}: X-axis positions of peak boundaries
\item \code{area}: Initially NA; use \code{\link[measure:step_measure_peaks_integrate]{measure::step_measure_peaks_integrate()}} to calculate
}
}
\section{Tidying}{
When you \code{\link[recipes:tidy.recipe]{tidy()}} this step, a tibble with columns
\code{terms}, \code{algorithm}, \code{min_height}, and \code{id} is returned.
}

\examples{
\dontrun{
library(recipes)
library(measure)

# SEC peak detection with finderskeepers (default)
rec <- recipe(~., data = sec_triple_detect) |>
  step_measure_input_long(ri_signal, location = vars(elution_time)) |>
  step_sec_peaks_detect() |>
  prep()

# Adjust sensitivity with min_height
rec <- recipe(~., data = sec_triple_detect) |>
  step_measure_input_long(ri_signal, location = vars(elution_time)) |>
  step_sec_peaks_detect(min_height = 5) |>
  prep()

# Adjust LOESS smoothing for noisy data
rec <- recipe(~., data = sec_triple_detect) |>
  step_measure_input_long(ri_signal, location = vars(elution_time)) |>
  step_sec_peaks_detect(loess_span = 0.05) |>
  prep()
}
}
\seealso{
\code{\link[measure:step_measure_peaks_detect]{measure::step_measure_peaks_detect()}} for general peak detection,
\code{\link[measure:step_measure_peaks_integrate]{measure::step_measure_peaks_integrate()}} to calculate peak areas.

Other sec-chromatography: 
\code{\link{step_sec_band_broadening}()},
\code{\link{step_sec_baseline}()},
\code{\link{step_sec_detector_delay}()},
\code{\link{step_sec_mw_averages}()},
\code{\link{step_sec_mw_distribution}()},
\code{\link{step_sec_mw_fractions}()}
}
\concept{sec-chromatography}
