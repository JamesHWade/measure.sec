[{"path":"/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"/CLAUDE.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"CLAUDE.md","text":"measure.sec R package extends measure package preprocessing steps specific Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC). provides recipes-style interface SEC/GPC data processing, calibration, molecular weight calculations. “technique pack” registers measure package registry system.","code":""},{"path":"/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md","text":"","code":"# Generate documentation from roxygen2 comments devtools::document()  # Run all tests devtools::test()  # Run a single test file (filter matches test-*.R files) devtools::test(filter = \"conventional\")  # runs test-step-conventional-cal.R  # Full CRAN-like package check devtools::check()  # Test coverage covr::package_coverage()  # Rebuild README.md from README.Rmd devtools::build_readme()  # Build pkgdown site pkgdown::build_site()"},{"path":[]},{"path":"/CLAUDE.html","id":"recipe-step-pattern","dir":"","previous_headings":"Architecture","what":"Recipe Step Pattern","title":"CLAUDE.md","text":"Every preprocessing step follows recipes framework three required methods: Step implementations R/ naming convention: step_sec_{operation}.R","code":"# Constructor function step_sec_*() → calls recipes::add_step()  # Three S3 methods required: prep.step_sec_*()   # Learn parameters from training data bake.step_sec_*()   # Apply transformation to new data tidy.step_sec_*()   # Return step parameters as tibble"},{"path":"/CLAUDE.html","id":"internal-data-format","dir":"","previous_headings":"Architecture","what":"Internal Data Format","title":"CLAUDE.md","text":"package uses measure package’s S3 class hierarchy: measure_tbl: Single measurement (tibble location value columns) measure_list: Collection measurements stored list column Key helper functions measure: - find_measure_cols(): Detect measure columns class - check_for_measure(): Validation utilities - new_measure_tbl() / new_measure_list(): Constructors","code":""},{"path":"/CLAUDE.html","id":"file-organization","dir":"","previous_headings":"Architecture","what":"File Organization","title":"CLAUDE.md","text":"Detector Processing: - step_sec_ri.R: RI detector dn/dc conversion - step_sec_uv.R: UV detector extinction coefficient - step_sec_mals.R: Multi-angle light scattering - step_sec_viscometer.R: Viscometer detector - step_sec_detector_delay.R: Inter-detector delay correction Calibration: - step_sec_conventional_cal.R: Narrow standard calibration (polynomial fits) - step_sec_universal_cal.R: Universal calibration Mark-Houwink parameters Molecular Weight Calculations: - step_sec_mw_averages.R: Mn, Mw, Mz, dispersity - step_sec_mw_fractions.R: MW fraction analysis - step_sec_mw_distribution.R: MW distribution curves Signal Processing: - step_sec_baseline.R: SEC-optimized baseline correction - step_sec_concentration.R: Signal concentration conversion Analysis: - step_sec_aggregates.R: Aggregate/fragment analysis - step_sec_composition.R: Copolymer composition - step_sec_uv_ri_ratio.R: UV/RI ratio composition - step_sec_intrinsic_visc.R: Intrinsic viscosity calculation Supporting Files: - qc-functions.R: QC metrics (plate count, asymmetry, resolution) - polymer-analysis.R: Polymer characterization (branching, M-H parameters) - export-functions.R: Summary table slice table exports - data.R: Dataset documentation","code":""},{"path":"/CLAUDE.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"CLAUDE.md","text":"Tests use testthat edition 3. Test files mirror source files: - tests/testthat/test-step-*.R: Step-specific tests - tests/testthat/test-edge-cases.R: Edge case coverage - tests/testthat/test-qc-functions.R: QC function tests","code":""},{"path":"/CLAUDE.html","id":"code-style","dir":"","previous_headings":"","what":"Code Style","title":"CLAUDE.md","text":"Tidyverse style guide Roxygen2 Markdown syntax documentation exported functions need @export tag S3 methods include print() tidy() methods","code":""},{"path":"/CLAUDE.html","id":"linting--formatting","dir":"","previous_headings":"","what":"Linting & Formatting","title":"CLAUDE.md","text":"project uses two complementary code quality tools: jarl catches: - vector_logic: Using | instead || () statements - potential bugs inefficiencies air enforces: - 2-space indentation function signatures - One argument per line long function calls - Closing parenthesis line multi-line constructs - Consistent line length limits Run committing pass CI checks.","code":"# Linter - catches logic/efficiency issues jarl check .        # Check for issues jarl check . --fix  # Auto-fix issues  # Formatter - enforces consistent code style air format .        # Format all R files"},{"path":"/CLAUDE.html","id":"pr-workflow","dir":"","previous_headings":"","what":"PR Workflow","title":"CLAUDE.md","text":"creating pull request, run following checks: adding new exported functions, ensure included _pkgdown.yml appropriate reference section.","code":"# 1. Format all R files (including tests) air format .  # 2. Check for linting issues and auto-fix jarl check . --fix  # 3. Generate/update documentation R -e 'devtools::document()'  # 4. Run full package check (should pass with 0 errors, 0 warnings) R -e 'devtools::check()'  # 5. Build pkgdown site to verify documentation renders correctly R -e 'pkgdown::build_site()'"},{"path":"/CLAUDE.html","id":"technique-pack-registration","dir":"","previous_headings":"","what":"Technique Pack Registration","title":"CLAUDE.md","text":"package registers measure R/zzz.R: Users can discover available steps :","code":".onLoad <- function(libname, pkgname) {  measure::register_measure_pack(     pack_name = pkgname,     technique = \"SEC/GPC\",     description = \"Size Exclusion / Gel Permeation Chromatography\"   )   # ... register individual steps } measure::measure_steps(techniques = \"SEC/GPC\")"},{"path":"/CLAUDE.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"CLAUDE.md","text":"measure: Core package providing measure_tbl/measure_list classes registry recipes: tidymodels preprocessing framework tibble, dplyr, purrr, rlang: tidyverse infrastructure cli: User-friendly messages warnings","code":""},{"path":"/CLAUDE.html","id":"calibration-quality-metrics","dir":"","previous_headings":"","what":"Calibration Quality Metrics","title":"CLAUDE.md","text":"step_sec_conventional_cal() provides comprehensive diagnostics: Per-standard: residuals, % deviation, prediction intervals Overall: R², adjusted R², RMSE, residual standard error Access via tidy(prepped_recipe, number = step_number) Nested standard_results tibble contains per-standard diagnostics","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 measure.sec authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/sec-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Size Exclusion Chromatography (SEC), also known Gel Permeation Chromatography (GPC), fundamental technique characterizing molecular weight distribution polymers, proteins, macromolecules. measure.sec package extends measure package specialized preprocessing steps SEC/GPC data analysis. vignette demonstrates : Process multi-detector SEC data (RI, UV/DAD, MALS, LALS, RALS, DLS) Calculate molecular weight averages distributions Analyze copolymer composition Quantify protein aggregates Perform quality control checks","code":""},{"path":"/articles/sec-analysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(tidyr) library(purrr) library(ggplot2)"},{"path":"/articles/sec-analysis.html","id":"the-measure-sec-data-model","dir":"Articles","previous_headings":"","what":"The measure.sec Data Model","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package uses measure framework, chromatographic signals stored nested tibbles. sample measure_tbl containing: location: Elution time volume value: Detector response Multiple samples combined measure_list column.","code":""},{"path":"/articles/sec-analysis.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package includes sec_triple_detect, synthetic dataset representing multi-detector SEC analysis:","code":"data(sec_triple_detect, package = \"measure.sec\")  # Overview of the dataset glimpse(sec_triple_detect) #> Rows: 24,012 #> Columns: 11 #> $ sample_id        <chr> \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\",… #> $ sample_type      <chr> \"standard\", \"standard\", \"standard\", \"standard\", \"stan… #> $ polymer_type     <chr> \"polystyrene\", \"polystyrene\", \"polystyrene\", \"polysty… #> $ elution_time     <dbl> 5.00, 5.01, 5.02, 5.03, 5.04, 5.05, 5.06, 5.07, 5.08,… #> $ ri_signal        <dbl> 6.926392e-04, 0.000000e+00, 3.199253e-04, 4.197175e-0… #> $ uv_signal        <dbl> 0.0002034583, 0.0000000000, 0.0000000000, 0.000000000… #> $ mals_signal      <dbl> 3.370385e-05, 3.483481e-05, 3.102092e-05, 3.261962e-0… #> $ known_mw         <dbl> 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,… #> $ known_dispersity <dbl> 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05,… #> $ dn_dc            <dbl> 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.18… #> $ extinction_coef  <dbl> 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2…  # Sample types included sec_triple_detect |>   distinct(sample_id, sample_type, polymer_type) |>   print(n = 12) #> # A tibble: 12 × 3 #>    sample_id sample_type polymer_type #>    <chr>     <chr>       <chr>        #>  1 PS-1K     standard    polystyrene  #>  2 PS-10K    standard    polystyrene  #>  3 PS-50K    standard    polystyrene  #>  4 PS-100K   standard    polystyrene  #>  5 PS-500K   standard    polystyrene  #>  6 PMMA-Low  sample      pmma         #>  7 PMMA-Med  sample      pmma         #>  8 PMMA-High sample      pmma         #>  9 PEG-5K    sample      peg          #> 10 PEG-20K   sample      peg          #> 11 Copoly-A  sample      copolymer    #> 12 Copoly-B  sample      copolymer"},{"path":"/articles/sec-analysis.html","id":"basic-workflow-single-detector-analysis","dir":"Articles","previous_headings":"","what":"Basic Workflow: Single Detector Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Let’s start simple RI detector workflow polystyrene standards:","code":"# Filter to PS standards ps_standards <- sec_triple_detect |>   filter(polymer_type == \"polystyrene\")  # Create the preprocessing recipe rec <- recipe(~., data = ps_standards) |>   # Convert to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   # Apply baseline correction   step_sec_baseline(measures = \"ri\") |>   # Process RI detector with dn/dc   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   # Calculate molecular weight averages   step_sec_mw_averages(mw_column = \"known_mw\")  # Prep and bake prepped <- prep(rec) result <- bake(prepped, new_data = NULL)  # View results result |>   select(sample_id, Mn, Mw, Mz, dispersity)"},{"path":"/articles/sec-analysis.html","id":"conventional-calibration","dir":"Articles","previous_headings":"","what":"Conventional Calibration","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Conventional (relative) calibration uses narrow molecular weight standards establish relationship elution time molecular weight. common approach routine polymer analysis.","code":""},{"path":"/articles/sec-analysis.html","id":"calibration-standards","dir":"Articles","previous_headings":"Conventional Calibration","what":"Calibration Standards","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package includes comprehensive polystyrene PMMA calibration standards:","code":"# Load polystyrene calibration standards data(sec_ps_standards, package = \"measure.sec\")  # View the standards (16 standards from 162 Da to 3.15 MDa) sec_ps_standards |>   select(standard_name, mp, log_mp, retention_time, dispersity) |>   print(n = 8) #> # A tibble: 16 × 5 #>   standard_name      mp log_mp retention_time dispersity #>   <chr>           <dbl>  <dbl>          <dbl>      <dbl> #> 1 PS-3150000    3150000   6.50           11.2       1.04 #> 2 PS-1870000    1870000   6.27           11.6       1.04 #> 3 PS-1090000    1090000   6.04           12.1       1.03 #> 4 PS-630000      630000   5.80           12.6       1.04 #> 5 PS-430000      430000   5.63           13.2       1.04 #> 6 PS-216000      216000   5.33           13.8       1.03 #> 7 PS-120000      120000   5.08           14.3       1.03 #> 8 PS-67500        67500   4.83           15.0       1.03 #> # ℹ 8 more rows"},{"path":"/articles/sec-analysis.html","id":"visualizing-the-calibration-curve","dir":"Articles","previous_headings":"Conventional Calibration","what":"Visualizing the Calibration Curve","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"fitting, ’s good practice visualize standards:","code":"ggplot(sec_ps_standards, aes(retention_time, log_mp)) +   geom_point(size = 3, color = \"#2E86AB\") +   geom_smooth(     method = \"lm\",     formula = y ~ poly(x, 3),     se = TRUE,     color = \"#A23B72\",     fill = \"#A23B72\",     alpha = 0.2   ) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     title = \"Polystyrene Calibration Curve\",     subtitle = \"Cubic polynomial fit with 95% confidence band\"   ) +   theme_minimal() +   theme(     plot.title = element_text(face = \"bold\"),     axis.title = element_text(size = 11)   )"},{"path":"/articles/sec-analysis.html","id":"building-a-calibration-curve","dir":"Articles","previous_headings":"Conventional Calibration","what":"Building a Calibration Curve","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Use step_sec_conventional_cal() fit calibration apply samples:","code":"# Prepare standards for the step (needs 'retention' and 'log_mw' columns) ps_cal <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  # Filter to a polystyrene sample for demonstration ps_sample <- sec_triple_detect |>   filter(sample_id == \"PS-50K\")  # Build the calibration recipe rec_cal <- recipe(~., data = ps_sample) |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   step_sec_conventional_cal(     standards = ps_cal,     fit_type = \"cubic\",     output_col = \"log_mw\",     extrapolation = \"none\"   ) |>   step_sec_mw_averages(measures = \"log_mw\")  # Prep and bake prepped <- prep(rec_cal) result <- bake(prepped, new_data = NULL)  # View molecular weight results result |>   select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity)"},{"path":"/articles/sec-analysis.html","id":"assessing-calibration-quality","dir":"Articles","previous_headings":"Conventional Calibration","what":"Assessing Calibration Quality","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"tidy() method provides comprehensive diagnostics evaluating calibration quality: Key quality metrics:","code":"# Get calibration diagnostics diagnostics <- tidy(prepped, number = 3)  # step_sec_conventional_cal is step 3  # Overview metrics diagnostics |>   select(fit_type, n_standards, r_squared, rmse_log_mw, max_abs_pct_deviation)  # Access per-standard residuals std_results <- diagnostics$standard_results[[1]] std_results |>   select(     location,     actual_log_mw,     predicted_log_mw,     residual_log_mw,     pct_deviation   )"},{"path":"/articles/sec-analysis.html","id":"comparing-fit-types","dir":"Articles","previous_headings":"Conventional Calibration","what":"Comparing Fit Types","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Different polynomial orders may appropriate depending column behavior:","code":"# Compare linear, quadratic, and cubic fits library(tidyr)  fits <- tibble(   fit_type = c(\"Linear\", \"Quadratic\", \"Cubic\"),   degree = c(1, 2, 3) ) |>   mutate(     predictions = map(degree, function(d) {       model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)       tibble(         retention_time = seq(11, 21, by = 0.1),         log_mp = predict(model, newdata = tibble(retention_time = seq(11, 21, by = 0.1)))       )     }),     r_squared = map_dbl(degree, function(d) {       model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)       summary(model)$r.squared     })   )  fit_curves <- fits |>   unnest(predictions)  ggplot() +   geom_point(     data = sec_ps_standards,     aes(retention_time, log_mp),     size = 3,     alpha = 0.7   ) +   geom_line(     data = fit_curves,     aes(retention_time, log_mp, color = fit_type),     linewidth = 1   ) +   scale_color_manual(     values = c(\"Linear\" = \"#E8751A\", \"Quadratic\" = \"#2E86AB\", \"Cubic\" = \"#A23B72\")   ) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     color = \"Fit Type\",     title = \"Calibration Curve Fit Comparison\",     subtitle = sprintf(       \"R²: Linear=%.5f, Quadratic=%.5f, Cubic=%.5f\",       fits$r_squared[1], fits$r_squared[2], fits$r_squared[3]     )   ) +   theme_minimal() +   theme(     legend.position = \"bottom\",     plot.title = element_text(face = \"bold\")   )"},{"path":"/articles/sec-analysis.html","id":"polymer-specific-calibration","dir":"Articles","previous_headings":"Conventional Calibration","what":"Polymer-Specific Calibration","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Conventional calibration polymer-specific different polymers different hydrodynamic volumes molecular weight:  Key insight: Using PS calibration PMMA samples underestimate molecular weight. cross-polymer analysis, use universal calibration Mark-Houwink parameters.","code":"data(sec_pmma_standards, package = \"measure.sec\")  # Combine PS and PMMA for comparison combined <- bind_rows(   sec_ps_standards |> mutate(polymer = \"Polystyrene\"),   sec_pmma_standards |> mutate(polymer = \"PMMA\") )  ggplot(combined, aes(retention_time, log_mp, color = polymer, shape = polymer)) +   geom_point(size = 3) +   geom_smooth(     method = \"lm\",     formula = y ~ poly(x, 3),     se = FALSE,     linewidth = 1   ) +   scale_color_manual(values = c(\"Polystyrene\" = \"#2E86AB\", \"PMMA\" = \"#A23B72\")) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     color = \"Polymer\",     shape = \"Polymer\",     title = \"PS vs PMMA Calibration Curves\",     subtitle = \"At same MW, PMMA elutes later (smaller hydrodynamic volume in THF)\"   ) +   theme_minimal() +   theme(     legend.position = \"bottom\",     plot.title = element_text(face = \"bold\")   )"},{"path":"/articles/sec-analysis.html","id":"multi-detector-sec-workflow","dir":"Articles","previous_headings":"","what":"Multi-Detector SEC Workflow","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"accurate molecular weight determination, multi-detector SEC uses RI concentration MALS absolute molecular weight:","code":"rec_multi <- recipe(~., data = sec_triple_detect) |>   # Convert each detector to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_measure_input_long(     uv_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   step_measure_input_long(     mals_signal,     location = vars(elution_time),     col_name = \"mals\"   ) |>   # Correct inter-detector delays   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.10)   ) |>   # Apply baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Process detectors   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>   step_sec_mals(measures = \"mals\", dn_dc_column = \"dn_dc\") |>   # Convert to concentration   step_sec_concentration(measures = \"ri\", detector = \"ri\") |>   # Calculate MW averages from MALS-derived MW   step_sec_mw_averages(mw_column = \"mw_mals\")  prepped <- prep(rec_multi) result <- bake(prepped, new_data = NULL)"},{"path":"/articles/sec-analysis.html","id":"copolymer-composition-analysis","dir":"Articles","previous_headings":"","what":"Copolymer Composition Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"UV/RI ratio can reveal compositional heterogeneity across molecular weight distribution:","code":"# Filter to copolymer samples copolymers <- sec_triple_detect |>   filter(polymer_type == \"copolymer\")  rec_comp <- recipe(~., data = copolymers) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = c(\"ri\", \"uv\")) |>   # Calculate UV/RI ratio   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\", smooth = TRUE) |>   # Calculate composition (requires known response factors)   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     component_a_uv = 1.0,   # UV response factor for component A     component_a_ri = 0.185, # RI response factor for component A     component_b_uv = 0.1,   # UV response factor for component B     component_b_ri = 0.084  # RI response factor for component B   )  prepped <- prep(rec_comp) result <- bake(prepped, new_data = NULL)  # The result contains: # - uv_ri_ratio: Point-by-point UV/RI ratio # - composition_a: Weight fraction of component A at each point"},{"path":"/articles/sec-analysis.html","id":"protein-sec-aggregate-quantitation","dir":"Articles","previous_headings":"","what":"Protein SEC: Aggregate Quantitation","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"protein therapeutics, SEC used quantify high molecular weight species (HMWS/aggregates) low molecular weight species (LMWS/fragments):","code":"# Create protein-like data (using UV at 280 nm) protein_data <- sec_triple_detect |>   filter(sample_type == \"sample\") |>   head(1)  rec_protein <- recipe(~., data = protein_data) |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = \"uv\") |>   # Quantify aggregates with manual peak boundaries   step_sec_aggregates(     measures = \"uv\",     monomer_start = 10,  # Monomer peak start time     monomer_end = 14,    # Monomer peak end time     method = \"manual\"   )  prepped <- prep(rec_protein) result <- bake(prepped, new_data = NULL)  # Results include: # - purity_hmws: % high MW species (before monomer) # - purity_monomer: % main peak # - purity_lmws: % low MW species (after monomer) result |>   select(sample_id, purity_hmws, purity_monomer, purity_lmws)"},{"path":"/articles/sec-analysis.html","id":"molecular-weight-distribution","dir":"Articles","previous_headings":"","what":"Molecular Weight Distribution","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Generate differential cumulative molecular weight distributions:","code":"rec_mwd <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline(measures = \"ri\") |>   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   # Add MW distribution curves   step_sec_mw_distribution(     signal_col = \"ri\",     mw_column = \"known_mw\",     output_type = \"both\"  # \"differential\", \"cumulative\", or \"both\"   )  prepped <- prep(rec_mwd) result <- bake(prepped, new_data = NULL)  # The result contains: # - mwd_differential: dw/d(logM) vs logM # - mwd_cumulative: cumulative weight fraction vs logM"},{"path":"/articles/sec-analysis.html","id":"quality-control-functions","dir":"Articles","previous_headings":"","what":"Quality Control Functions","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package provides functions chromatographic system suitability testing:","code":""},{"path":"/articles/sec-analysis.html","id":"peak-resolution","dir":"Articles","previous_headings":"Quality Control Functions","what":"Peak Resolution","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Calculate USP resolution between two peaks Rs <- measure_sec_resolution(   retention_1 = 8.5,   retention_2 = 10.0,   width_1 = 0.3,   width_2 = 0.35,   method = \"usp\" )  cat(\"Resolution (Rs):\", round(Rs, 2), \"\\n\") #> Resolution (Rs): 4.62"},{"path":"/articles/sec-analysis.html","id":"plate-count","dir":"Articles","previous_headings":"Quality Control Functions","what":"Plate Count","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Calculate theoretical plates N <- measure_sec_plate_count(   retention = 10.0,   width = 0.25,   width_type = \"half_height\" )  cat(\"Theoretical plates:\", round(N), \"\\n\") #> Theoretical plates: 8864"},{"path":"/articles/sec-analysis.html","id":"system-suitability","dir":"Articles","previous_headings":"Quality Control Functions","what":"System Suitability","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Comprehensive system suitability testing peaks <- data.frame(   name = c(\"dimer\", \"monomer\"),   retention = c(8.5, 10.0),   width = c(0.3, 0.35),   area = c(5, 95) )  sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\") )  print(sst) #> SEC System Suitability Test #> ==================================================  #>  #> Overall Status: FAILED #>  #> Results: #> --------------------------------------------------  #> resolution          : 4.615385 (>= 1.5) [PASS] #> plate count         : 4522.0 (>= 5000) [FAIL]  #> --------------------------------------------------"},{"path":"/articles/sec-analysis.html","id":"polymer-analysis-mark-houwink-parameters","dir":"Articles","previous_headings":"","what":"Polymer Analysis: Mark-Houwink Parameters","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Estimate Mark-Houwink parameters intrinsic viscosity data:","code":"# Molecular weight and intrinsic viscosity data mw <- c(10000, 25000, 50000, 100000, 250000) iv <- 0.0001 * mw^0.7  # Simulated data  mh <- measure_mh_parameters(mw, iv) #> Warning in summary.lm(fit): essentially perfect fit: summary may be unreliable print(mh) #> Mark-Houwink Parameters #> ========================================  #>  #> K = 1.0000e-04 #> a = 0.700 #>  #> R-squared: 1.0000 #> Data points: 5 #> MW range: 10000 - 250000 #>  #> Equation: [eta] = K * M^a"},{"path":"/articles/sec-analysis.html","id":"branching-analysis","dir":"Articles","previous_headings":"","what":"Branching Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Calculate branching indices branched polymers:","code":"# Compare branched polymer to linear reference mw <- c(100000, 200000, 500000) rg_branched <- c(10, 15, 25) rg_linear <- c(12, 18, 32)  g <- measure_branching_index(   mw = mw,   rg = rg_branched,   reference = data.frame(mw = mw, rg = rg_linear),   method = \"g\" )  print(g) # g < 1 indicates branching (smaller Rg than linear)"},{"path":[]},{"path":"/articles/sec-analysis.html","id":"slice-by-slice-data","dir":"Articles","previous_headings":"Exporting Results","what":"Slice-by-Slice Data","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Extract point--point chromatographic data:","code":"slices <- measure_sec_slice_table(   result,   measures = c(\"ri\", \"mw\"),   sample_id = \"sample_id\",   pivot = TRUE  # Wide format with one column per measure )  head(slices)"},{"path":"/articles/sec-analysis.html","id":"summary-table","dir":"Articles","previous_headings":"Exporting Results","what":"Summary Table","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Generate summary table reporting:","code":"summary <- measure_sec_summary_table(   result,   sample_id = \"sample_id\",   digits = 0 )  print(summary)"},{"path":"/articles/sec-analysis.html","id":"complete-workflow-example","dir":"Articles","previous_headings":"","what":"Complete Workflow Example","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"’s complete workflow analyzing polymer standards:","code":"library(measure) library(measure.sec) library(recipes)  # Load data data(sec_triple_detect, package = \"measure.sec\")  # Create comprehensive recipe rec <- recipe(~., data = sec_triple_detect) |>   # Input conversion   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   # Preprocessing   step_sec_detector_delay(reference = \"ri\", delay_volumes = c(uv = -0.05, mals = 0.10)) |>   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Detector processing   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>   step_sec_mals(measures = \"mals\", dn_dc_column = \"dn_dc\") |>   step_sec_concentration(measures = \"ri\", detector = \"ri\") |>   # Molecular weight calculations   step_sec_mw_averages(mw_column = \"known_mw\") |>   step_sec_mw_fractions(mw_column = \"known_mw\", cutoffs = c(10000, 100000)) |>   # Composition analysis   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\")  # Process prepped <- prep(rec) result <- bake(prepped, new_data = NULL)  # View molecular weight results result |>   select(sample_id, polymer_type, Mn, Mw, Mz, dispersity) |>   print(n = 12)  # Generate summary summary <- measure_sec_summary_table(result, sample_id = \"sample_id\") print(summary)"},{"path":[]},{"path":"/articles/sec-analysis.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          purrr_1.2.0            tidyr_1.3.2            #> [4] measure.sec_0.0.0.9000 measure_0.0.1.9001     recipes_1.3.1          #> [7] dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.4     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  pillar_1.11.1       pkgdown_2.2.0       #> [28] jquerylib_0.1.4     MASS_7.3-65         cachem_1.1.0        #> [31] gower_1.0.2         rpart_4.1.24        nlme_3.1-168        #> [34] parallelly_1.46.0   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       listenv_0.10.0      #> [40] labeling_0.4.3      splines_4.5.2       fastmap_1.2.0       #> [43] grid_4.5.2          cli_3.6.5           magrittr_2.0.4      #> [46] utf8_1.2.6          survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] mgcv_1.9-3          rlang_1.1.6         Rcpp_1.1.0          #> [64] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [67] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James Wade. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wade J (2026). measure.sec: SEC/GPC Analysis Extensions Measure Package. R package version 0.0.0.9000, https://github.com/JamesHWade/measure-sec.","code":"@Manual{,   title = {measure.sec: SEC/GPC Analysis Extensions for the Measure Package},   author = {James Wade},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://github.com/JamesHWade/measure-sec}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"measure.sec R package extends measure package preprocessing analysis steps Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC) data.","code":""},{"path":"/index.html","id":"features","dir":"","previous_headings":"Overview","what":"Features","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"Multi-detector support: RI, UV/DAD, MALS, LALS, RALS, DLS, viscometer processing Inter-detector delay correction: Align signals detectors series Molecular weight calculations: Mn, Mw, Mz, dispersity (PDI) Copolymer composition: UV/RI ratio composition analysis Protein SEC: Aggregate fragment quantitation (HMWS/LMWS) Universal calibration: Mark-Houwink parameter-based MW conversion Quality control: System suitability testing (resolution, plate count, asymmetry) Polymer analysis: Branching indices Mark-Houwink parameter estimation","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"can install development version measure.sec GitHub : Note: measure.sec requires measure package:","code":"# install.packages(\"pak\") pak::pak(\"JamesHWade/measure-sec\") pak::pak(\"JamesHWade/measure\")"},{"path":"/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"","code":"library(measure) library(measure.sec) library(recipes)  # Load example triple-detection SEC data data(sec_triple_detect, package = \"measure.sec\")  # Create a processing recipe rec <- recipe(~ ., data = sec_triple_detect) |>   # Convert to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>    # Correct inter-detector delays   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05)   ) |>    # Apply baseline correction   step_sec_baseline() |>    # Process RI detector with dn/dc   step_sec_ri(dn_dc_column = \"dn_dc\")  # Prep and bake prepped <- prep(rec) result <- bake(prepped, new_data = NULL)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/index.html","id":"quality-control-functions","dir":"","previous_headings":"","what":"Quality Control Functions","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"","code":"# Peak resolution Rs <- measure_sec_resolution(   retention_1 = 8.5,   retention_2 = 10.0,   width_1 = 0.3,   width_2 = 0.35 )  # Plate count N <- measure_sec_plate_count(retention = 10.0, width = 0.25)  # System suitability testing peaks <- data.frame(   name = c(\"dimer\", \"monomer\"),   retention = c(8.5, 10.0),   width = c(0.3, 0.35),   area = c(5, 95) )  sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\") ) print(sst)"},{"path":"/index.html","id":"polymer-analysis-functions","dir":"","previous_headings":"","what":"Polymer Analysis Functions","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"","code":"# Estimate Mark-Houwink parameters mw <- c(10000, 25000, 50000, 100000, 250000) iv <- c(0.15, 0.28, 0.45, 0.72, 1.2)  mh <- measure_mh_parameters(mw, iv) print(mh) # K = 1.14e-04, a = 0.716  # Calculate branching index g <- measure_branching_index(   mw = mw,   rg = c(8, 12, 18, 28, 45),   reference = data.frame(mw = mw, rg = c(10, 15, 22, 35, 55)),   method = \"g\" )"},{"path":"/index.html","id":"data-export","dir":"","previous_headings":"","what":"Data Export","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"","code":"# Extract slice-by-slice data slices <- measure_sec_slice_table(result, measures = c(\"ri\", \"mw\"))  # Generate summary table summary <- measure_sec_summary_table(result, sample_id = \"sample_id\")"},{"path":"/index.html","id":"example-dataset","dir":"","previous_headings":"","what":"Example Dataset","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"package includes sec_triple_detect, synthetic multi-detector SEC dataset : 12 polymer samples (PS standards, PMMA, PEG, copolymers) RI, UV, MALS detector signals Known molecular weights dispersities Sample-specific dn/dc extinction coefficients","code":"data(sec_triple_detect) head(sec_triple_detect)"},{"path":"/index.html","id":"integration-with-measure","dir":"","previous_headings":"","what":"Integration with measure","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"measure.sec automatically registers measure package load:","code":"library(measure) library(measure.sec)  # View registered SEC steps measure_steps(techniques = \"SEC/GPC\")"},{"path":"/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"Package documentation GitHub Issues","code":""},{"path":"/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"SEC/GPC Analysis Extensions for the Measure Package","text":"Please note measure.sec project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"/reference/estimate_sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"Estimates instrumental spreading parameter (sigma) narrow molecular weight standard peak. sigma value can used step_sec_band_broadening() correct band broadening.","code":""},{"path":"/reference/estimate_sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"","code":"estimate_sigma(peak, method = c(\"gaussian\", \"fwhm\", \"moments\"))"},{"path":"/reference/estimate_sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"peak measure_tbl data frame location value columns representing chromatographic peak narrow MW standard. method Method sigma estimation: \"gaussian\" (default): Fit Gaussian extract sigma \"fwhm\": Calculate full width half maximum (sigma = FWHM / 2.355) \"moments\": Calculate second moment peak","code":""},{"path":"/reference/estimate_sigma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"list components: sigma estimated spreading parameter (Gaussian std dev) tau Exponential tail parameter (EMG model), NA applicable fwhm Full width half maximum asymmetry Peak asymmetry factor (> 1 indicates tailing) method method used estimation","code":""},{"path":"/reference/estimate_sigma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"spreading parameter sigma represents standard deviation instrumental broadening function, assumed approximately Gaussian. best results, use narrow polydispersity standard (PDI < 1.05) run conditions samples. Method Details: gaussian: Fits Gaussian function peak using nonlinear least squares. accurate symmetric peaks. fwhm: Uses relationship sigma = FWHM / 2.355 Gaussian. Fast robust assumes symmetric peak. moments: Calculates sigma second central moment. Accounts asymmetry sensitive baseline.","code":""},{"path":"/reference/estimate_sigma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"","code":"if (FALSE) { # \\dontrun{ # From a measure_tbl sigma_result <- estimate_sigma(narrow_standard_peak) sigma_result$sigma  # Use in band broadening correction rec <- recipe(~., data = sec_data) |>   step_sec_band_broadening(sigma = sigma_result$sigma) } # }"},{"path":"/reference/measure.sec-package.html","id":null,"dir":"Reference","previous_headings":"","what":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","title":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","text":"Provides preprocessing analysis recipe steps Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC) data. Includes multi-detector support (RI, UV, MALS), inter-detector delay correction, molecular weight calculations (Mn, Mw, Mz, dispersity), calibration curve fitting. package technique pack 'measure' package.","code":""},{"path":[]},{"path":"/reference/measure.sec-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","text":"Maintainer: James Wade github@jameshwade.com (ORCID)","code":""},{"path":"/reference/measure_branching_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Branching Index — measure_branching_index","title":"Calculate Branching Index — measure_branching_index","text":"Calculates branching index (g g') branched polymers comparing properties linear reference polymers molecular weight.","code":""},{"path":"/reference/measure_branching_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Branching Index — measure_branching_index","text":"","code":"measure_branching_index(   mw,   rg = NULL,   intrinsic_visc = NULL,   reference = \"linear\",   mh_linear = NULL,   rg_linear_fit = NULL,   method = c(\"g\", \"g_prime\", \"both\") )"},{"path":"/reference/measure_branching_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Branching Index — measure_branching_index","text":"mw Numeric vector molecular weights branched samples. rg Numeric vector radius gyration values (g ratio). intrinsic_visc Numeric vector intrinsic viscosity values (g'). reference Type reference: either \"linear\" comparison linear polymer theory, data frame containing linear reference data. mh_linear Mark-Houwink parameters linear reference polymer (list K ). Required reference = \"linear\" using g'. rg_linear_fit Rg-MW relationship linear polymer: either model list slope intercept log(Rg) = intercept + slope * log(M). method Branching index type: \"g\": Radius gyration ratio: g = Rg^2(branched) / Rg^2(linear) \"g_prime\": Viscosity ratio: g' = [eta](branched) / [eta](linear) \"\": Calculate g g'","code":""},{"path":"/reference/measure_branching_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Branching Index — measure_branching_index","text":"data frame columns: mw Molecular weight g Branching index Rg (calculated) g_prime Branching index viscosity (calculated) branches_per_molecule Estimated branch points (Zimm-Stockmayer)","code":""},{"path":"/reference/measure_branching_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Branching Index — measure_branching_index","text":"Branching reduces hydrodynamic size polymers compared linear counterparts. quantified branching ratios: Rg-based branching index (g): $$g = \\frac{R_g^2(branched)}{R_g^2(linear)}$$ Viscosity-based branching index (g'): $$g' = \\frac{[\\eta](branched)}{[\\eta](linear)}$$ relationship g g' depends polymer architecture: $$g' = g^\\epsilon$$ epsilon ~ 0.5-1.5 depending branching type. Zimm-Stockmayer Model (random branching): $$g = \\frac{6}{n_b} \\left[ \\frac{1}{2} + \\frac{(2 + n_b)^{1/2} - 1 - n_b/2}{n_b} \\right]$$ n_b number branch points per molecule.","code":""},{"path":[]},{"path":"/reference/measure_branching_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Branching Index — measure_branching_index","text":"","code":"# Calculate branching index from Rg data mw <- c(100000, 200000, 500000) rg_branched <- c(12, 18, 32) rg_linear <- c(15, 22, 40)  # Reference linear polymer  g <- measure_branching_index(   mw = mw,   rg = rg_branched,   reference = data.frame(mw = mw, rg = rg_linear),   method = \"g\" )"},{"path":"/reference/measure_conformation_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Conformation Plot Data — measure_conformation_data","title":"Create Conformation Plot Data — measure_conformation_data","text":"Prepares data Mark-Houwink conformation plots (log([eta]) vs log(M) log(Rg) vs log(M)).","code":""},{"path":"/reference/measure_conformation_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Conformation Plot Data — measure_conformation_data","text":"","code":"measure_conformation_data(mw, y, y_type = c(\"iv\", \"rg\"), fit_line = TRUE)"},{"path":"/reference/measure_conformation_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Conformation Plot Data — measure_conformation_data","text":"mw Numeric vector molecular weights. y Numeric vector intrinsic viscosity radius gyration. y_type Type y-axis data: \"iv\" intrinsic viscosity \"rg\" radius gyration. fit_line Logical. Include fitted line? Default TRUE.","code":""},{"path":"/reference/measure_conformation_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Conformation Plot Data — measure_conformation_data","text":"data frame suitable plotting columns: log_mw log10(MW) log_y log10(y) mw Original MW values y Original y values","code":""},{"path":[]},{"path":"/reference/measure_conformation_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Conformation Plot Data — measure_conformation_data","text":"","code":"mw <- c(10000, 50000, 100000, 500000) iv <- c(0.15, 0.35, 0.50, 0.95)  plot_data <- measure_conformation_data(mw, iv, y_type = \"iv\")  # Plot with ggplot2 # ggplot(plot_data, aes(log_mw, log_y)) + #   geom_point() + #   geom_smooth(method = \"lm\")"},{"path":"/reference/measure_mh_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Mark-Houwink Parameters — measure_mh_parameters","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"Estimates Mark-Houwink K (alpha) parameters intrinsic viscosity molecular weight data.","code":""},{"path":"/reference/measure_mh_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"","code":"measure_mh_parameters(   mw,   intrinsic_visc,   weights = NULL,   mw_range = NULL,   log_fit = TRUE )"},{"path":"/reference/measure_mh_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"mw Numeric vector molecular weights. intrinsic_visc Numeric vector intrinsic viscosities (length mw). weights Optional numeric vector weights weighted regression. Use concentration signal intensity weights SEC data. mw_range Optional numeric vector length 2 specifying MW range use fitting. Data outside range excluded. log_fit Logical. Perform fit log-log space (recommended)? Default TRUE.","code":""},{"path":"/reference/measure_mh_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"list class mh_parameters containing: K Mark-Houwink K parameter Mark-Houwink (alpha) exponent r_squared R-squared fit n_points Number data points used mw_range MW range data fit fitted linear model object","code":""},{"path":"/reference/measure_mh_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"Mark-Houwink equation relates intrinsic viscosity molecular weight: $$[\\eta] = K \\cdot M^$$ log form: $$\\log([\\eta]) = \\log(K) + \\cdot \\log(M)$$ parameters K depend : Polymer-solvent system Temperature Polymer microstructure (tacticity, branching) Interpretation '' exponent: ~ 0.5: Theta solvent (polymer coil collapsed) ~ 0.5-0.8: Good solvent (typical range) ~ 0.8: Rigid rod extended chain < 0.5: Branched compact structures","code":""},{"path":[]},{"path":"/reference/measure_mh_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"","code":"# Estimate Mark-Houwink parameters from triple-detection data mw <- c(10000, 25000, 50000, 100000, 250000) iv <- c(0.15, 0.28, 0.45, 0.72, 1.2)  mh <- measure_mh_parameters(mw, iv) print(mh) #> Mark-Houwink Parameters #> ========================================  #>  #> K = 3.8112e-04 #> a = 0.652 #>  #> R-squared: 0.9981 #> Data points: 5 #> MW range: 10000 - 250000 #>  #> Equation: [eta] = K * M^a # K = 0.000114, a = 0.716 (typical for PS in THF)"},{"path":"/reference/measure_sec_asymmetry.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Calculates asymmetry factor () tailing factor (Tf) chromatographic peak.","code":""},{"path":"/reference/measure_sec_asymmetry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"","code":"measure_sec_asymmetry(leading, tailing, method = c(\"usp\", \"ep\"))"},{"path":"/reference/measure_sec_asymmetry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"leading Width leading (front) half peak measurement height. tailing Width tailing (back) half peak measurement height. method Asymmetry calculation method: \"usp\" (default): Tailing factor 5% height \"ep\": Asymmetry factor 10% height","code":""},{"path":"/reference/measure_sec_asymmetry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Numeric asymmetry value. Values > 1 indicate tailing, < 1 indicate fronting. Ideal value 1.0.","code":""},{"path":"/reference/measure_sec_asymmetry.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Peak asymmetry indicates deviation ideal Gaussian peak shape: USP Tailing Factor (5% height): $$T_f = \\frac{W_{0.05}}{2f}$$ W_0.05 width 5% height f leading half-width. EP Asymmetry Factor (10% height): $$A_s = \\frac{b}{}$$ b tailing half-width leading half-width. Interpretation: = 1.0: Symmetric (ideal) < 0.9 > 1.2: Slight asymmetry (acceptable) < 0.8 > 1.5: Significant asymmetry (investigate) > 2.0: Severe tailing (column/sample issue)","code":""},{"path":[]},{"path":"/reference/measure_sec_asymmetry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"","code":"# Calculate USP tailing factor measure_sec_asymmetry(   leading = 0.12,   tailing = 0.15,   method = \"usp\" ) #> [1] 1.125"},{"path":"/reference/measure_sec_plate_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Theoretical Plate Count — measure_sec_plate_count","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Calculates number theoretical plates (N) chromatographic peak, measure column efficiency.","code":""},{"path":"/reference/measure_sec_plate_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"","code":"measure_sec_plate_count(   retention,   width,   width_type = c(\"half_height\", \"baseline\", \"inflection\"),   dead_time = NULL )"},{"path":"/reference/measure_sec_plate_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"retention Retention time peak. width Peak width. See width_type measurement method. width_type Type peak width measurement: \"half_height\" (default): Width 50% height (W0.5h) \"baseline\": Width baseline tangent lines (Wb) \"inflection\": Width inflection points (Wi) dead_time Column dead time (t0). provided, calculates effective plates (N_eff) using adjusted retention time.","code":""},{"path":"/reference/measure_sec_plate_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Numeric plate count. Higher values indicate better efficiency.","code":""},{"path":"/reference/measure_sec_plate_count.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Theoretical plate count measures column efficiency: Half-height width (common): $$N = 5.54 \\left(\\frac{t_R}{W_{0.5h}}\\right)^2$$ Baseline width: $$N = 16 \\left(\\frac{t_R}{W_b}\\right)^2$$ dead time correction (effective plates): $$N_{eff} = 5.54 \\left(\\frac{t_R - t_0}{W_{0.5h}}\\right)^2$$ Typical SEC Performance: Analytical SEC columns: 10,000-40,000 plates/meter Preparative columns: 5,000-15,000 plates/meter UHPLC SEC: 50,000+ plates/meter","code":""},{"path":[]},{"path":"/reference/measure_sec_plate_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"","code":"# Calculate plate count for a monomer peak measure_sec_plate_count(   retention = 9.5,   width = 0.25,   width_type = \"half_height\" ) #> [1] 7999.76  # With dead time for effective plates measure_sec_plate_count(   retention = 9.5,   width = 0.25,   dead_time = 3.0 ) #> [1] 3745.04"},{"path":"/reference/measure_sec_recovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mass Recovery — measure_sec_recovery","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Calculates mass recovery (percent injected mass detected) SEC analysis.","code":""},{"path":"/reference/measure_sec_recovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mass Recovery — measure_sec_recovery","text":"","code":"measure_sec_recovery(detected_mass, injected_mass, units = \"mg\")"},{"path":"/reference/measure_sec_recovery.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mass Recovery — measure_sec_recovery","text":"detected_mass Mass detected integration chromatogram. injected_mass Mass injected onto column. units Units mass values. must units.","code":""},{"path":"/reference/measure_sec_recovery.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Numeric recovery percentage (0-100+).","code":""},{"path":"/reference/measure_sec_recovery.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Mass recovery verifies analytical system detecting injected sample: $$\\% Recovery = \\frac{m_{detected}}{m_{injected}} \\times 100$$ Interpretation: 95-105%: Excellent recovery (typical acceptance) 90-95% 105-110%: Acceptable (investigate persistent) < 90%: Low recovery - possible column adsorption, precipitation > 110%: High recovery - calibration issue, interference Common Causes Low Recovery: Sample adsorption column packing Sample precipitation aggregation -column Detector calibration drift Integration baseline errors Sample degradation","code":""},{"path":[]},{"path":"/reference/measure_sec_recovery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mass Recovery — measure_sec_recovery","text":"","code":"# Calculate recovery measure_sec_recovery(   detected_mass = 0.195,   injected_mass = 0.200 ) #> [1] 97.5 # Returns 97.5%"},{"path":"/reference/measure_sec_resolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peak Resolution — measure_sec_resolution","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Calculates resolution two chromatographic peaks using USP EP formula.","code":""},{"path":"/reference/measure_sec_resolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peak Resolution — measure_sec_resolution","text":"","code":"measure_sec_resolution(   retention_1,   retention_2,   width_1,   width_2,   width_type = c(\"baseline\", \"half_height\", \"tangent\"),   method = c(\"usp\", \"ep\") )"},{"path":"/reference/measure_sec_resolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peak Resolution — measure_sec_resolution","text":"retention_1 Retention time first peak (earlier eluting). retention_2 Retention time second peak (later eluting). width_1 Peak width first peak. See width_type units. width_2 Peak width second peak. width_type Type peak width measurement: \"baseline\" (default): Width baseline (Wb) \"half_height\": Width half height (W0.5h) \"tangent\": Width tangent lines inflection points method Resolution formula use: \"usp\" (default): Rs = 2(t2 - t1) / (w1 + w2) \"ep\": Rs = 1.18(t2 - t1) / (w1_0.5h + w2_0.5h)","code":""},{"path":"/reference/measure_sec_resolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Numeric resolution value. Rs > 1.5 indicates baseline separation.","code":""},{"path":"/reference/measure_sec_resolution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Resolution quantifies degree separation adjacent peaks: USP Formula (baseline width): $$R_s = \\frac{2(t_2 - t_1)}{W_{b1} + W_{b2}}$$ EP Formula (half-height width): $$R_s = \\frac{1.18(t_2 - t_1)}{W_{0.5h,1} + W_{0.5h,2}}$$ Interpretation: Rs < 1.0: Peaks overlap significantly Rs = 1.0: ~94% separation (4 sigma) Rs = 1.5: Baseline separation (~99.7%) Rs > 2.0: Complete separation gap","code":""},{"path":[]},{"path":"/reference/measure_sec_resolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peak Resolution — measure_sec_resolution","text":"","code":"# Calculate resolution between monomer and dimer measure_sec_resolution(   retention_1 = 8.2,   # dimer (elutes first in SEC)   retention_2 = 9.5,   # monomer   width_1 = 0.4,   width_2 = 0.5 ) #> [1] 2.888889"},{"path":"/reference/measure_sec_slice_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"Extracts point--point (slice) data SEC analysis results, creating long-format table suitable export analysis.","code":""},{"path":"/reference/measure_sec_slice_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"","code":"measure_sec_slice_table(   data,   measures = NULL,   sample_id = NULL,   include_location = TRUE,   pivot = FALSE )"},{"path":"/reference/measure_sec_slice_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"data data frame containing SEC results measure columns. measures Character vector measure column names include. NULL, includes measure columns found. sample_id Column name containing sample identifiers. NULL, uses row numbers. include_location Logical. Include location (time/volume) column? Default TRUE. pivot Logical. Pivot measures wide format (one column per measure)? Default FALSE (long format).","code":""},{"path":"/reference/measure_sec_slice_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"tibble slice--slice data: sample_id Sample identifier slice Slice index (1, 2, 3, ...) location Elution time volume measure Measure column name (pivot = FALSE) value Signal value (pivot = FALSE) <measure_names> Individual measure columns (pivot = TRUE)","code":""},{"path":"/reference/measure_sec_slice_table.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"function extracts raw slice data processed SEC chromatograms, making easy : Export CSV/Excel external analysis Create custom plots Perform slice-level calculations Compare samples point--point Typical Slice Data Columns: Retention time/volume (location) Concentration (RI UV) Molecular weight (calibration MALS) Intrinsic viscosity (viscometer) Radius gyration (MALS angles) Composition (UV/RI ratio)","code":""},{"path":[]},{"path":"/reference/measure_sec_slice_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process SEC data prepped <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   prep() |>   bake(new_data = NULL)  # Extract slice table (long format) slices <- measure_sec_slice_table(prepped, measures = \"ri\")  # Extract slice table (wide format) slices_wide <- measure_sec_slice_table(   prepped,   measures = c(\"ri\", \"mw\"),   pivot = TRUE )  # Export to CSV write.csv(slices, \"sec_slices.csv\", row.names = FALSE) } # }"},{"path":"/reference/measure_sec_suitability.html","id":null,"dir":"Reference","previous_headings":"","what":"System Suitability Test for SEC — measure_sec_suitability","title":"System Suitability Test for SEC — measure_sec_suitability","text":"Performs comprehensive system suitability testing SEC analysis, evaluating resolution, plate count, asymmetry, quality metrics.","code":""},{"path":"/reference/measure_sec_suitability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"System Suitability Test for SEC — measure_sec_suitability","text":"","code":"measure_sec_suitability(   data = NULL,   peaks,   reference_peaks = NULL,   injected_mass = NULL,   criteria = NULL,   column_length = NULL )"},{"path":"/reference/measure_sec_suitability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"System Suitability Test for SEC — measure_sec_suitability","text":"data data frame tibble containing chromatogram data minimum retention times peak parameters. peaks data frame peak information. Must contain columns: retention: Peak retention time width: Peak width (half height unless specified) area: Peak area (recovery calculation) height: Peak height (optional, asymmetry raw data reference_peaks Character vector peak names use resolution calculation (e.g., c(\"dimer\", \"monomer\")). injected_mass Injected mass recovery calculation (optional). criteria list acceptance criteria. Default uses common biopharmaceutical criteria. column_length Column length cm (plates per meter calculation).","code":""},{"path":"/reference/measure_sec_suitability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"System Suitability Test for SEC — measure_sec_suitability","text":"list class sec_suitability containing: results Data frame calculated metrics pass/fail status passed Logical indicating criteria passed summary Character summary results criteria Criteria used evaluation","code":""},{"path":"/reference/measure_sec_suitability.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"System Suitability Test for SEC — measure_sec_suitability","text":"System suitability testing (SST) verifies chromatographic system performing adequately , , sample analysis. Standard SEC SST Parameters: Resolution: Rs >= 1.5 critical pair Plate count: N >= specified minimum Tailing factor: 0.8 <= Tf <= 1.5 Mass recovery: 95-105% Retention time RSD: <= 1.0% Peak area RSD: <= 2.0% Regulatory References: USP <621> Chromatography ICH Q2(R1) Validation EP 2.2.46 Chromatographic Separation Techniques","code":""},{"path":[]},{"path":"/reference/measure_sec_suitability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"System Suitability Test for SEC — measure_sec_suitability","text":"","code":"if (FALSE) { # \\dontrun{ # Define peaks from integration results peaks <- data.frame(   name = c(\"aggregate\", \"dimer\", \"monomer\", \"fragment\"),   retention = c(7.2, 8.5, 9.8, 11.5),   width = c(0.3, 0.25, 0.28, 0.35),   area = c(2.1, 5.3, 89.2, 3.4) )  # Run system suitability sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\"),   injected_mass = 0.200,   column_length = 30 )  print(sst) } # }"},{"path":"/reference/measure_sec_summary_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate SEC Summary Table — measure_sec_summary_table","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"Creates summary table SEC analysis results key metrics sample.","code":""},{"path":"/reference/measure_sec_summary_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"","code":"measure_sec_summary_table(   data,   mw_col = NULL,   include_mw = TRUE,   include_fractions = TRUE,   include_purity = TRUE,   sample_id = NULL,   additional_cols = NULL,   digits = 2 )"},{"path":"/reference/measure_sec_summary_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"data data frame containing SEC results. mw_col Column name containing molecular weight averages (list column Mn, Mw, Mz, dispersity). include_mw Logical. Include molecular weight averages? Default TRUE. include_fractions Logical. Include MW fractions available? Default TRUE. include_purity Logical. Include purity metrics (HMWS, monomer, LMWS) available? Default TRUE. sample_id Column name sample identifiers. additional_cols Character vector additional columns include summary. digits Number decimal places numeric columns. Default 2.","code":""},{"path":"/reference/measure_sec_summary_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"tibble one row per sample containing: sample_id Sample identifier Mn Number-average molecular weight Mw Weight-average molecular weight Mz Z-average molecular weight dispersity Polydispersity index (Mw/Mn) purity_hmws Percent high MW species (available) purity_monomer Percent monomer (available) purity_lmws Percent low MW species (available)","code":""},{"path":"/reference/measure_sec_summary_table.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"function creates publication-ready summary table SEC results. automatically detects includes available metrics. Typical Summary Metrics: Molecular weight averages: Mn, Mw, Mz Dispersity (PDI): Mw/Mn Purity metrics: %HMWS, %Monomer, %LMWS MW fractions: % /cutoffs Recovery: % mass balance","code":""},{"path":[]},{"path":"/reference/measure_sec_summary_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"","code":"if (FALSE) { # \\dontrun{ # Generate summary after SEC processing summary_tbl <- measure_sec_summary_table(   processed_data,   sample_id = \"sample_name\" )  # Print formatted table print(summary_tbl)  # Export to Excel writexl::write_xlsx(summary_tbl, \"sec_summary.xlsx\") } # }"},{"path":"/reference/required_pkgs.step_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"Returns packages required use step.","code":""},{"path":"/reference/required_pkgs.step_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"","code":"# S3 method for class 'step_sec_aggregates' required_pkgs(x, ...)  # S3 method for class 'step_sec_band_broadening' required_pkgs(x, ...)  # S3 method for class 'step_sec_baseline' required_pkgs(x, ...)  # S3 method for class 'step_sec_composition' required_pkgs(x, ...)  # S3 method for class 'step_sec_concentration' required_pkgs(x, ...)  # S3 method for class 'step_sec_conventional_cal' required_pkgs(x, ...)  # S3 method for class 'step_sec_dad' required_pkgs(x, ...)  # S3 method for class 'step_sec_detector_delay' required_pkgs(x, ...)  # S3 method for class 'step_sec_dls' required_pkgs(x, ...)  # S3 method for class 'step_sec_intrinsic_visc' required_pkgs(x, ...)  # S3 method for class 'step_sec_lals' required_pkgs(x, ...)  # S3 method for class 'step_sec_mals' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_averages' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_distribution' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_fractions' required_pkgs(x, ...)  # S3 method for class 'step_sec_oligomer' required_pkgs(x, ...)  # S3 method for class 'step_sec_protein' required_pkgs(x, ...)  # S3 method for class 'step_sec_rals' required_pkgs(x, ...)  # S3 method for class 'step_sec_ri' required_pkgs(x, ...)  # S3 method for class 'step_sec_universal_cal' required_pkgs(x, ...)  # S3 method for class 'step_sec_uv' required_pkgs(x, ...)  # S3 method for class 'step_sec_uv_ri_ratio' required_pkgs(x, ...)  # S3 method for class 'step_sec_viscometer' required_pkgs(x, ...)"},{"path":"/reference/required_pkgs.step_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"x recipe step object. ... currently used.","code":""},{"path":"/reference/required_pkgs.step_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"character vector package names.","code":""},{"path":"/reference/sec_calibration_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"Comprehensive calibration standard data SEC/GPC analysis, containing polystyrene PMMA narrow standards certificate values, retention data, Mark-Houwink parameters. Based commercial standard kits.","code":""},{"path":"/reference/sec_calibration_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"","code":"sec_calibration_standards"},{"path":"/reference/sec_calibration_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"tibble 26 rows 19 columns: standard_name Character. Standard identifier (e.g., \"PS-67500\", \"PMMA-30300\") polymer_type Character. Either \"polystyrene\" \"pmma\" kit_name Character. Commercial kit name reference mp Numeric. Peak molecular weight Da (commonly used calibration) mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn), typically 1.02-1.05 mp_uncertainty Numeric. Relative uncertainty Mp (e.g., 0.05 = 5%) log_mp Numeric. log10(Mp) calibration curve fitting log_mw Numeric. log10(Mw) log_mn Numeric. log10(Mn) retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL k_value Numeric. Mark-Houwink K constant mL/g a_value Numeric. Mark-Houwink exponent (alpha) intrinsic_viscosity Numeric. Intrinsic viscosity mL/g log_hydrodynamic_vol Numeric. log10(M * [eta]) universal calibration dn_dc Numeric. Refractive index increment mL/g notes Character. Special notes (e.g., near exclusion limit)","code":""},{"path":"/reference/sec_calibration_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"Synthetic data based typical commercial narrow standards (e.g., Agilent EasiVial, PSS ReadyCal) realistic retention times PLgel Mixed-C columns THF 1.0 mL/min.","code":""},{"path":"/reference/sec_calibration_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"dataset enables several key calibration workflows: Conventional Calibration: Use retention_time (retention_volume) log_mp step_sec_conventional_cal build calibration curve. Universal Calibration: Use log_hydrodynamic_vol vs retention polymer-independent calibration. Mark-Houwink parameters (k_value, a_value) enable conversion polymers. Quality Assessment: mp_uncertainty values (typical certificates) enable uncertainty propagation calibration. Dispersity values confirm standards suitably narrow. Polymer Types: 16 polystyrene standards (162 Da 3,150,000 Da) 10 PMMA standards (602 Da 1,190,000 Da) Mark-Houwink Parameters (THF, 35°C): Polystyrene: K = 0.000141 mL/g, = 0.700 PMMA: K = 0.000128 mL/g, = 0.690","code":""},{"path":[]},{"path":"/reference/sec_calibration_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"","code":"library(dplyr) data(sec_calibration_standards)  # View the polystyrene standards sec_calibration_standards |>   filter(polymer_type == \"polystyrene\") |>   select(standard_name, mp, log_mp, retention_time) #> # A tibble: 16 × 4 #>    standard_name      mp log_mp retention_time #>    <chr>           <dbl>  <dbl>          <dbl> #>  1 PS-3150000    3150000   6.50           11.2 #>  2 PS-1870000    1870000   6.27           11.6 #>  3 PS-1090000    1090000   6.04           12.1 #>  4 PS-630000      630000   5.80           12.6 #>  5 PS-430000      430000   5.63           13.2 #>  6 PS-216000      216000   5.33           13.8 #>  7 PS-120000      120000   5.08           14.3 #>  8 PS-67500        67500   4.83           15.0 #>  9 PS-33500        33500   4.53           15.5 #> 10 PS-19800        19800   4.30           16.1 #> 11 PS-9680          9680   3.99           16.7 #> 12 PS-5030          5030   3.70           17.4 #> 13 PS-2970          2970   3.47           17.9 #> 14 PS-1050          1050   3.02           18.9 #> 15 PS-580            580   2.76           19.4 #> 16 PS-162            162   2.21           20.8  # Compare PS and PMMA at similar MW - PMMA elutes later (smaller Rh) sec_calibration_standards |>   filter(mp > 60000 & mp < 80000) |>   select(standard_name, polymer_type, mp, retention_time) #> # A tibble: 2 × 4 #>   standard_name polymer_type    mp retention_time #>   <chr>         <chr>        <dbl>          <dbl> #> 1 PMMA-67700    pmma         67700           14.8 #> 2 PS-67500      polystyrene  67500           15.0  # Prepare standards for conventional calibration ps_cal <- sec_calibration_standards |>   filter(polymer_type == \"polystyrene\") |>   select(retention = retention_time, log_mw = log_mp)"},{"path":"/reference/sec_pmma_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC PMMA Calibration Standards — sec_pmma_standards","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"Poly(methyl methacrylate) narrow molecular weight standards SEC/GPC calibration. convenient subset sec_calibration_standards containing PMMA standards.","code":""},{"path":"/reference/sec_pmma_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"","code":"sec_pmma_standards"},{"path":"/reference/sec_pmma_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"tibble 10 rows 12 columns: standard_name Character. Standard identifier (e.g., \"PMMA-67700\") mp Numeric. Peak molecular weight Da log_mp Numeric. log10(Mp) calibration curve fitting retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn) mp_uncertainty Numeric. Relative uncertainty Mp k_value Numeric. Mark-Houwink K constant (0.000128 mL/g) a_value Numeric. Mark-Houwink exponent (0.690) dn_dc Numeric. Refractive index increment (0.084 mL/g)","code":""},{"path":"/reference/sec_pmma_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"Synthetic data based typical commercial narrow PMMA standards.","code":""},{"path":"/reference/sec_pmma_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"PMMA standards useful : Calibrating PMMA acrylate samples Validating universal calibration comparing PS vs PMMA curves Demonstrating polymer-specific hydrodynamic volume differences equivalent molecular weight, PMMA smaller hydrodynamic volume PS THF, PMMA standards elute later PS MW. demonstrates conventional calibration polymer-specific. Universal Calibration Validation: plotted log(M * [eta]) vs retention time, PS PMMA fall curve, confirming universal calibration valid column.","code":""},{"path":[]},{"path":"/reference/sec_pmma_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"","code":"data(sec_pmma_standards) data(sec_ps_standards)  # Compare PS and PMMA calibration curves if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    bind_rows(     sec_ps_standards |> mutate(polymer = \"PS\"),     sec_pmma_standards |> mutate(polymer = \"PMMA\")   ) |>     ggplot(aes(retention_time, log_mp, color = polymer)) +     geom_point(size = 3) +     geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), se = FALSE) +     labs(       x = \"Retention Time (min)\",       y = expression(log[10](M[p])),       title = \"PS vs PMMA Calibration Curves\",       subtitle = \"PMMA elutes later at same MW (smaller hydrodynamic volume)\"     ) +     theme_minimal() }"},{"path":"/reference/sec_ps_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC Polystyrene Calibration Standards — sec_ps_standards","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Polystyrene narrow molecular weight standards SEC/GPC conventional calibration. convenient subset sec_calibration_standards containing polystyrene standards.","code":""},{"path":"/reference/sec_ps_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"","code":"sec_ps_standards"},{"path":"/reference/sec_ps_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"tibble 16 rows 12 columns: standard_name Character. Standard identifier (e.g., \"PS-67500\") mp Numeric. Peak molecular weight Da log_mp Numeric. log10(Mp) calibration curve fitting retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn) mp_uncertainty Numeric. Relative uncertainty Mp k_value Numeric. Mark-Houwink K constant (0.000141 mL/g) a_value Numeric. Mark-Houwink exponent (0.700) dn_dc Numeric. Refractive index increment (0.185 mL/g)","code":""},{"path":"/reference/sec_ps_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Synthetic data based typical commercial narrow PS standards.","code":""},{"path":"/reference/sec_ps_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Polystyrene widely used SEC calibration standard due : Availability narrow dispersity grades across wide MW range Well-characterized Mark-Houwink parameters common solvents Strong UV absorption dual detection Good solubility stability 16 standards span 162 Da 3,150,000 Da, covering typical analytical SEC columns. Standards pre-sorted descending molecular weight (elution order). Usage step_sec_conventional_cal:","code":"library(dplyr) standards <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  recipe(~., data = my_data) |>   step_sec_conventional_cal(standards = standards, fit_type = \"cubic\")"},{"path":[]},{"path":"/reference/sec_ps_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"","code":"data(sec_ps_standards)  # Quick look at the calibration range range(sec_ps_standards$mp) #> [1]     162 3150000 range(sec_ps_standards$retention_time) #> [1] 11.150 20.787  # Plot calibration curve if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   ggplot(sec_ps_standards, aes(retention_time, log_mp)) +     geom_point(size = 3) +     geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), se = FALSE) +     labs(       x = \"Retention Time (min)\",       y = expression(log[10](M[p])),       title = \"PS Calibration Curve (Cubic Fit)\"     ) +     theme_minimal() }"},{"path":"/reference/sec_triple_detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-Detector SEC Data — sec_triple_detect","title":"Multi-Detector SEC Data — sec_triple_detect","text":"synthetic dataset containing multi-detector Size Exclusion Chromatography (SEC) data 12 polymer samples realistic signal characteristics.","code":""},{"path":"/reference/sec_triple_detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-Detector SEC Data — sec_triple_detect","text":"","code":"sec_triple_detect"},{"path":"/reference/sec_triple_detect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Multi-Detector SEC Data — sec_triple_detect","text":"tibble 24,012 rows 11 columns: sample_id Character. Unique sample identifier (e.g., \"PS-10K\", \"PMMA-Low\") sample_type Character. Either \"standard\" (narrow dispersity calibrants) \"sample\" polymer_type Character. Polymer type: \"polystyrene\", \"pmma\", \"peg\", \"copolymer\" elution_time Numeric. Elution time minutes (5-25 min range) ri_signal Numeric. Refractive index detector signal (reference detector) uv_signal Numeric. UV detector signal 280 nm mals_signal Numeric. Multi-angle light scattering detector signal known_mw Numeric. True weight-average molecular weight (Mw) g/mol known_dispersity Numeric. True dispersity (Mw/Mn) dn_dc Numeric. Refractive index increment mL/g extinction_coef Numeric. UV extinction coefficient mL/(mg*cm)","code":""},{"path":"/reference/sec_triple_detect.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Multi-Detector SEC Data — sec_triple_detect","text":"Synthetic data generated package testing examples.","code":""},{"path":"/reference/sec_triple_detect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multi-Detector SEC Data — sec_triple_detect","text":"dataset includes realistic features commonly encountered SEC analysis: Sample Composition: 5 polystyrene standards (1K 500K MW, narrow dispersity ~1.01-1.05) 3 PMMA samples (25K 200K MW, broader dispersity 1.8-2.2) 2 PEG samples (5K 20K MW, low dispersity ~1.1-1.15) 2 copolymer samples (40K 80K MW, intermediate dispersity 1.5-1.7) Multi-Detector Features: Inter-detector volume delays: UV 0.05 mL RI, MALS 0.15 mL RI Different detector responses based polymer chemistry PEG UV response (extinction_coef = 0) MALS signal scales MW absolute MW determination Signal Characteristics: Gaussian noise appropriate detector Slight baseline drift Log-normal peak shapes tailing Typical SEC Workflow: 1 . Convert measure format step_measure_input_long 2. Correct inter-detector delays step_sec_detector_delay 3. Apply baseline correction step_sec_baseline 4. Process detectors step_sec_ri step_sec_uv 5. Convert concentration step_sec_concentration 6. Calculate MW averages step_sec_mw_averages","code":""},{"path":[]},{"path":"/reference/sec_triple_detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-Detector SEC Data — sec_triple_detect","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure) library(measure.sec)  # Load the dataset data(sec_triple_detect)  # View sample distribution table(sec_triple_detect$polymer_type)  # Plot RI chromatograms for polystyrene standards library(ggplot2) sec_triple_detect |>   dplyr::filter(polymer_type == \"polystyrene\") |>   ggplot(aes(elution_time, ri_signal, color = sample_id)) +   geom_line() +   labs(x = \"Elution Time (min)\", y = \"RI Signal\", color = \"Sample\")  # Process with SEC recipe rec <- recipe(~ ., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline(measures = \"ri\") |>   step_sec_ri(dn_dc_column = \"dn_dc\") |>   prep() } # }"},{"path":"/reference/step_sec_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"step_sec_aggregates() creates specification recipe step quantifies high molecular weight species (HMWS/aggregates), monomers, low molecular weight species (LMWS/fragments) protein SEC chromatograms.","code":""},{"path":"/reference/step_sec_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"","code":"step_sec_aggregates(   recipe,   measures = NULL,   monomer_start = NULL,   monomer_end = NULL,   method = c(\"tallest\", \"manual\"),   hmws_threshold = 0.001,   include_main_peak = TRUE,   output_prefix = \"purity_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_aggregates\") )"},{"path":"/reference/step_sec_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. monomer_start Start monomer peak region (location units, typically minutes). NULL, automatically determined. monomer_end End monomer peak region. NULL, automatically determined. method Method peak boundary detection monomer_start monomer_end NULL: \"tallest\" (default): Uses tallest peak monomer \"manual\": Requires explicit boundaries hmws_threshold Minimum fraction monomer height consider HMWS signal. Default 0.001 (0.1%). , signal considered baseline. include_main_peak Logical. Include main peak boundaries output? Default TRUE. output_prefix Prefix output columns. Default \"purity_\". Creates columns: {prefix}hmws, {prefix}monomer, {prefix}lmws. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"updated recipe new columns containing aggregate percentages: purity_hmws Percent high molecular weight species (aggregates) purity_monomer Percent monomer (main peak) purity_lmws Percent low molecular weight species (fragments) purity_main_start Start main peak region (include_main_peak) purity_main_end End main peak region (include_main_peak)","code":""},{"path":"/reference/step_sec_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"Aggregate analysis critical biopharmaceutical characterization: HMWS (High Molecular Weight Species): Elute monomer peak. Includes dimers, trimers, higher-order aggregates. Monomer: main therapeutic protein peak. LMWS (Low Molecular Weight Species): Elute monomer peak. Includes fragments, clips, degradation products. Calculation Method: $$\\% HMWS = \\frac{A_{HMWS}}{A_{total}} \\times 100$$ $$\\% Monomer = \\frac{A_{monomer}}{A_{total}} \\times 100$$ $$\\% LMWS = \\frac{A_{LMWS}}{A_{total}} \\times 100$$ represents integrated peak areas. Regulatory Importance: ICH Q6B requires aggregate content specification USP <129> provides guidance aggregate testing Typical acceptance: HMWS < 5%, Monomer > 95%","code":""},{"path":"/reference/step_sec_aggregates.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"accurate results: Baseline correct chromatogram first Ensure proper column resolution (especially dimer separation) Use UV detection 280 nm (214 nm higher sensitivity)","code":""},{"path":[]},{"path":"/reference/step_sec_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Analyze mAb aggregate content rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_aggregates(     monomer_start = 8.5,     monomer_end = 10.5   ) |>   prep()  # Automatic peak detection rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_aggregates(method = \"tallest\") |>   prep() } # }"},{"path":"/reference/step_sec_band_broadening.html","id":null,"dir":"Reference","previous_headings":"","what":"Band Broadening Correction for SEC — step_sec_band_broadening","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"step_sec_band_broadening() creates specification recipe step corrects axial dispersion (band broadening) SEC chromatograms. improves accuracy molecular weight distribution measurements.","code":""},{"path":"/reference/step_sec_band_broadening.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"","code":"step_sec_band_broadening(   recipe,   measures = NULL,   method = c(\"tung\", \"emg\"),   sigma = NULL,   calibration_peak = NULL,   tau = NULL,   iterations = 1,   damping = 0.5,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_band_broadening\") )"},{"path":"/reference/step_sec_band_broadening.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"recipe recipe object. measures Character vector measure column names process. NULL, measure columns processed. method Correction method. One : \"tung\" (default): Tung's linear correction \"emg\": Exponentially Modified Gaussian deconvolution sigma Spreading parameter (standard deviation instrumental broadening function) units location axis (typically minutes mL). NULL, must provide calibration_peak. calibration_peak measure_tbl data frame location value columns representing narrow standard peak used estimate sigma. tau Exponential time constant EMG method. NULL EMG method, estimated calibration_peak. iterations Number iterations iterative correction. Default 1 Tung's method (single pass). Higher values may improve correction can introduce instability. damping Damping factor (0-1) prevent -correction instability. Default 0.5. Lower values conservative. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_band_broadening.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_band_broadening.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Band broadening SEC occurs due : Axial diffusion elution Non-ideal column packing Extra-column volume (tubing, connections, detector cell) causes: Artificially broadened peaks Underestimated Mn (number-average MW) Overestimated dispersity (Mw/Mn) Tung's Method (default): observed chromatogram F(V) related true distribution W(V) : $$F(V) = \\int W(V') G(V - V') dV'$$ G Gaussian spreading function standard deviation sigma. Tung's linear correction approximates: $$W(V) \\approx F(V) - \\sigma^2 \\frac{d^2 F(V)}{dV^2}$$ EMG Method: Models band broadening convolution Exponentially Modified Gaussian, better handles asymmetric peak shapes caused tailing. Sigma Determination: spreading parameter sigma determined narrow molecular weight standard (e.g., polystyrene PDI < 1.05). Use estimate_sigma() calculate sigma standard.","code":""},{"path":"/reference/step_sec_band_broadening.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Correction applied signal, molecular weight values Large corrections (> 50% change peak width) may indicate unreliable sigma poor chromatographic conditions step preserves area curve (mass conservation)","code":""},{"path":"/reference/step_sec_band_broadening.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Tung, L. H. (1966). Method calculating molecular weight distribution function gel permeation chromatograms. Journal Applied Polymer Science, 10(3), 375-385.","code":""},{"path":[]},{"path":"/reference/step_sec_band_broadening.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Using a known sigma value rec <- recipe(~., data = sec_data) |>   step_measure_input_long(signal, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_band_broadening(sigma = 0.05) |>   prep()  # Estimating sigma from a narrow standard narrow_std <- estimate_sigma(narrow_standard_peak) rec <- recipe(~., data = sec_data) |>   step_measure_input_long(signal, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_band_broadening(sigma = narrow_std$sigma) |>   prep() } # }"},{"path":"/reference/step_sec_baseline.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Baseline Correction — step_sec_baseline","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"step_sec_baseline() creates specification recipe step applies baseline correction optimized Gel Permeation Chromatography (GPC) Size Exclusion Chromatography (SEC) data. method estimates baseline interpolating baseline regions start end chromatogram.","code":""},{"path":"/reference/step_sec_baseline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"","code":"step_sec_baseline(   recipe,   measures = NULL,   left_frac = 0.05,   right_frac = 0.05,   method = \"linear\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_baseline\") )"},{"path":"/reference/step_sec_baseline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"recipe recipe object. step added sequence operations recipe. measures optional character vector measure column names process. NULL (default), measure columns (columns class measure_list) processed. left_frac Fraction points beginning use left baseline region. Default 0.05 (first 5% data points). right_frac Fraction points end use right baseline region. Default 0.05 (last 5% data points). method Method baseline estimation. One : \"linear\" (default): Linear interpolation left right means \"median\": Uses median baseline regions (robust outliers) \"spline\": Smooth spline baseline regions role used step since new variables created. trained logical indicate quantities preprocessing estimated. skip logical. step skipped recipe baked? id character string unique step identify .","code":""},{"path":"/reference/step_sec_baseline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"/reference/step_sec_baseline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"GPC/SEC chromatograms typically distinct baseline regions beginning end polymer elutes. step leverages characteristic : Identifying baseline regions start end chromatogram Computing representative baseline value region (mean median) Interpolating values estimate full baseline Subtracting estimated baseline signal left_frac right_frac parameters control much chromatogram considered \"baseline\". Choose values : Include flat, signal-free regions Exclude polymer peaks system peaks large enough average noise Unlike general-purpose baseline methods like ALS polynomial fitting, approach specifically designed characteristic shape GPC/SEC chromatograms computationally fast. selectors supplied step function. data internal format produced measure::step_measure_input_wide() measure::step_measure_input_long().","code":""},{"path":"/reference/step_sec_baseline.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"tidy() step, tibble columns terms, left_frac, right_frac, method, id returned.","code":""},{"path":[]},{"path":"/reference/step_sec_baseline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # SEC baseline correction with default settings rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   prep()  # Using median method for robustness to outliers rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline(left_frac = 0.1, right_frac = 0.1, method = \"median\") |>   prep() } # }"},{"path":"/reference/step_sec_composition.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"step_sec_composition() creates specification recipe step calculates weight fraction components copolymer blend using UV RI detector signals known response factors.","code":""},{"path":"/reference/step_sec_composition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"","code":"step_sec_composition(   recipe,   uv_col = NULL,   ri_col = NULL,   component_a_uv,   component_a_ri,   component_b_uv,   component_b_ri,   output_col = \"composition_a\",   min_signal = 0.01,   clip = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_composition\") )"},{"path":"/reference/step_sec_composition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"recipe recipe object. uv_col Name UV detector measure column. ri_col Name RI detector measure column. component_a_uv UV response factor component (extinction coefficient mL/(mg*cm) relative units). component_a_ri RI response factor component (dn/dc mL/g relative units). component_b_uv UV response factor component B. component_b_ri RI response factor component B. output_col Name output composition column. Default \"composition_a\". Contains weight fraction component (0-1). min_signal Minimum signal threshold (fraction max) composition set NA. Default 0.01. clip Logical. Clip composition values [0, 1] range? Default TRUE. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_composition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_composition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"two-component system, detector signals : $$UV = \\varepsilon_A \\cdot c_A + \\varepsilon_B \\cdot c_B$$ $$RI = (dn/dc)_A \\cdot c_A + (dn/dc)_B \\cdot c_B$$ c_A c_B concentrations components B. weight fraction component calculated solving system: $$w_A = \\frac{R_{obs} - R_B}{R_A - R_B}$$ R_obs observed UV/RI ratio, R_A, R_B ratios pure components (e/dn/dc). Common Applications: Styrene-acrylate copolymers (styrene UV-active) Block copolymers different chromophore content PEGylated proteins (protein 280nm, PEG UV-transparent) Polymer blends known compositions Example Response Factors: Polystyrene: UV (254nm) ~ 1.0, dn/dc ~ 0.185 PMMA: UV (254nm) ~ 0.01, dn/dc ~ 0.084 PEG: UV (280nm) ~ 0, dn/dc ~ 0.135 Proteins: UV (280nm) ~ 1.0, dn/dc ~ 0.185","code":""},{"path":"/reference/step_sec_composition.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"Response factors must consistent units. absolute values matter long ratios correct pure components.","code":""},{"path":[]},{"path":"/reference/step_sec_composition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Styrene-MMA copolymer composition rec <- recipe(~., data = copolymer_data) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     component_a_uv = 1.0,    # Styrene (UV-active)     component_a_ri = 0.185,  # Styrene dn/dc     component_b_uv = 0.01,   # MMA (weak UV)     component_b_ri = 0.084,  # MMA dn/dc     output_col = \"styrene_fraction\"   ) |>   prep() } # }"},{"path":"/reference/step_sec_concentration.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Detector Signal to Concentration — step_sec_concentration","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"step_sec_concentration() creates specification recipe step converts detector signals absolute concentration values using calibration factors injection parameters.","code":""},{"path":"/reference/step_sec_concentration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"","code":"step_sec_concentration(   recipe,   measures = NULL,   detector = c(\"ri\", \"uv\", \"auto\"),   injection_volume = NULL,   injection_mass = NULL,   sample_concentration = NULL,   flow_rate = 1,   concentration_units = \"mg/mL\",   normalize_to_mass = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_concentration\") )"},{"path":"/reference/step_sec_concentration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"recipe recipe object. measures Character vector detector column names convert. NULL, convert measure columns. detector Type detector signal converted: \"ri\": Refractive index detector (assumes dn/dc normalized) \"uv\": UV detector (assumes extinction coefficient normalized) \"auto\": Attempt detect column names injection_volume Injection volume uL. Required absolute concentration calculation. injection_mass Injected mass mg. Alternative using sample_concentration injection_volume. sample_concentration Sample concentration mg/mL. Used injection_volume calculate injected mass. flow_rate Flow rate mL/min peak area calculations. concentration_units Output concentration units. Default \"mg/mL\". normalize_to_mass Logical. TRUE, normalize chromatogram total area equals injected mass. Default TRUE. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_concentration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_concentration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"step converts detector response (dn/dc extinction coefficient normalization) absolute concentration. conversion uses known injected mass normalize chromatogram area: $$c(t) = \\frac{S(t) \\times m_{inj}}{\\int S(t) \\times F \\times dt}$$ : S(t) normalized detector signal m_inj injected mass F flow rate Workflow concentration determination: Baseline correct chromatogram Apply detector-specific normalization (dn/dc extinction coefficient) Apply step known injection parameters Result: concentration elution point","code":""},{"path":[]},{"path":"/reference/step_sec_concentration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Convert RI signal to concentration rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(     detector = \"ri\",     injection_volume = 100,        # uL     sample_concentration = 2.0,    # mg/mL     flow_rate = 1.0                # mL/min   ) |>   prep() } # }"},{"path":"/reference/step_sec_conventional_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"step_sec_conventional_cal() creates specification recipe step fits calibration curve narrow molecular weight standards applies convert elution time/volume molecular weight.","code":""},{"path":"/reference/step_sec_conventional_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"","code":"step_sec_conventional_cal(   recipe,   measures = NULL,   standards = NULL,   fit_type = c(\"cubic\", \"quadratic\", \"linear\", \"fifth\"),   extrapolation = c(\"warn\", \"none\", \"linear\"),   output_col = \"mw\",   log_output = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_conventional_cal\") )"},{"path":"/reference/step_sec_conventional_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"recipe recipe object. measures Character vector measure columns apply calibration . NULL, uses measure columns. standards data frame containing calibration standards columns: location (time, volume, retention): Elution position log_mw (mw): Molecular weight (log-transformed mw) fit_type Type polynomial fit calibration curve: \"cubic\" (default): Third-order polynomial \"quadratic\": Second-order polynomial \"linear\": First-order (linear) fit \"fifth\": Fifth-order polynomial extrapolation handle data outside calibration range: \"warn\" (default): Extrapolate warn \"none\": Return NA --range values \"linear\": Use linear extrapolation boundaries output_col Name output molecular weight column. Default \"mw\". log_output Logical. TRUE (default), output column contains log10(MW). FALSE, output contains MW Daltons. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_conventional_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_conventional_cal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"step performs conventional (also called relative) SEC calibration using narrow dispersity standards known molecular weight. calibration curve relates elution position log(MW): $$\\log_{10}(M) = f(V_e)$$ f polynomial function V_e elution volume time. Calibration Curve Fitting: calibration fit using orthogonal polynomials numerical stability. least 3 standards required cubic fits, 4 quadratic, etc. Important Considerations: Standards bracket MW range interest Calibration polymer-specific (different polymers different hydrodynamic volumes MW) cross-polymer comparisons, use universal calibration instead (step_sec_universal_cal) Fit Quality Metrics: tidy() method returns calibration coefficients R-squared values assessing fit quality. R² > 0.999 typical good calibrations.","code":""},{"path":[]},{"path":"/reference/step_sec_conventional_cal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Create calibration standards data ps_standards <- data.frame(   retention = c(12.5, 13.2, 14.1, 15.0, 16.2, 17.5),   log_mw = c(6.0, 5.5, 5.0, 4.5, 4.0, 3.5) )  # Apply conventional calibration rec <- recipe(~., data = polymer_data) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_conventional_cal(     standards = ps_standards,     fit_type = \"cubic\"   ) |>   prep()  # Check calibration quality tidy(rec, number = 3) } # }"},{"path":"/reference/step_sec_dad.html","id":null,"dir":"Reference","previous_headings":"","what":"Diode Array Detector Processing for SEC — step_sec_dad","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"step_sec_dad() creates specification recipe step processes diode array detector (DAD) signals across multiple wavelengths. can apply wavelength-specific extinction coefficients optionally compute ratios reference wavelength.","code":""},{"path":"/reference/step_sec_dad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"","code":"step_sec_dad(   recipe,   measures = NULL,   wavelengths = c(254, 280, 220),   extinction_coefs = NULL,   reference_wavelength = NULL,   output_prefix = \"uv\",   path_length = 1,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_dad\") )"},{"path":"/reference/step_sec_dad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"recipe recipe object. measures Character vector DAD/UV measure columns. NULL, step searches measure columns containing \"dad\" \"uv\". wavelengths Numeric vector wavelengths (nm) aligned measures. NULL, attempts parse wavelengths measures names. extinction_coefs Extinction coefficients wavelength. Accepts named numeric vector (names wavelengths), unnamed vector aligned wavelengths, data frame columns wavelength extinction_coef. reference_wavelength Optional wavelength used denominator ratio calculations. output_prefix Prefix used name output columns (e.g., uv_254). path_length Path length flow cell cm. Default 1.0. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_dad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_dad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"wavelength, signal can normalized using Beer-Lambert law: $$= \\varepsilon \\times c \\times l$$ absorbance (AU), epsilon extinction coefficient, l path length. reference_wavelength provided, step additionally creates ratio columns wavelength vs reference.","code":""},{"path":[]},{"path":"/reference/step_sec_dad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_254, location = vars(elution_time), col_name = \"uv_254\") |>   step_measure_input_long(uv_280, location = vars(elution_time), col_name = \"uv_280\") |>   step_sec_dad(     measures = c(\"uv_254\", \"uv_280\"),     wavelengths = c(254, 280),     extinction_coefs = c(`254` = 1.2, `280` = 1.0),     reference_wavelength = 280   ) |>   prep() } # }"},{"path":"/reference/step_sec_detector_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"step_sec_detector_delay() creates specification recipe step corrects volume delays detectors multi-detector SEC systems.","code":""},{"path":"/reference/step_sec_detector_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"","code":"step_sec_detector_delay(   recipe,   reference = NULL,   targets = NULL,   delay_volumes = NULL,   delay_times = NULL,   flow_rate = 1,   method = c(\"shift\", \"interpolate\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_detector_delay\") )"},{"path":"/reference/step_sec_detector_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"recipe recipe object. reference Character name reference detector column (typically RI). detectors aligned reference. targets Character vector detector column names shift. NULL, measure columns except reference shifted. delay_volumes Named numeric vector delay volumes mL. Names match target column names. Positive values indicate detector sees sample reference. delay_times Named numeric vector delay times minutes. Alternative delay_volumes. Requires flow_rate specified. flow_rate Flow rate mL/min. Required using delay_times. method Method shifting signals: \"shift\" (default): Simple index shift (fastest, slight edge effects) \"interpolate\": Linear interpolation (smoother, preserves signal shape) role used step. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_detector_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_detector_delay.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"multi-detector SEC systems, detectors connected series separated tubing. causes detector see analyte different times. accurate molecular weight calculations combine signals multiple detectors (e.g., RI + MALS absolute MW), delays must corrected. Typical detector order delays: UV detector: Often first, minimal delay RI detector: Common reference detector MALS detector: Often 0.1-0.3 mL delay RI Viscometer: May 0.2-0.5 mL delay Determining delay volumes: Inject narrow standard record detector signals Measure time offset peak maxima Convert volume: delay_volume = time_offset × flow_rate","code":""},{"path":[]},{"path":"/reference/step_sec_detector_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Correct UV and MALS signals relative to RI rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.15)   ) |>   prep() } # }"},{"path":"/reference/step_sec_dls.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic Light Scattering Processing for SEC — step_sec_dls","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"step_sec_dls() creates specification recipe step processes dynamic light scattering (DLS) correlation data estimate diffusion coefficient hydrodynamic radius (Rh).","code":""},{"path":"/reference/step_sec_dls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"","code":"step_sec_dls(   recipe,   measures = NULL,   temperature = 25,   viscosity = NULL,   laser_wavelength = 633,   angle = 90,   solvent_ri = 1.333,   rg_col = \"rg\",   output_cols = c(\"rh\", \"diffusion_coef\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_dls\") )"},{"path":"/reference/step_sec_dls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"recipe recipe object. measures Character vector DLS measure columns. NULL, step searches measure columns containing \"dls\" \"corr\". temperature Temperature degrees Celsius. viscosity Solvent viscosity mPa*s. NULL, uses water approximation based temperature. laser_wavelength Laser wavelength nm. Default 633. angle Scattering angle degrees. Default 90. solvent_ri Solvent refractive index. Default 1.333 (water). rg_col Optional Rg measure column MALS Rg/Rh ratio. output_cols Output column names Rh diffusion coefficient. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_dls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_dls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"DLS correlation function g2(tau) approximated : $$g2(\\tau) = 1 + \\beta e^{-2 \\Gamma \\tau}$$ Gamma decay rate. diffusion coefficient calculated D = Gamma / q^2 q determined scattering angle wavelength. Rh obtained Stokes-Einstein equation.","code":""},{"path":[]},{"path":"/reference/step_sec_dls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(dls_corr, location = vars(lag_time), col_name = \"dls\") |>   step_sec_dls(measures = \"dls\", temperature = 25, viscosity = 0.89) |>   prep() } # }"},{"path":"/reference/step_sec_intrinsic_visc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"step_sec_intrinsic_visc() creates specification recipe step calculates intrinsic viscosity ([eta]) specific viscosity concentration elution point.","code":""},{"path":"/reference/step_sec_intrinsic_visc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"","code":"step_sec_intrinsic_visc(   recipe,   specific_visc_col = NULL,   concentration_col = NULL,   output_col = \"intrinsic_visc\",   min_concentration = 1e-06,   units = c(\"dL/g\", \"mL/g\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_intrinsic_visc\") )"},{"path":"/reference/step_sec_intrinsic_visc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"recipe recipe object. specific_visc_col Name specific viscosity measure column (step_sec_viscometer()). concentration_col Name concentration measure column. output_col Name intrinsic viscosity output column. Default \"intrinsic_visc\". min_concentration Minimum concentration threshold intrinsic viscosity set NA. Default 1e-6 mg/mL. units Output units intrinsic viscosity. Default \"dL/g\". Common alternatives \"mL/g\" (multiply 100). role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_intrinsic_visc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"updated recipe new step added, containing intrinsic viscosity elution point.","code":""},{"path":"/reference/step_sec_intrinsic_visc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"Intrinsic viscosity defined limit reduced viscosity infinite dilution: $$[\\eta] = \\lim_{c \\0} \\frac{\\eta_{sp}}{c}$$ SEC, elution slice low concentration, approximation [eta] = eta_sp / c valid. Applications Intrinsic Viscosity: Universal Calibration: log([eta] * M) linear retention volume, allowing calibration transfer polymer types Mark-Houwink Equation: [eta] = K * M^, K polymer- solvent-specific constants Branching Analysis: g' = [eta]_branched / [eta]_linear provides information long-chain branching Polymer Conformation: scaling exponent [eta] vs M reveals chain conformation (coil, rod, sphere) Typical Intrinsic Viscosity Values (dL/g): Polystyrene THF (MW 100k): ~0.5 PEG water (MW 10k): ~0.2 Proteins: 0.03-0.05 (globular), 0.2-1.0 (denatured)","code":""},{"path":[]},{"path":"/reference/step_sec_intrinsic_visc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate intrinsic viscosity rec <- recipe(~., data = sec_visc_data) |>   step_measure_input_long(dp_signal, location = vars(elution_time), col_name = \"dp\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_viscometer(dp_col = \"dp\") |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_intrinsic_visc(     specific_visc_col = \"specific_visc\",     concentration_col = \"ri\"   ) |>   prep() } # }"},{"path":"/reference/step_sec_lals.html","id":null,"dir":"Reference","previous_headings":"","what":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"step_sec_lals() creates specification recipe step processes low-angle light scattering (LALS) signals absolute molecular weight.","code":""},{"path":"/reference/step_sec_lals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"","code":"step_sec_lals(   recipe,   measures = NULL,   concentration_col = NULL,   angle = 7,   laser_wavelength = 670,   dn_dc = NULL,   solvent_ri = 1.333,   optical_constant = NULL,   calibration_constant = NULL,   output_mw = \"mw_lals\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_lals\") )"},{"path":"/reference/step_sec_lals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"recipe recipe object. measures Character vector LALS measure columns. NULL, step searches measure columns containing \"lals\". concentration_col Name concentration measure column (step_sec_concentration() similar). angle Detection angle degrees (must < 20 LALS). laser_wavelength Laser wavelength nm. dn_dc Refractive index increment (mL/g). Required unless optical_constant provided. solvent_ri Solvent refractive index. Default 1.333 (water). optical_constant Optional optical constant K; overrides dn/dc. calibration_constant LALS instrument calibration constant. NULL, results relative units. output_mw Name molecular weight output column. min_signal Minimum signal threshold (fraction max) MW set NA. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_lals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_lals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"LALS provides absolute MW using low-angle detector (e.g., ~7 degrees). assumes P(theta) ~ 1 small particles accurate angular dependence minimal. use LALS vs MALS: LALS: Preferred smaller molecules (Rg < ~10 nm) multi-angle data available. Single-angle measurement faster simpler determine Rg. MALS: Required large molecules angular dependence significant. Provides Mw Rg extrapolation zero angle.","code":""},{"path":[]},{"path":"/reference/step_sec_lals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(lals_signal, location = vars(elution_time), col_name = \"lals\") |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_lals(measures = \"lals\", concentration_col = \"ri\", dn_dc = 0.185) |>   prep() } # }"},{"path":"/reference/step_sec_mals.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"step_sec_mals() creates specification recipe step processes multi-angle light scattering (MALS) detector signals determine absolute molecular weight radius gyration elution slice.","code":""},{"path":"/reference/step_sec_mals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"","code":"step_sec_mals(   recipe,   mals_col = NULL,   concentration_col = NULL,   dn_dc = NULL,   dn_dc_column = NULL,   wavelength = 658,   solvent_ri = 1.333,   angles = 90,   formalism = c(\"zimm\", \"debye\", \"berry\"),   calibration_constant = NULL,   output_mw = \"mw_mals\",   output_rg = \"rg\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mals\") )"},{"path":"/reference/step_sec_mals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"recipe recipe object. mals_col Name MALS detector measure column. single-angle detectors (RALS/LALS), signal needed. concentration_col Name concentration measure column (step_sec_concentration() similar). dn_dc Refractive index increment (mL/g). Required absolute MW. dn_dc_column Column containing sample-specific dn/dc values. wavelength Laser wavelength nm. Default 658 (common MALS). solvent_ri Solvent refractive index. Default 1.333 (water). Common values: water = 1.333, THF = 1.407, toluene = 1.497. angles Numeric vector detection angles degrees. single-angle detectors, provide just one value (e.g., 90 RALS). Default assumes 90-degree detector. formalism Angular extrapolation method multi-angle data: \"zimm\" (default), \"debye\", \"berry\". calibration_constant MALS instrument calibration constant. NULL, results relative units. Obtain toluene standard calibration. output_mw Name molecular weight output column. Default \"mw_mals\". output_rg Name radius gyration output column. Default \"rg\". calculated multiple angles provided. min_signal Minimum signal threshold (fraction max) MW set NA. Default 0.01. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_mals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"updated recipe new step added, containing absolute MW (optionally Rg) elution point.","code":""},{"path":"/reference/step_sec_mals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"Light scattering provides absolute molecular weight without calibration standards. fundamental relationship : $$\\frac{K \\cdot c}{R(\\theta)} = \\frac{1}{M_w} \\cdot P(\\theta) + 2A_2 c$$ : K optical constant c concentration R(theta) excess Rayleigh ratio Mw weight-average molecular weight P(theta) particle scattering function A2 second virial coefficient optical constant K calculated : $$K = \\frac{4\\pi^2 n_0^2 (dn/dc)^2}{N_A \\lambda^4}$$ Formalisms Angular Extrapolation: Zimm: Kc/R vs sin^2(theta/2) - best random coils Debye: Kc/R vs sin^2(theta/2) - similar Zimm Berry: sqrt(Kc/R) vs sin^2(theta/2) - better large particles Single-Angle vs Multi-Angle: Single angle (RALS/LALS): Provides Mw , assumes P(theta) ~ 1 Multi-angle (MALS): Provides Mw Rg angular dependence","code":""},{"path":"/reference/step_sec_mals.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"Accurate results require: Known accurate dn/dc value Calibrated instrument (calibration_constant toluene) Accurate concentration RI detector Clean baseline aligned detectors","code":""},{"path":[]},{"path":"/reference/step_sec_mals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Single-angle (90 degree) light scattering rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   step_sec_baseline() |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_mals(     mals_col = \"mals\",     concentration_col = \"ri\",     dn_dc = 0.185,     wavelength = 658,     angles = 90   ) |>   prep() } # }"},{"path":"/reference/step_sec_mw_averages.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"step_sec_mw_averages() creates specification recipe step calculates molecular weight averages size exclusion chromatography data.","code":""},{"path":"/reference/step_sec_mw_averages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"","code":"step_sec_mw_averages(   recipe,   measures = NULL,   calibration = NULL,   integration_range = NULL,   output_cols = c(\"mn\", \"mw\", \"mz\", \"mp\", \"dispersity\"),   prefix = \"mw_\",   role = \"predictor\",   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_averages\") )"},{"path":"/reference/step_sec_mw_averages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"recipe recipe object. measures optional character vector measure column names. calibration Calibration method converting x-axis log(MW). Can : NULL (default): Assumes x-axis already log10(MW) numeric vector length 2: Linear calibration c(slope, intercept) log10(MW) = slope * x + intercept \"auto\": Estimate data range (assumes typical polymer range) integration_range Optional numeric vector c(min, max) specifying x-axis range integration. NULL, uses full range. output_cols Character vector metrics calculate. Default includes : c(\"mn\", \"mw\", \"mz\", \"mp\", \"dispersity\"). prefix Prefix output column names. Default \"mw_\". role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_mw_averages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_mw_averages.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"step calculates standard molecular weight averages SEC/GPC data: detector signal assumed proportional weight concentration. RI detection, typically valid. UV detection, response factors may need applied first. Prerequisites: Data baseline corrected X-axis represent retention time/volume log(MW) Integration limits exclude solvent peaks","code":""},{"path":[]},{"path":"/reference/step_sec_mw_averages.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Assuming x-axis is already calibrated to log10(MW) rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_averages() |>   prep() } # }"},{"path":"/reference/step_sec_mw_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"step_sec_mw_distribution() creates specification recipe step generates molecular weight distribution curves SEC/GPC data.","code":""},{"path":"/reference/step_sec_mw_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"","code":"step_sec_mw_distribution(   recipe,   measures = NULL,   type = c(\"differential\", \"cumulative\", \"both\"),   calibration = NULL,   n_points = 100L,   mw_range = NULL,   normalize = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_distribution\") )"},{"path":"/reference/step_sec_mw_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"recipe recipe object. measures optional character vector measure column names. type Type distribution generate: \"differential\" (default): dW/d(log M) differential distribution \"cumulative\": Cumulative weight fraction distribution \"\": Generate distributions calibration Calibration method converting x-axis log(MW). See step_sec_mw_averages() details. n_points Number points output distribution. Default 100. NULL, uses original data resolution. mw_range Optional numeric vector c(min, max) specifying MW range output distribution. NULL, uses range data. normalize Logical. differential distribution normalized integrate 1? Default TRUE. role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_mw_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_mw_distribution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"step transforms raw chromatogram standard MW distribution representations: Differential Distribution (dW/d(log M)): weight fraction per unit log(MW). representation preferred area curve represents weight fraction MW range. Cumulative Distribution: cumulative weight fraction low high MW. Values range 0 1. output replaces .measures column distribution data, location contains log10(MW) values value contains distribution values.","code":""},{"path":[]},{"path":"/reference/step_sec_mw_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Generate differential MW distribution rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_distribution(type = \"differential\") |>   prep() } # }"},{"path":"/reference/step_sec_mw_fractions.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"step_sec_mw_fractions() creates specification recipe step calculates weight fractions specified molecular weight cutoffs.","code":""},{"path":"/reference/step_sec_mw_fractions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"","code":"step_sec_mw_fractions(   recipe,   measures = NULL,   cutoffs = c(1000, 10000, 1e+05),   calibration = NULL,   integration_range = NULL,   prefix = \"frac_\",   role = \"predictor\",   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_fractions\") )"},{"path":"/reference/step_sec_mw_fractions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"recipe recipe object. measures optional character vector measure column names. cutoffs Numeric vector MW cutoff values. cutoff, step calculates weight fraction value. calibration Calibration method converting x-axis log(MW). See step_sec_mw_averages() details. integration_range Optional numeric vector c(min, max) specifying x-axis range integration. NULL, uses full range. prefix Prefix output column names. Default \"frac_\". role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_mw_fractions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_mw_fractions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"cutoff value C, step calculates: frac_below_C: Weight fraction MW < C frac_above_C: Weight fraction MW >= C fractions sum 1.0 useful characterizing polymer distributions. Common cutoffs include: 1000 Da oligomer content 10000 Da low MW fraction 100000 Da high MW fraction","code":""},{"path":[]},{"path":"/reference/step_sec_mw_fractions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate fractions at multiple cutoffs rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_fractions(cutoffs = c(1000, 10000, 100000)) |>   prep() } # }"},{"path":"/reference/step_sec_oligomer.html","id":null,"dir":"Reference","previous_headings":"","what":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"step_sec_oligomer() creates specification recipe step identifies quantifies individual oligomeric species (monomer, dimer, trimer, etc.) protein SEC chromatograms.","code":""},{"path":"/reference/step_sec_oligomer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"","code":"step_sec_oligomer(   recipe,   measures = NULL,   monomer_mw = NULL,   peak_detection = c(\"auto\", \"manual\"),   peaks = NULL,   species = c(\"monomer\", \"dimer\", \"trimer\", \"hmw\", \"lmw\"),   mw_tolerance = 0.15,   mw_column = NULL,   min_area_pct = 0.1,   output_prefix = \"oligo_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_oligomer\") )"},{"path":"/reference/step_sec_oligomer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. monomer_mw Expected monomer molecular weight Da. Required species assignment. Typical range: 10,000 - 1,000,000 Da proteins. peak_detection Method peak detection: \"auto\" (default): Automatic peak detection using derivative analysis \"manual\": Use peaks specified peaks argument peaks manual mode, list data frame peak definitions. peak start end retention times. species Character vector species identify. Default includes \"monomer\", \"dimer\", \"trimer\", \"hmw\", \"lmw\". mw_tolerance Tolerance MW-based species assignment fraction. Default 0.15 (15%). peak assigned \"dimer\" MW within 15% 2x monomer MW. mw_column Optional name molecular weight measure column (MALS LALS). provided, uses MW species assignment; otherwise uses retention time patterns. min_area_pct Minimum peak area percentage report. Peaks threshold grouped \"\". Default 0.1 (0.1%). output_prefix Prefix output columns. Default \"oligo_\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_oligomer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"updated recipe new columns: oligo_monomer_pct Percent monomer oligo_dimer_pct Percent dimer oligo_trimer_pct Percent trimer oligo_hmw_pct Percent high molecular weight (> trimer) oligo_lmw_pct Percent low molecular weight (fragments) oligo_species_count Number detected species oligo_monomer_mw Observed monomer MW (mw_column provided) oligo_dimer_mw Observed dimer MW (mw_column provided)","code":""},{"path":"/reference/step_sec_oligomer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"step extends step_sec_aggregates() providing detailed species identification rather just HMWS/monomer/LMWS classification. Species Assignment: Monomer: MW within mw_tolerance monomer_mw Dimer: MW within mw_tolerance 2x monomer_mw Trimer: MW within mw_tolerance 3x monomer_mw HMW: MW > 3x monomer_mw LMW: MW < monomer_mw (fragments, clips) Peak Detection: using \"auto\" detection, peaks identified using: Signal derivative analysis Local maxima identification Valley detection peak boundaries Without MW Data: MW column available, species assigned based retention time: Largest peak assumed monomer Earlier-eluting peaks HMW/oligomers Later-eluting peaks LMW/fragments","code":""},{"path":"/reference/step_sec_oligomer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"best results: Provide monomer_mw accurate species assignment Use MALS/LALS data MW-based assignment Ensure good chromatographic resolution species","code":""},{"path":[]},{"path":"/reference/step_sec_oligomer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Analyze IgG oligomers (monomer MW ~150 kDa) rec <- recipe(~., data = igg_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_oligomer(monomer_mw = 150000) |>   prep()  # With MALS-derived MW for accurate assignment rec <- recipe(~., data = igg_mals_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_mals() |>   step_sec_oligomer(monomer_mw = 150000, mw_column = \"mw_mals\") |>   prep() } # }"},{"path":"/reference/step_sec_protein.html","id":null,"dir":"Reference","previous_headings":"","what":"Protein SEC Analysis Workflow — step_sec_protein","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"step_sec_protein() creates specification recipe step provides streamlined workflow protein SEC analysis, combining baseline correction, aggregate quantitation, optionally oligomer analysis single step.","code":""},{"path":"/reference/step_sec_protein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"","code":"step_sec_protein(   recipe,   measures = NULL,   type = c(\"native\", \"denaturing\"),   monomer_mw = NULL,   monomer_start = NULL,   monomer_end = NULL,   extinction_coef = NULL,   aggregate_threshold = 0.001,   baseline_method = c(\"linear\", \"median\", \"spline\"),   baseline_left_frac = 0.05,   baseline_right_frac = 0.05,   include_oligomer = NULL,   output_prefix = \"protein_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_protein\") )"},{"path":"/reference/step_sec_protein.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. type Analysis type: \"native\" (default): Native conditions (aqueous buffer, non-denaturing) \"denaturing\": Denaturing conditions (e.g., SDS guanidine) monomer_mw Expected monomer molecular weight Da. Required oligomer analysis include_oligomer = TRUE. monomer_start Start monomer peak region (location units). NULL, automatically determined. monomer_end End monomer peak region. NULL, automatically determined. extinction_coef Extinction coefficient UV-based concentration. NULL, signal remains raw units. aggregate_threshold Minimum fraction signal report aggregate/fragment. Default 0.001 (0.1%). baseline_method Method baseline correction. One \"linear\" (default), \"median\", \"spline\". baseline_left_frac Fraction chromatogram start baseline. Default 0.05. baseline_right_frac Fraction chromatogram end baseline. Default 0.05. include_oligomer Logical. Include detailed oligomer analysis? Default TRUE monomer_mw provided. output_prefix Prefix output columns. Default \"protein_\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_protein.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"updated recipe new columns: protein_hmws_pct Percent high molecular weight species protein_monomer_pct Percent monomer protein_lmws_pct Percent low molecular weight species protein_main_start Start main peak region protein_main_end End main peak region include_oligomer = TRUE monomer_mw provided: protein_monomer_oligo_pct Percent monomer (oligomer analysis) protein_dimer_pct Percent dimer protein_trimer_pct Percent trimer protein_hmw_oligo_pct Percent HMW oligomers protein_lmw_oligo_pct Percent fragments protein_species_count Number detected species","code":""},{"path":"/reference/step_sec_protein.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"step provides convenient \"one-stop\" workflow protein SEC analysis, suitable biopharmaceutical characterization. combines: Baseline correction: SEC-optimized linear median baseline Aggregate quantitation: HMWS/monomer/LMWS percentages Oligomer analysis (optional): Detailed species identification Native vs Denaturing: Native: Preserves quaternary structure; use oligomer analysis Denaturing: Disrupts non-covalent interactions; use covalent aggregate detection Regulatory Context: Aggregate analysis critical biopharmaceutical characterization: ICH Q6B requires aggregate content specification USP <129> provides guidance aggregate testing Typical specifications: HMWS < 5%, Monomer > 95% Control: advanced analysis custom workflows, use individual steps: step_sec_baseline() baseline correction step_sec_uv() UV signal processing step_sec_aggregates() HMWS/monomer/LMWS step_sec_oligomer() detailed species analysis","code":""},{"path":[]},{"path":"/reference/step_sec_protein.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Basic protein SEC workflow rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(monomer_mw = 150000) |>   prep()  # Native mAb analysis with oligomer detection rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(     type = \"native\",     monomer_mw = 150000,     extinction_coef = 1.4,     include_oligomer = TRUE   ) |>   prep()  # Denaturing conditions (SDS-SEC) rec <- recipe(~., data = sds_sec_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(type = \"denaturing\", monomer_mw = 150000) |>   prep() } # }"},{"path":"/reference/step_sec_rals.html","id":null,"dir":"Reference","previous_headings":"","what":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"step_sec_rals() creates specification recipe step processes right-angle light scattering (RALS) signals absolute molecular weight.","code":""},{"path":"/reference/step_sec_rals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"","code":"step_sec_rals(   recipe,   measures = NULL,   concentration_col = NULL,   angle = 90,   laser_wavelength = 670,   dn_dc = NULL,   solvent_ri = 1.333,   optical_constant = NULL,   calibration_constant = NULL,   output_mw = \"mw_rals\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_rals\") )"},{"path":"/reference/step_sec_rals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"recipe recipe object. measures Character vector RALS measure columns. NULL, step searches measure columns containing \"rals\". concentration_col Name concentration measure column (step_sec_concentration() similar). angle Detection angle degrees. Default 90. laser_wavelength Laser wavelength nm. dn_dc Refractive index increment (mL/g). Required unless optical_constant provided. solvent_ri Solvent refractive index. Default 1.333 (water). optical_constant Optional optical constant K; overrides dn/dc. calibration_constant RALS instrument calibration constant. NULL, results relative units. output_mw Name molecular weight output column. min_signal Minimum signal threshold (fraction max) MW set NA. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_rals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_rals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"RALS provides absolute MW using 90-degree detector. accurate smaller molecules angular dependence minimal (Rg << lambda/20).","code":""},{"path":[]},{"path":"/reference/step_sec_rals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(rals_signal, location = vars(elution_time), col_name = \"rals\") |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_rals(measures = \"rals\", concentration_col = \"ri\", dn_dc = 0.185) |>   prep() } # }"},{"path":"/reference/step_sec_ri.html","id":null,"dir":"Reference","previous_headings":"","what":"RI Detector Processing for SEC — step_sec_ri","title":"RI Detector Processing for SEC — step_sec_ri","text":"step_sec_ri() creates specification recipe step processes refractive index (RI) detector signals SEC analysis, including application dn/dc (refractive index increment) values.","code":""},{"path":"/reference/step_sec_ri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RI Detector Processing for SEC — step_sec_ri","text":"","code":"step_sec_ri(   recipe,   measures = NULL,   dn_dc = NULL,   dn_dc_column = NULL,   instrument_constant = 1,   output_col = NULL,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_ri\") )"},{"path":"/reference/step_sec_ri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RI Detector Processing for SEC — step_sec_ri","text":"recipe recipe object. measures Character vector RI detector column names process. NULL, look columns containing \"ri\" name. dn_dc Refractive index increment (mL/g). Can : single numeric value applied samples NULL skip dn/dc normalization (signal remains detector units) dn_dc_column Character name column containing sample-specific dn/dc values. Overrides dn_dc provided. instrument_constant RI detector instrument constant. Default 1.0 (adjustment). converts raw detector response refractive index units. output_col Name output column. Default modify place. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_ri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RI Detector Processing for SEC — step_sec_ri","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_ri.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RI Detector Processing for SEC — step_sec_ri","text":"refractive index (RI) detector common concentration detector SEC/GPC. detector response proportional product concentration dn/dc: $$RI_{signal} = K \\times c \\times (dn/dc)$$ : K instrument constant c concentration (mg/mL) dn/dc refractive index increment (mL/g) Common dn/dc values (water 25°C, 633 nm): Polystyrene THF: 0.185 mL/g PMMA THF: 0.084 mL/g PEG water: 0.135 mL/g Proteins: ~0.185 mL/g DNA: ~0.170 mL/g","code":""},{"path":[]},{"path":"/reference/step_sec_ri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RI Detector Processing for SEC — step_sec_ri","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply fixed dn/dc value rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_ri(dn_dc = 0.185) |>   prep()  # Use sample-specific dn/dc from a column rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_ri(dn_dc_column = \"dn_dc\") |>   prep() } # }"},{"path":"/reference/step_sec_universal_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Universal Calibration for SEC — step_sec_universal_cal","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"step_sec_universal_cal() creates specification recipe step applies universal calibration determine molecular weight intrinsic viscosity retention data.","code":""},{"path":"/reference/step_sec_universal_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"","code":"step_sec_universal_cal(   recipe,   measures = NULL,   calibration = NULL,   calibration_col = NULL,   intrinsic_visc_col = NULL,   K_sample,   a_sample,   K_standard = 0.000114,   a_standard = 0.716,   output_col = \"mw_universal\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_universal_cal\") )"},{"path":"/reference/step_sec_universal_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"recipe recipe object. measures Character vector measure columns apply calibration . NULL, uses measure columns. calibration calibration object data frame containing universal calibration curve (log([eta]M) vs retention). calibration_col calibration column name data, specify . intrinsic_visc_col Column containing intrinsic viscosity values. Required converting polymer types. K_sample Mark-Houwink K parameter sample polymer. a_sample Mark-Houwink (alpha) exponent sample polymer. K_standard Mark-Houwink K calibration standard polymer. Default 0.000114 (polystyrene THF). a_standard Mark-Houwink calibration standard. Default 0.716 (polystyrene THF). output_col Name output molecular weight column. Default \"mw_universal\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_universal_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"updated recipe molecular weight calculated via universal calibration.","code":""},{"path":"/reference/step_sec_universal_cal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"Universal calibration based principle polymers hydrodynamic volume elute retention time, regardless chemical structure. hydrodynamic volume proportional [eta]M: $$V_h \\propto [\\eta] \\cdot M$$ Universal Calibration Curve: $$\\log([\\eta] \\cdot M)_{sample} = \\log([\\eta] \\cdot M)_{standard}$$ retention volume, using Mark-Houwink equations: $$[\\eta] = K \\cdot M^$$ can solve sample MW: $$M_{sample} = \\left(\\frac{K_{std} \\cdot M_{std}^{1+a_{std}}}{K_{sample}}\\right)^{\\frac{1}{1+a_{sample}}}$$ Mark-Houwink Parameters (THF, 25C): Polystyrene: K = 0.000114, = 0.716 PMMA: K = 0.000128, = 0.690 Polyisoprene: K = 0.000251, = 0.728 Polybutadiene: K = 0.000457, = 0.693","code":""},{"path":"/reference/step_sec_universal_cal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"Universal calibration requires: Known Mark-Houwink parameters standard sample Calibration narrow standards (typically polystyrene) solvent temperature measurements absolute MW determination, consider using MALS detection instead.","code":""},{"path":[]},{"path":"/reference/step_sec_universal_cal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply universal calibration to convert PS calibration to PMMA rec <- recipe(~., data = pmma_data) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_universal_cal(     calibration = ps_calibration,     K_sample = 0.000128,      # PMMA     a_sample = 0.690,     K_standard = 0.000114,    # PS (default)     a_standard = 0.716   ) |>   prep() } # }"},{"path":"/reference/step_sec_uv.html","id":null,"dir":"Reference","previous_headings":"","what":"UV Detector Processing for SEC — step_sec_uv","title":"UV Detector Processing for SEC — step_sec_uv","text":"step_sec_uv() creates specification recipe step processes UV detector signals SEC analysis, including application extinction coefficients concentration determination.","code":""},{"path":"/reference/step_sec_uv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UV Detector Processing for SEC — step_sec_uv","text":"","code":"step_sec_uv(   recipe,   measures = NULL,   extinction_coef = NULL,   extinction_column = NULL,   wavelength = 280,   path_length = 1,   output_col = NULL,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_uv\") )"},{"path":"/reference/step_sec_uv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UV Detector Processing for SEC — step_sec_uv","text":"recipe recipe object. measures Character vector UV detector column names process. NULL, look columns containing \"uv\" name. extinction_coef Extinction coefficient mL/(mgcm) L/(gcm). Can : single numeric value applied samples NULL skip normalization (signal remains AU) extinction_column Character name column containing sample-specific extinction coefficients. Overrides extinction_coef provided. wavelength UV detection wavelength nm. documentation . path_length Path length flow cell cm. Default 1.0. output_col Name output column. Default modify place. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_uv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"UV Detector Processing for SEC — step_sec_uv","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_uv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"UV Detector Processing for SEC — step_sec_uv","text":"UV detector measures absorbance according Beer-Lambert law: $$= \\varepsilon \\times c \\times l$$ : absorbance (AU) epsilon molar extinction coefficient mL/(mg*cm) c concentration (mg/mL) l path length (cm) step can convert UV absorbance concentration-proportional signals dividing extinction coefficient path length. Common UV applications SEC: Proteins 280 nm (aromatic amino acids) Nucleic acids 260 nm Conjugated polymers UV-active end groups labels UV vs RI concentration: UV sensitive chromophore-containing analytes UV response depends chemical composition (may vary MW) RI universal less sensitive accurate MW, combine detectors","code":""},{"path":[]},{"path":"/reference/step_sec_uv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"UV Detector Processing for SEC — step_sec_uv","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply fixed extinction coefficient rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_uv(extinction_coef = 1.0, wavelength = 280) |>   prep()  # Use sample-specific extinction coefficients rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_uv(extinction_column = \"ext_coef\") |>   prep() } # }"},{"path":"/reference/step_sec_uv_ri_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"step_sec_uv_ri_ratio() creates specification recipe step calculates ratio UV RI detector signals elution point. ratio useful detecting compositional heterogeneity copolymers conjugates.","code":""},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"","code":"step_sec_uv_ri_ratio(   recipe,   uv_col = NULL,   ri_col = NULL,   output_col = \"uv_ri_ratio\",   min_signal = 0.01,   smooth = TRUE,   smooth_window = 5,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_uv_ri_ratio\") )"},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"recipe recipe object. uv_col Name UV detector measure column. ri_col Name RI detector measure column. output_col Name output ratio column. Default \"uv_ri_ratio\". min_signal Minimum signal threshold (fraction max) ratio set NA. Default 0.01 (1%). Prevents noisy ratios baseline. smooth Logical. Apply smoothing ratio? Default TRUE. smooth_window Window size smoothing (number points). Default 5. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"updated recipe new step added.","code":""},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"UV/RI ratio provides information chemical composition across molecular weight distribution: $$Ratio(t) = \\frac{UV(t)}{RI(t)} = \\frac{\\varepsilon \\cdot c(t)}{(dn/dc) \\cdot c(t) \\cdot K}$$ Since concentration cancels , ratio reflects relative detector response factors, depend chemical composition. Applications: Copolymer composition drift molecular weight Block copolymer characterization PEGylation analysis (protein-PEG conjugates) Detection chemical heterogeneity End-group analysis UV labels Interpretation: Constant ratio: Uniform composition across MW Increasing ratio MW: chromophore higher MW species Decreasing ratio MW: Less chromophore higher MW species","code":""},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"UV RI signals baseline-corrected properly aligned (using step_sec_detector_delay()) calculating ratio.","code":""},{"path":[]},{"path":"/reference/step_sec_uv_ri_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate UV/RI ratio for copolymer rec <- recipe(~., data = sec_copolymer) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_detector_delay(reference = \"ri\", delay_volumes = c(uv = 0.05)) |>   step_sec_baseline() |>   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\") |>   prep() } # }"},{"path":"/reference/step_sec_viscometer.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential Viscometer Processing for SEC — step_sec_viscometer","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"step_sec_viscometer() creates specification recipe step processes differential viscometer signals calculate specific viscosity elution point.","code":""},{"path":"/reference/step_sec_viscometer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"","code":"step_sec_viscometer(   recipe,   dp_col = NULL,   ip_col = NULL,   output_col = \"specific_visc\",   viscometer_constant = 1,   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_viscometer\") )"},{"path":"/reference/step_sec_viscometer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"recipe recipe object. dp_col Name differential pressure (DP) measure column. ip_col Name inlet pressure (IP) measure column. NULL, assumes single-capillary viscometer DP directly proportional specific viscosity. output_col Name specific viscosity output column. Default \"specific_visc\". viscometer_constant Instrument calibration constant. Default 1.0. Obtain viscosity standard calibration. min_signal Minimum signal threshold (fraction max) viscosity set NA. Default 0.01. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"/reference/step_sec_viscometer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"updated recipe new step added, containing specific viscosity elution point.","code":""},{"path":"/reference/step_sec_viscometer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"Differential viscometers measure pressure difference sample reference capillary determine solution viscosity. specific viscosity calculated differential pressure (DP) inlet pressure (IP): $$\\eta_{sp} = \\frac{4 \\cdot DP}{IP - 2 \\cdot DP}$$ single-capillary viscometers IP available: $$\\eta_{sp} = K \\cdot DP$$ K calibration constant. Viscometry SEC: Provides specific viscosity MW slice Combined concentration gives intrinsic viscosity [eta] Used universal calibration: log([eta] * M) vs retention Essential branching analysis (g' = [eta]_branched / [eta]_linear)","code":""},{"path":"/reference/step_sec_viscometer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"intrinsic viscosity calculation, use step_sec_intrinsic_visc() step.","code":""},{"path":[]},{"path":"/reference/step_sec_viscometer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process differential viscometer data rec <- recipe(~., data = sec_visc_data) |>   step_measure_input_long(dp_signal, location = vars(elution_time), col_name = \"dp\") |>   step_measure_input_long(ip_signal, location = vars(elution_time), col_name = \"ip\") |>   step_sec_baseline() |>   step_sec_viscometer(dp_col = \"dp\", ip_col = \"ip\") |>   prep() } # }"},{"path":"/reference/tidy.step_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"tidy() method returns tibble information step parameters.","code":""},{"path":"/reference/tidy.step_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"","code":"# S3 method for class 'step_sec_aggregates' tidy(x, ...)  # S3 method for class 'step_sec_band_broadening' tidy(x, ...)  # S3 method for class 'step_sec_baseline' tidy(x, ...)  # S3 method for class 'step_sec_composition' tidy(x, ...)  # S3 method for class 'step_sec_concentration' tidy(x, ...)  # S3 method for class 'step_sec_conventional_cal' tidy(x, ...)  # S3 method for class 'step_sec_dad' tidy(x, ...)  # S3 method for class 'step_sec_detector_delay' tidy(x, ...)  # S3 method for class 'step_sec_dls' tidy(x, ...)  # S3 method for class 'step_sec_intrinsic_visc' tidy(x, ...)  # S3 method for class 'step_sec_lals' tidy(x, ...)  # S3 method for class 'step_sec_mals' tidy(x, ...)  # S3 method for class 'step_sec_mw_averages' tidy(x, ...)  # S3 method for class 'step_sec_mw_distribution' tidy(x, ...)  # S3 method for class 'step_sec_mw_fractions' tidy(x, ...)  # S3 method for class 'step_sec_oligomer' tidy(x, ...)  # S3 method for class 'step_sec_protein' tidy(x, ...)  # S3 method for class 'step_sec_rals' tidy(x, ...)  # S3 method for class 'step_sec_ri' tidy(x, ...)  # S3 method for class 'step_sec_universal_cal' tidy(x, ...)  # S3 method for class 'step_sec_uv' tidy(x, ...)  # S3 method for class 'step_sec_uv_ri_ratio' tidy(x, ...)  # S3 method for class 'step_sec_viscometer' tidy(x, ...)"},{"path":"/reference/tidy.step_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"x recipe step object. ... currently used.","code":""},{"path":"/reference/tidy.step_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"tibble step information.","code":""}]
