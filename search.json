[{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_️-critical-worktree-requirement-for-parallel-agents","dir":"","previous_headings":"","what":"⚠️ CRITICAL: Worktree Requirement for Parallel Agents","title":"CLAUDE.md","text":"Multiple agents MUST use separate git worktrees. Working directory causes file conflicts. matters: Without worktrees, parallel agents modify files, causing: - Uncommitted changes one agent appearing another’s work - Merge conflicts within working directory - Lost mixed work features","code":"# BEFORE starting work, check if you're in a worktree or the main repo git rev-parse --show-toplevel  # If another agent might be working, create your own worktree: git worktree add ../measure.sec-<issue-id> -b feat/<short-description> cd ../measure.sec-<issue-id>"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_️-critical-feature-branch-workflow","dir":"","previous_headings":"","what":"⚠️ CRITICAL: Feature Branch Workflow","title":"CLAUDE.md","text":"NEVER commit directly main. starting implementation work: mandatory even small changes. commits main merge commits PRs.","code":"# 1. ALWAYS create a feature branch FIRST (in a worktree if parallel) git checkout -b feat/<short-description> # or: git checkout -b fix/<short-description>  # 2. Then claim the issue and start work bd update <id> --status=in_progress"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"CLAUDE.md","text":"measure.sec R package extends measure package preprocessing steps specific Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC). provides recipes-style interface SEC/GPC data processing, calibration, molecular weight calculations. “technique pack” registers measure package registry system.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md","text":"","code":"# Generate documentation from roxygen2 comments devtools::document()  # Run all tests devtools::test()  # Run a single test file (filter matches test-*.R files) devtools::test(filter = \"conventional\")  # runs test-step-conventional-cal.R  # Full CRAN-like package check devtools::check()  # Test coverage covr::package_coverage()  # Rebuild README.md from README.Rmd devtools::build_readme()  # Build pkgdown site pkgdown::build_site()"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"recipe-step-pattern","dir":"","previous_headings":"Architecture","what":"Recipe Step Pattern","title":"CLAUDE.md","text":"Every preprocessing step follows recipes framework three required methods: Step implementations R/ naming convention: step_sec_{operation}.R","code":"# Constructor function step_sec_*() → calls recipes::add_step()  # Three S3 methods required: prep.step_sec_*()   # Learn parameters from training data bake.step_sec_*()   # Apply transformation to new data tidy.step_sec_*()   # Return step parameters as tibble"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"internal-data-format","dir":"","previous_headings":"Architecture","what":"Internal Data Format","title":"CLAUDE.md","text":"package uses measure package’s S3 class hierarchy: measure_tbl: Single measurement (tibble location value columns) measure_list: Collection measurements stored list column Key helper functions measure: - find_measure_cols(): Detect measure columns class - check_for_measure(): Validation utilities - new_measure_tbl() / new_measure_list(): Constructors","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"file-organization","dir":"","previous_headings":"Architecture","what":"File Organization","title":"CLAUDE.md","text":"Detector Processing: - step_sec_ri.R: RI detector dn/dc conversion - step_sec_uv.R: UV detector extinction coefficient - step_sec_mals.R: Multi-angle light scattering - step_sec_viscometer.R: Viscometer detector - step_sec_detector_delay.R: Inter-detector delay correction Calibration: - step_sec_conventional_cal.R: Narrow standard calibration (polynomial fits) - step_sec_universal_cal.R: Universal calibration Mark-Houwink parameters Molecular Weight Calculations: - step_sec_mw_averages.R: Mn, Mw, Mz, dispersity - step_sec_mw_fractions.R: MW fraction analysis - step_sec_mw_distribution.R: MW distribution curves Signal Processing: - step_sec_baseline.R: SEC-optimized baseline correction - step_sec_concentration.R: Signal concentration conversion Analysis: - step_sec_aggregates.R: Aggregate/fragment analysis - step_sec_composition.R: Copolymer composition - step_sec_uv_ri_ratio.R: UV/RI ratio composition - step_sec_intrinsic_visc.R: Intrinsic viscosity calculation Supporting Files: - qc-functions.R: QC metrics (plate count, asymmetry, resolution) - polymer-analysis.R: Polymer characterization (branching, M-H parameters) - export-functions.R: Summary table slice table exports - data.R: Dataset documentation","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"CLAUDE.md","text":"Tests use testthat edition 3. Test files mirror source files: - tests/testthat/test-step-*.R: Step-specific tests - tests/testthat/test-edge-cases.R: Edge case coverage - tests/testthat/test-qc-functions.R: QC function tests","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"code-style","dir":"","previous_headings":"","what":"Code Style","title":"CLAUDE.md","text":"Tidyverse style guide Roxygen2 Markdown syntax documentation exported functions need @export tag S3 methods include print() tidy() methods","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"linting--formatting","dir":"","previous_headings":"","what":"Linting & Formatting","title":"CLAUDE.md","text":"project uses two complementary code quality tools: jarl catches: - vector_logic: Using | instead || () statements - potential bugs inefficiencies air enforces: - 2-space indentation function signatures - One argument per line long function calls - Closing parenthesis line multi-line constructs - Consistent line length limits Run committing pass CI checks.","code":"# Linter - catches logic/efficiency issues jarl check .        # Check for issues jarl check . --fix  # Auto-fix issues  # Formatter - enforces consistent code style air format .        # Format all R files"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"pr-workflow","dir":"","previous_headings":"","what":"PR Workflow","title":"CLAUDE.md","text":"creating pull request, run following checks: adding new exported functions, ensure included _pkgdown.yml appropriate reference section.","code":"# 1. Format all R files (including tests) air format .  # 2. Check for linting issues and auto-fix jarl check . --fix  # 3. Generate/update documentation R -e 'devtools::document()'  # 4. Run full package check (should pass with 0 errors, 0 warnings) R -e 'devtools::check()'  # 5. Build pkgdown site to verify documentation renders correctly R -e 'pkgdown::build_site()'"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"technique-pack-registration","dir":"","previous_headings":"","what":"Technique Pack Registration","title":"CLAUDE.md","text":"package registers measure R/zzz.R: Users can discover available steps :","code":".onLoad <- function(libname, pkgname) {  measure::register_measure_pack(     pack_name = pkgname,     technique = \"SEC/GPC\",     description = \"Size Exclusion / Gel Permeation Chromatography\"   )   # ... register individual steps } measure::measure_steps(techniques = \"SEC/GPC\")"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"CLAUDE.md","text":"measure: Core package providing measure_tbl/measure_list classes registry recipes: tidymodels preprocessing framework tibble, dplyr, purrr, rlang: tidyverse infrastructure cli: User-friendly messages warnings","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"calibration-quality-metrics","dir":"","previous_headings":"","what":"Calibration Quality Metrics","title":"CLAUDE.md","text":"step_sec_conventional_cal() provides comprehensive diagnostics: Per-standard: residuals, % deviation, prediction intervals Overall: R², adjusted R², RMSE, residual standard error Access via tidy(prepped_recipe, number = step_number) Nested standard_results tibble contains per-standard diagnostics","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"issue-tracking-with-beads","dir":"","previous_headings":"","what":"Issue Tracking with Beads","title":"CLAUDE.md","text":"project uses bd (beads) issue tracking. Issues stored .beads/ synced via git.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"git-integration","dir":"","previous_headings":"Issue Tracking with Beads","what":"Git Integration","title":"CLAUDE.md","text":"Beads integrates git via: - JSONL sync: Issues stored .beads/issues.jsonl (git-tracked) - Merge driver: Intelligent JSONL conflict resolution (auto-configured) - Hooks: Auto-sync git operations Files committed: .beads/.gitignore, .gitattributes Files gitignored: .beads/beads.db, daemon files","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"essential-commands","dir":"","previous_headings":"Issue Tracking with Beads","what":"Essential Commands","title":"CLAUDE.md","text":"","code":"# Finding work bd ready                              # Show issues ready to work (no blockers) bd list --status=open                 # All open issues bd show <id>                          # Detailed issue view with dependencies  # Working on issues bd update <id> --status=in_progress   # Claim work bd close <id>                         # Mark complete bd close <id1> <id2> ...              # Close multiple issues  # Creating issues (always include description for context) bd create \"Fix bug\" --description=\"Details here\" -t bug -p 1  # Dependencies bd dep add <issue> <depends-on>       # Add dependency bd blocked                            # Show blocked issues bd dep tree <id>                      # View dependency tree  # Sync bd sync                               # Sync with git remote bd sync --status                      # Check sync status"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"when-to-use-beads-vs-todowrite","dir":"","previous_headings":"Issue Tracking with Beads","what":"When to Use Beads vs TodoWrite","title":"CLAUDE.md","text":"doubt, prefer beads—persistence don’t need beats lost context.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_1-find-work-and-create-worktree--feature-branch","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"1. Find Work and Create Worktree + Feature Branch","title":"CLAUDE.md","text":"⚠️ IMPORTANT: Create worktree feature branch claiming issue writing code. Rule: git status shows uncommitted changes didn’t make, STOP create worktree.","code":"bd ready                              # Find available work bd show <id>                          # Review issue details  # CHECK: Is another agent working in this directory? git status                            # Any uncommitted changes = another agent!  # CREATE WORKTREE (required for parallel work) git worktree add ../measure.sec-<id> -b feat/<short-description> cd ../measure.sec-<id>  # OR if you're the only agent, just create a branch: git checkout -b feat/<short-description>  bd update <id> --status=in_progress   # Now claim the work"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_2-work-and-sync","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"2. Work and Sync","title":"CLAUDE.md","text":"","code":"# Make changes... bd sync                               # Sync beads periodically"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_3-run-quality-gates","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"3. Run Quality Gates","title":"CLAUDE.md","text":"","code":"air format .                          # Format R files jarl check . --fix                    # Lint and fix R -e 'devtools::document()'           # Generate docs R -e 'devtools::check()'              # Full package check"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_4-create-pr-and-close-issue","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"4. Create PR and Close Issue","title":"CLAUDE.md","text":"code complete ready review: Important: Close beads issue work complete, PR merged. issue tracks work; PR tracks review/merge process.","code":"git add . git commit -m \"feat: description (measure.sec-xxx)\"  # Include beads issue ID! bd close <id>                         # Close beads issue - work is done bd sync git push -u origin HEAD gh pr create --title \"...\" --body \"Resolves measure.sec-xxx\""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_5-human-reviews-and-merges-pr","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"5. Human Reviews and Merges PR","title":"CLAUDE.md","text":"Agents create PRs merge . Humans review merge PRs main.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"id_6-after-pr-merged-cleanup","dir":"","previous_headings":"Feature Branch + PR Workflow","what":"6. After PR Merged (Cleanup)","title":"CLAUDE.md","text":"","code":"git checkout main git pull git branch -d feat/<short-description>"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"session-completion-protocol","dir":"","previous_headings":"","what":"Session Completion Protocol","title":"CLAUDE.md","text":"CRITICAL: ending session, complete steps. Work complete git push succeeds.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"mandatory-checklist-feature-branch-workflow","dir":"","previous_headings":"Session Completion Protocol","what":"Mandatory Checklist (Feature Branch Workflow)","title":"CLAUDE.md","text":"","code":"# 1. Verify you're on a feature branch (NOT main!) git branch --show-current  # Should NOT be 'main'  # 2. File issues for remaining work bd create \"Follow-up task\" --description=\"...\" -t task -p 2  # 3. Run quality gates (if code changed) air format . jarl check . --fix R -e 'devtools::check()'  # 4. Update issue status bd close <completed-issues>           # Include reason if helpful bd update <in-progress-issues> --status=open  # If not finished  # 5. Commit with beads issue ID git add . git commit -m \"feat: description (measure.sec-xxx)\"  # Always include issue ID! bd sync git push -u origin HEAD  # 6. Create PR (if not already created) gh pr create --title \"...\" --body \"Resolves measure.sec-xxx\"  # 7. Verify git status  # Should show \"up to date with origin\""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"critical-rules","dir":"","previous_headings":"Session Completion Protocol","what":"Critical Rules","title":"CLAUDE.md","text":"NEVER commit directly main - always use feature branches CHECK git status FIRST - see uncommitted changes didn’t make, create worktree Use worktrees parallel work - multiple agents = multiple worktrees Work complete git push succeeds NEVER stop pushing—leaves work stranded locally NEVER say “ready push ”—must push push fails, resolve retry succeeds Always run bd sync ending session Always include beads issue ID commit messages","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"parallel-sessions--worktrees-mandatory","dir":"","previous_headings":"","what":"Parallel Sessions & Worktrees (MANDATORY)","title":"CLAUDE.md","text":"Worktrees REQUIRED multiple agents work simultaneously. project uses sync-branch: beads-sync beads, code changes still conflict without worktrees.","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"why-worktrees-are-required","dir":"","previous_headings":"Parallel Sessions & Worktrees (MANDATORY)","what":"Why Worktrees Are Required","title":"CLAUDE.md","text":"Without worktrees, parallel agents: - Share working directory files - See ’s uncommitted changes - Accidentally commit ’s work - Create merge conflicts locally (even pushing)","code":""},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"creating-worktrees-for-each-feature","dir":"","previous_headings":"Parallel Sessions & Worktrees (MANDATORY)","what":"Creating Worktrees for Each Feature","title":"CLAUDE.md","text":"worktrees share .beads database main repo. Changes immediately visible across sessions.","code":"# From main repo, create worktree for YOUR feature git worktree add ../measure.sec-<issue-id> -b feat/<short-description> cd ../measure.sec-<issue-id>  # Verify you're in the worktree pwd  # Should show ../measure.sec-<issue-id>  # Beads commands work normally - shared database, safe daemon bd ready bd update <id> --status=in_progress"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"merging-beads-sync-to-main","dir":"","previous_headings":"Parallel Sessions & Worktrees (MANDATORY)","what":"Merging Beads-Sync to Main","title":"CLAUDE.md","text":"Periodically merge beads metadata main via PR: direct merge allowed:","code":"git push origin beads-sync gh pr create --base main --head beads-sync --title \"Sync beads metadata\" bd sync --merge"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"cleanup-after-pr-merged","dir":"","previous_headings":"Parallel Sessions & Worktrees (MANDATORY)","what":"Cleanup After PR Merged","title":"CLAUDE.md","text":"","code":"git worktree remove ../measure.sec-<issue-id> git worktree prune"},{"path":"https://jameshwade.github.io/measure-sec/CLAUDE.html","id":"troubleshooting-branch-already-checked-out","dir":"","previous_headings":"Parallel Sessions & Worktrees (MANDATORY)","what":"Troubleshooting: “Branch already checked out”","title":"CLAUDE.md","text":"git says branch checked beads worktree:","code":"rm -rf .git/beads-worktrees git worktree prune"},{"path":"https://jameshwade.github.io/measure-sec/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 measure.sec authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Polymer Branching Analysis","text":"guide shows analyze polymer branching using multi-detector SEC data. ’ll learn : Calculate branching indices (g g’) Estimate branching frequency Analyze Mark-Houwink parameters Compare branching architectures Visualize conformation data","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Polymer Branching Analysis","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"when-you-need-branching-analysis","dir":"Articles","previous_headings":"","what":"When You Need Branching Analysis","title":"Polymer Branching Analysis","text":"Branching affects polymer properties like: Melt viscosity: Branched polymers often lower viscosity linear analogs Mechanical strength: Long-chain branching can improve toughness Solution behavior: Branched chains compact linear ones SEC MALS viscometry detectors can quantify branching comparing branched samples linear references molecular weight.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example Data","title":"Polymer Branching Analysis","text":"package includes sec_branched, dataset linear, branched, star polymers:","code":"data(sec_branched)  # Sample overview sec_branched |>   distinct(sample_id, topology) |>   print() #> # A tibble: 8 × 2 #>   sample_id   topology #>   <chr>       <chr>    #> 1 Linear-50K  linear   #> 2 Linear-100K linear   #> 3 Linear-200K linear   #> 4 Branch-50K  branched #> 5 Branch-100K branched #> 6 Branch-200K branched #> 7 Star-50K    star     #> 8 Star-100K   star  # Preview the data structure sec_branched |>   group_by(sample_id) |>   summarize(     mw_range = paste(round(min(mw)), \"-\", round(max(mw))),     mean_g = round(mean(branching_index, na.rm = TRUE), 3),     .groups = \"drop\"   ) #> # A tibble: 8 × 3 #>   sample_id   mw_range      mean_g #>   <chr>       <chr>          <dbl> #> 1 Branch-100K 1e+05 - 1e+05   0.65 #> 2 Branch-200K 2e+05 - 2e+05   0.55 #> 3 Branch-50K  50000 - 50000   0.75 #> 4 Linear-100K 1e+05 - 1e+05   1    #> 5 Linear-200K 2e+05 - 2e+05   1    #> 6 Linear-50K  50000 - 50000   1    #> 7 Star-100K   1e+05 - 1e+05   0.5  #> 8 Star-50K    50000 - 50000   0.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"calculating-branching-index-g","dir":"Articles","previous_headings":"","what":"Calculating Branching Index (g)","title":"Polymer Branching Analysis","text":"branching index g compares radius gyration branched polymer linear reference molecular weight: g=Rg2(branched)Rg2(linear)g = \\frac{R_g^2(\\text{branched})}{R_g^2(\\text{linear})} Values g < 1 indicate branching (branched chains compact).","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"using-linear-reference-data","dir":"Articles","previous_headings":"Calculating Branching Index (g)","what":"Using Linear Reference Data","title":"Polymer Branching Analysis","text":"","code":"# Extract linear and branched samples linear_ref <- sec_branched |>   filter(topology == \"linear\") |>   select(mw, rg)  branched_sample <- sec_branched |>   filter(sample_id == \"Branch-100K\")  # Calculate g ratio using linear reference g_result <- measure_branching_index(    mw = branched_sample$mw,   rg = branched_sample$rg,   reference = linear_ref,   method = \"g\" ) #> Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): #> collapsing to unique 'x' values  print(g_result) #> Branching Analysis Results #> ==================================================  #>  #> MW Range: 100000 - 100000 #> g (Rg ratio): 0.627 - 0.627 (mean: 0.627) #>  #> Estimated branches/molecule: 2.6 - 2.6 #>  #> # A tibble: 701 × 2 #>        mw     g #>     <dbl> <dbl> #>  1 100000 0.627 #>  2 100000 0.627 #>  3 100000 0.627 #>  4 100000 0.627 #>  5 100000 0.627 #>  6 100000 0.627 #>  7 100000 0.627 #>  8 100000 0.627 #>  9 100000 0.627 #> 10 100000 0.627 #> # ℹ 691 more rows"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"interpreting-g-values","dir":"Articles","previous_headings":"Calculating Branching Index (g)","what":"Interpreting g Values","title":"Polymer Branching Analysis","text":"","code":"# Visualize g across MW distribution branched_with_g <- branched_sample |>   mutate(g = g_result$g)  ggplot(branched_with_g, aes(x = mw, y = g)) +  geom_point(alpha = 0.5, color = \"#2E86AB\") +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   scale_x_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +   labs(     x = \"Molecular Weight (Da)\",     y = \"Branching Index (g)\",     title = \"Branching Index vs Molecular Weight\",     subtitle = \"g < 1 indicates branching\"   ) +   theme_minimal()"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"estimating-branching-frequency","dir":"Articles","previous_headings":"","what":"Estimating Branching Frequency","title":"Polymer Branching Analysis","text":"branching frequency (branches per molecule) can estimated g using Zimm-Stockmayer theory:","code":"# Calculate branching frequency assuming random branching freq <- measure_branching_frequency(   g = g_result$g,   architecture = \"random\",   mw = branched_sample$mw )  print(freq) #> Branching Frequency Analysis (Zimm-Stockmayer) #> ==================================================  #>  #> Architecture: random #> N samples: 701 #>  #> g ratio range: 0.627 - 0.627 #> Branches/molecule: 7.74 - 7.74 (mean: 7.74) #> Branch density: 0.0774 - 0.0774 per 1000 Da #>  #> # A tibble: 701 × 2 #>        g branches_per_molecule #>    <dbl>                 <dbl> #>  1 0.627                  7.74 #>  2 0.627                  7.74 #>  3 0.627                  7.74 #>  4 0.627                  7.74 #>  5 0.627                  7.74 #>  6 0.627                  7.74 #>  7 0.627                  7.74 #>  8 0.627                  7.74 #>  9 0.627                  7.74 #> 10 0.627                  7.74 #> # ℹ 691 more rows"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"different-architectures","dir":"Articles","previous_headings":"Estimating Branching Frequency","what":"Different Architectures","title":"Polymer Branching Analysis","text":"relationship g branching frequency depends polymer architecture:","code":"# Compare architectures for the same g value g_test <- 0.6  architectures <- c(\"random\", \"star_3\", \"star_4\", \"comb\") results <- sapply(architectures, function(arch) {   tryCatch(     measure_branching_frequency(g = g_test, architecture = arch)$branches_per_molecule,     error = function(e) NA   ) })  data.frame(   Architecture = architectures,   Branches = round(results, 2) ) #>        Architecture Branches #> random       random     8.96 #> star_3       star_3     1.00 #> star_4       star_4     1.00 #> comb           comb     1.00"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"mark-houwink-analysis","dir":"Articles","previous_headings":"","what":"Mark-Houwink Analysis","title":"Polymer Branching Analysis","text":"Mark-Houwink parameters (K α) describe relationship intrinsic viscosity molecular weight: [η]=K⋅Mα[\\eta] = K \\cdot M^\\alpha exponent α provides conformational information:","code":"# Extract MW and intrinsic viscosity data linear_data <- sec_branched |>   filter(topology == \"linear\", !is.na(intrinsic_visc), intrinsic_visc > 0)  # Calculate Mark-Houwink parameters mh <- measure_mh_parameters(   mw = linear_data$mw,   intrinsic_visc = linear_data$intrinsic_visc )  print(mh) #> Mark-Houwink Parameters #> ========================================  #>  #> K = 2.9716e-02 #> a = 0.677 #>  #> R-squared: 1.0000 #> Data points: 2103 #> MW range: 50000 - 200000 #>  #> Equation: [eta] = K * M^a"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"comparing-linear-vs-branched","dir":"Articles","previous_headings":"Mark-Houwink Analysis","what":"Comparing Linear vs Branched","title":"Polymer Branching Analysis","text":"","code":"# Compare Mark-Houwink plots comparison_data <- sec_branched |>   filter(!is.na(intrinsic_visc), intrinsic_visc > 0) |>   filter(sample_id %in% c(\"Linear-100K\", \"Branch-100K\"))  ggplot(comparison_data, aes(x = mw, y = intrinsic_visc, color = topology)) +   geom_point(alpha = 0.5) +   geom_smooth(method = \"lm\", se = FALSE, linewidth = 1) +   scale_x_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +   scale_y_log10() +   scale_color_manual(values = c(\"linear\" = \"#2E86AB\", \"branched\" = \"#A23B72\")) +   labs(     x = \"Molecular Weight (Da)\",     y = \"Intrinsic Viscosity (dL/g)\",     color = \"Topology\",     title = \"Mark-Houwink Plot: Linear vs Branched\",     subtitle = \"Branched polymers show lower [η] at same MW\"   ) +   theme_minimal() +   theme(legend.position = \"bottom\") #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"rg-mw-scaling-analysis","dir":"Articles","previous_headings":"","what":"Rg-MW Scaling Analysis","title":"Polymer Branching Analysis","text":"relationship radius gyration molecular weight follows: Rg=KRg⋅MνR_g = K_{Rg} \\cdot M^\\nu exponent ν provides conformational information similar α.","code":"# Calculate Rg-MW scaling parameters rg_scaling <- measure_rg_mw_scaling(   mw = linear_data$mw,   rg = linear_data$rg )  print(rg_scaling) #> Rg-MW Scaling Analysis #> ========================================  #>  #> Scaling Law: Rg = K * M^nu #>  #> nu (Flory exponent): 0.500 #>   95% CI: [0.500, 0.500] #> K (prefactor): 3.7991e-02 #>  #> Conformation: theta solvent (ideal chain) #>  #> R-squared: 1.0000 #> Data points: 2103 #> MW range: 50000 - 200000"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"comparing-branching-models","dir":"Articles","previous_headings":"","what":"Comparing Branching Models","title":"Polymer Branching Analysis","text":"experimental g data, can compare theoretical predictions identify likely branching architecture:","code":"# Compare experimental data to branching models branched_data <- sec_branched |>   filter(topology == \"branched\", !is.na(branching_index))  comparison <- measure_branching_model_comparison(   g = branched_data$branching_index,   mw = branched_data$mw )  print(comparison) #> Branching Model Comparison #> ============================================================  #>  #> Model Fit Summary: #> ------------------------------------------------------------  #>          model   parameter r_squared       rmse        aic #>         random 0.066439282 0.9545604 0.01740491 -11066.463 #>           star 1.657330906 0.6361160 0.04925336  -6691.276 #>           comb 0.007454604 0.7363526 0.04192433  -7368.910 #>  hyperbranched 0.132485444 0.9303057 0.02155524 -10166.940 #> ------------------------------------------------------------  #>  #> Best Model: random (lowest AIC) #>   R-squared: 0.9546 #>   RMSE: 0.0174 #>   Parameter: 0.0664 #>  #> Note: Lower AIC indicates better fit with penalty for complexity. #> Consider physical plausibility when selecting the final model."},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"conformation-plots","dir":"Articles","previous_headings":"","what":"Conformation Plots","title":"Polymer Branching Analysis","text":"Visualize structure-MW relationships plot_sec_conformation(). slope reveals polymer conformation:  slope (ν) indicates conformation: - ν ≈ 0.5-0.6: Linear chains good solvent - ν < 0.5: Branched compact structures - ν > 0.6: Extended chains","code":"# Prepare data for conformation plot plot_data <- sec_branched |>   filter(!is.na(rg), rg > 0, !is.na(mw), mw > 0)  # Create Rg-MW conformation plot plot_sec_conformation(   plot_data,   type = \"rg_mw\",   mw_col = \"mw\",   y_col = \"rg\",   sample_id = \"topology\",   show_fit = TRUE,   show_exponent = TRUE )"},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"complete-workflow-example","dir":"Articles","previous_headings":"","what":"Complete Workflow Example","title":"Polymer Branching Analysis","text":"’s complete workflow analyzing unknown branched sample:","code":"# Step 1: Load and prepare data unknown_sample <- sec_branched |>   filter(sample_id == \"Branch-200K\")  linear_reference <- sec_branched |>   filter(topology == \"linear\")  # Step 2: Calculate branching index g_analysis <- measure_branching_index(   mw = unknown_sample$mw,   rg = unknown_sample$rg,   reference = linear_reference |> select(mw, rg),   method = \"g\" ) #> Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): #> collapsing to unique 'x' values  cat(\"Mean branching index (g):\", round(mean(g_analysis$g, na.rm = TRUE), 3), \"\\n\") #> Mean branching index (g): 0.541  # Step 3: Estimate branching frequency freq_analysis <- measure_branching_frequency(   g = g_analysis$g,   architecture = \"random\",   mw = unknown_sample$mw )  cat(\"Mean branches per molecule:\", round(mean(freq_analysis$branches_per_molecule, na.rm = TRUE), 1), \"\\n\") #> Mean branches per molecule: 12.4  # Step 4: Calculate Mark-Houwink parameters mh_branched <- measure_mh_parameters(   mw = unknown_sample$mw,   intrinsic_visc = unknown_sample$intrinsic_visc ) #> Warning in summary.lm(fit): essentially perfect fit: summary may be unreliable  cat(\"Mark-Houwink exponent (α):\", round(mh_branched$a, 3), \"\\n\") #> Mark-Houwink exponent (α): NA cat(\"(α < 0.5 suggests branching)\\n\") #> (α < 0.5 suggests branching)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Polymer Branching Analysis","text":"Getting Started - Basic SEC workflow Multi-Detector SEC - MALS viscometry setup SEC Analysis Reference - Complete function reference","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/branching-analysis.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Polymer Branching Analysis","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] nlme_3.1-168        parallelly_1.46.1   lava_1.8.2          #> [37] tidyselect_1.2.1    digest_0.6.39       future_1.68.0       #> [40] purrr_1.2.0         listenv_0.10.0      labeling_0.4.3      #> [43] splines_4.5.2       fastmap_1.2.0       grid_4.5.2          #> [46] cli_3.6.5           magrittr_2.0.4      utf8_1.2.6          #> [49] survival_3.8-3      future.apply_1.20.1 withr_3.0.2         #> [52] scales_1.4.0        lubridate_1.9.4     timechange_0.3.0    #> [55] rmarkdown_2.30      globals_0.18.0      nnet_7.3-20         #> [58] timeDate_4051.111   ragg_1.5.0          evaluate_1.0.5      #> [61] knitr_1.51          hardhat_1.4.2       mgcv_1.9-3          #> [64] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [67] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [70] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Calibration Management","text":"guide shows save, load, reuse SEC calibrations measure.sec. Key tasks covered: Save calibration prepped recipe Load reuse saved calibration Inspect calibration quality Compare calibrations time","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Calibration Management","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"step-1-fit-a-calibration","dir":"Articles","previous_headings":"How to Create and Save a Calibration","what":"Step 1: Fit a Calibration","title":"Calibration Management","text":"First, create recipe calibration standards prep fit calibration:","code":"# Load polystyrene standards data(sec_ps_standards)  # View the standards sec_ps_standards |>   select(standard_name, mp, log_mp, retention_time) |>   head(8) #> # A tibble: 8 × 4 #>   standard_name      mp log_mp retention_time #>   <chr>           <dbl>  <dbl>          <dbl> #> 1 PS-3150000    3150000   6.50           11.2 #> 2 PS-1870000    1870000   6.27           11.6 #> 3 PS-1090000    1090000   6.04           12.1 #> 4 PS-630000      630000   5.80           12.6 #> 5 PS-430000      430000   5.63           13.2 #> 6 PS-216000      216000   5.33           13.8 #> 7 PS-120000      120000   5.08           14.3 #> 8 PS-67500        67500   4.83           15.0 # Prepare standards with required column names # The step expects 'retention' and 'log_mw' columns ps_cal_standards <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  # Create a simple data frame for the recipe # (In practice, this would be your chromatogram data) sample_data <- tibble(   sample_id = \"test\",   elution_time = seq(10, 20, by = 0.01),   ri_signal = dnorm(seq(10, 20, by = 0.01), mean = 14, sd = 1) )  # Create and prep a recipe with conventional calibration rec <- recipe(~ ., data = sample_data) |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_conventional_cal(     standards = ps_cal_standards,     fit_type = \"cubic\"   )  # Prep the recipe (this fits the calibration) prepped <- prep(rec) #> Warning: Standard at 12.58 has 14.4% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 115 points (11.5%) are outside calibration range. #> ℹ Calibration range: 11.15 to 20.79"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"step-2-save-the-calibration","dir":"Articles","previous_headings":"How to Create and Save a Calibration","what":"Step 2: Save the Calibration","title":"Calibration Management","text":"Use save_sec_calibration() extract save calibration reuse:","code":"# Create a temporary file for this example cal_file <- tempfile(fileext = \".rds\")  # Save with metadata for traceability save_sec_calibration(  prepped,   cal_file,   metadata = list(     column = \"PLgel 5um Mixed-C\",     instrument = \"Agilent 1260\",     analyst = \"JW\",     notes = \"Monthly calibration - January 2024\"   ) ) #> ✔ Saved cubic calibration to /tmp/Rtmp3LKKZC/file29a0483aaa6c.rds"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"format-options","dir":"Articles","previous_headings":"How to Create and Save a Calibration","what":"Format Options","title":"Calibration Management","text":"Two formats supported:","code":"# Save as YAML for human readability save_sec_calibration(prepped, \"calibration.yaml\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"load-a-saved-calibration","dir":"Articles","previous_headings":"How to Load and Reuse a Calibration","what":"Load a Saved Calibration","title":"Calibration Management","text":"","code":"# Load the calibration cal <- load_sec_calibration(cal_file) #> ℹ Loaded cubic calibration (R\\u00b2 = 0.9995)  # View calibration details print(cal) #>  #> ── SEC Calibration ───────────────────────────────────────────────────────────── #> Fit type: cubic (degree 3) #> Calibration range: 11.15 to 20.79 #> Standards: 16 #>  #> ── Fit Quality ── #>  #> R\\u00b2: 0.999466 #> RMSE (log MW): 0.0294 #> Max % deviation: 14.43% #>  #> ── Settings ── #>  #> Extrapolation: warn #> Output column: mw #> Log output: TRUE #>  #> ── Metadata ── #>  #> Created: 2026-01-08 17:12:54 #> measure.sec version: 0.0.0.9000 #>  #> ── User Metadata #> column: PLgel 5um Mixed-C #> instrument: Agilent 1260 #> analyst: JW #> notes: Monthly calibration - January 2024"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"use-in-a-new-recipe","dir":"Articles","previous_headings":"How to Load and Reuse a Calibration","what":"Use in a New Recipe","title":"Calibration Management","text":"Pass loaded calibration step_sec_conventional_cal() skip fitting:","code":"# New sample data new_samples <- tibble(   sample_id = \"unknown_polymer\",   elution_time = seq(10, 20, by = 0.01),   ri_signal = dnorm(seq(10, 20, by = 0.01), mean = 15, sd = 0.8) )  # Create recipe using saved calibration (no fitting needed) rec_new <- recipe(~ ., data = new_samples) |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_conventional_cal(calibration = cal)  # Prep and bake prepped_new <- prep(rec_new) #> ℹ Using pre-loaded cubic calibration (R\\u00b2 = 0.9995) #> Warning: 115 points (11.5%) are outside calibration range. #> ℹ Calibration range: 11.15 to 20.79 result <- bake(prepped_new, new_data = NULL)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"view-fit-diagnostics","dir":"Articles","previous_headings":"How to Inspect Calibration Quality","what":"View Fit Diagnostics","title":"Calibration Management","text":"","code":"# Summary shows per-standard results summary(cal) #>  #> ── SEC Calibration ───────────────────────────────────────────────────────────── #> Fit type: cubic (degree 3) #> Calibration range: 11.15 to 20.79 #> Standards: 16 #>  #> ── Fit Quality ── #>  #> R\\u00b2: 0.999466 #> RMSE (log MW): 0.0294 #> Max % deviation: 14.43% #>  #> ── Settings ── #>  #> Extrapolation: warn #> Output column: mw #> Log output: TRUE #>  #> ── Metadata ── #>  #> Created: 2026-01-08 17:12:54 #> measure.sec version: 0.0.0.9000 #>  #> ── User Metadata #> column: PLgel 5um Mixed-C #> instrument: Agilent 1260 #> analyst: JW #> notes: Monthly calibration - January 2024 #>  #> ── Per-Standard Results ── #>  #> # A tibble: 16 × 10 #>    location actual_log_mw predicted_log_mw residual_log_mw actual_mw #>       <dbl>         <dbl>            <dbl>           <dbl>     <dbl> #>  1     11.2          6.50             6.47         0.0294   3150000. #>  2     11.6          6.27             6.28        -0.00364  1870000. #>  3     12.1          6.04             6.06        -0.0192   1090000  #>  4     12.6          5.80             5.86        -0.0585    630000. #>  5     13.2          5.63             5.59         0.0421    430000. #>  6     13.8          5.33             5.32         0.0126    216000  #>  7     14.3          5.08             5.11        -0.0300    120000. #>  8     15.0          4.83             4.79         0.0413     67500. #>  9     15.5          4.53             4.55        -0.0262     33500. #> 10     16.1          4.30             4.26         0.0352     19800  #> 11     16.7          3.99             4.01        -0.0197      9680  #> 12     17.4          3.70             3.70         0.00359     5030  #> 13     17.9          3.47             3.46         0.0146      2970  #> 14     18.9          3.02             3.02         0.00222     1050  #> 15     19.4          2.76             2.81        -0.0419       580  #> 16     20.8          2.21             2.19         0.0181       162  #> # ℹ 5 more variables: predicted_mw <dbl>, pct_deviation <dbl>, #> #   prediction_se <dbl>, ci_lower_log_mw <dbl>, ci_upper_log_mw <dbl>"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"visualize-the-calibration-curve","dir":"Articles","previous_headings":"How to Inspect Calibration Quality","what":"Visualize the Calibration Curve","title":"Calibration Management","text":"","code":"# Plot calibration curve from standards data plot_sec_calibration(sec_ps_standards) # With residuals panel to check for systematic errors plot_sec_calibration(sec_ps_standards, show_residuals = TRUE)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"reuse-existing-calibration-when","dir":"Articles","previous_headings":"When to Recalibrate vs. Reuse","what":"Reuse Existing Calibration When:","title":"Calibration Management","text":"column mobile phase Column performance stable (check plate count) Within lab’s validated timeframe (typically 1-4 weeks) Running routine samples","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"recalibrate-when","dir":"Articles","previous_headings":"When to Recalibrate vs. Reuse","what":"Recalibrate When:","title":"Calibration Management","text":"New column installed Mobile phase composition changed Column performance degraded Significant time passed Method validation requires fresh calibration Results seem inconsistent","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"naming-conventions","dir":"Articles","previous_headings":"Best Practices","what":"Naming Conventions","title":"Calibration Management","text":"Use descriptive, consistent file names:","code":"# Good: includes key information \"ps_plgel-mixed-c_2024-01-15.rds\" \"pmma_superose6_instrument2_2024-01.yaml\"  # Avoid: ambiguous names \"calibration.rds\" \"cal_new.rds\""},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"include-metadata","dir":"Articles","previous_headings":"Best Practices","what":"Include Metadata","title":"Calibration Management","text":"Always add metadata traceability:","code":"save_sec_calibration(   prepped,   \"ps_calibration.rds\",   metadata = list(     column = \"PLgel 5um Mixed-C, S/N ABC123\",     instrument = \"Agilent 1260 #2\",     analyst = \"Jane Doe\",     date = Sys.Date(),     mobile_phase = \"THF + 0.1% BHT\",     flow_rate = \"1.0 mL/min\",     temperature = \"35C\",     notes = \"Monthly recalibration after column flush\"   ) )"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"version-control-yaml-format","dir":"Articles","previous_headings":"Best Practices","what":"Version Control (YAML Format)","title":"Calibration Management","text":"labs using git similar version control:","code":"# YAML format is diff-friendly save_sec_calibration(prepped, \"calibrations/ps_current.yaml\")  # Git will show meaningful diffs when calibration changes"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"lab-workflow-integration","dir":"Articles","previous_headings":"Best Practices","what":"Lab Workflow Integration","title":"Calibration Management","text":"typical workflow: Monthly: Run calibration standards, save new calibration date Daily: Load current calibration sample analysis Archive: Keep old calibrations historical reference Compare: Periodically compare calibrations detect drift","code":"# Monthly calibration routine monthly_cal <- prep(calibration_recipe) save_sec_calibration(   monthly_cal,   sprintf(\"calibrations/ps_%s.rds\", format(Sys.Date(), \"%Y-%m\")),   metadata = list(analyst = Sys.info()[\"user\"]) )  # Daily sample analysis cal <- load_sec_calibration(\"calibrations/ps_2024-01.rds\") samples_recipe <- recipe(...) |>   step_sec_conventional_cal(calibration = cal) |>   prep()"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"cleanup","dir":"Articles","previous_headings":"","what":"Cleanup","title":"Calibration Management","text":"","code":"# Remove temporary file unlink(cal_file)"},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Calibration Management","text":"Getting Started - Basic SEC workflow concepts System Suitability - Validate column performance Multi-Detector SEC - Absolute MW without calibration Exporting Results - Summary tables reports","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/calibration-management.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Calibration Management","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      patchwork_1.3.2     utf8_1.2.6          #> [49] survival_3.8-3      future.apply_1.20.1 withr_3.0.2         #> [52] scales_1.4.0        lubridate_1.9.4     timechange_0.3.0    #> [55] rmarkdown_2.30      globals_0.18.0      nnet_7.3-20         #> [58] timeDate_4051.111   ragg_1.5.0          evaluate_1.0.5      #> [61] knitr_1.51          hardhat_1.4.2       rlang_1.1.6         #> [64] Rcpp_1.1.0          glue_1.8.0          ipred_0.9-15        #> [67] jsonlite_2.0.0      R6_2.6.1            systemfonts_1.3.1   #> [70] fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Copolymer Composition Analysis","text":"SEC dual detection (UV RI) can reveal compositional heterogeneity copolymers. analyzing UV/RI ratio across molecular weight distribution, can: Detect compositional drift polymerization Identify blocky vs random copolymer structures Quantify composition different molecular weights vignette covers: UV/RI ratio analysis Composition calculations Interpreting compositional heterogeneity","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"what-makes-copolymers-complex","dir":"Articles","previous_headings":"Understanding Copolymer Heterogeneity","what":"What Makes Copolymers Complex","title":"Copolymer Composition Analysis","text":"copolymer polymer chain built two different monomer units. Unlike homopolymers (single monomer type), copolymers additional dimension complexity: compositional heterogeneity—variation monomer ratio across molecular weight distribution. Consider styrene-acrylate copolymer: overall composition might 40% styrene, just average. Individual chains might range 30% 50% styrene, variation often correlates molecular weight. Understanding heterogeneity essential predicting material properties—copolymer uniform composition behaves differently one significant compositional drift, even identical average compositions.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"why-composition-varies-with-molecular-weight","dir":"Articles","previous_headings":"Understanding Copolymer Heterogeneity","what":"Why Composition Varies with Molecular Weight","title":"Copolymer Composition Analysis","text":"polymerization, monomer consumption changes reactor composition time. one monomer reacts faster (different reactivity ratios), chains formed early different composition chains formed later. result compositional drift: systematic change composition across molecular weight distribution. drift creates correlation MW composition. SEC, higher MW chains elute first. high MW chains formed reactor enriched one monomer, higher content monomer. UV/RI ratio across chromatogram directly reveals variation. Beyond drift, copolymers can also show compositional distribution—random variation composition molecular weight. Block copolymers, gradient copolymers, statistical copolymers distinct compositional signatures SEC dual detection can reveal.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"what-uvri-ratio-analysis-can-and-cannot-tell-you","dir":"Articles","previous_headings":"Understanding Copolymer Heterogeneity","what":"What UV/RI Ratio Analysis Can (and Cannot) Tell You","title":"Copolymer Composition Analysis","text":"UV/RI ratio method provides powerful, accessible approach compositional analysis one monomer absorbs UV light doesn’t. ratio UV RI signal elution slice reflects local composition. flat ratio indicates uniform composition; changing ratio reveals heterogeneity. However, approach important limitations: monomers must different UV responses. absorb equally (neither absorbs), UV/RI provides compositional information. Response factors must known. Converting UV/RI ratio actual composition requires accurate extinction coefficients dn/dc values monomer unit. Secondary effects can interfere. Sequence effects (alternating vs. random vs. blocky distribution) can affect UV absorption RI response beyond simple compositional effects. systems UV/RI analysis isn’t applicable, sophisticated techniques like SEC-FTIR SEC-NMR can provide compositional information, though added complexity cost.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Copolymer Composition Analysis","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"uv-and-ri-response","dir":"Articles","previous_headings":"Copolymer Detection Principles","what":"UV and RI Response","title":"Copolymer Composition Analysis","text":"Different monomers different detector responses:","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Copolymer Composition Analysis","text":"package includes sec_copolymer, dataset styrene-acrylate copolymers varying compositions:","code":"data(sec_copolymer, package = \"measure.sec\")  # View the dataset structure glimpse(sec_copolymer) #> Rows: 4,206 #> Columns: 8 #> $ sample_id        <chr> \"Copoly-20S\", \"Copoly-20S\", \"Copoly-20S\", \"Copoly-20S… #> $ elution_time     <dbl> 8.00, 8.02, 8.04, 8.06, 8.08, 8.10, 8.12, 8.14, 8.16,… #> $ ri_signal        <dbl> 0.005043384, 0.004595667, 0.004945809, 0.005114517, 0… #> $ uv_254_signal    <dbl> 0.01516172, 0.01369785, 0.01487566, 0.01432866, 0.015… #> $ styrene_fraction <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2… #> $ mw               <dbl> 45000, 45000, 45000, 45000, 45000, 45000, 45000, 4500… #> $ dispersity       <dbl> 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8… #> $ description      <chr> \"20% styrene, 80% acrylate\", \"20% styrene, 80% acryla…  # Available samples sec_copolymer |>   distinct(sample_id, styrene_fraction, description) #> # A tibble: 6 × 3 #>   sample_id  styrene_fraction description               #>   <chr>                 <dbl> <chr>                     #> 1 Copoly-20S              0.2 20% styrene, 80% acrylate #> 2 Copoly-40S              0.4 40% styrene, 60% acrylate #> 3 Copoly-60S              0.6 60% styrene, 40% acrylate #> 4 Copoly-80S              0.8 80% styrene, 20% acrylate #> 5 PS-Homo                 1   Polystyrene homopolymer   #> 6 PA-Homo                 0   Polyacrylate homopolymer"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"basic-workflow","dir":"Articles","previous_headings":"UV/RI Ratio Analysis","what":"Basic Workflow","title":"Copolymer Composition Analysis","text":"","code":"# Analyze a single copolymer sample copoly_40 <- sec_copolymer |>   filter(sample_id == \"Copoly-40S\")  # UV/RI ratio analysis for compositional heterogeneity rec_ratio <- recipe(   ri_signal + uv_254_signal + elution_time ~ sample_id,   data = copoly_40 ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert signals to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_measure_input_long(     uv_254_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\")) |>   # Calculate UV/RI ratio   step_sec_uv_ri_ratio(     uv_col = \"uv\",     ri_col = \"ri\",     smooth = TRUE          # Apply smoothing for noise reduction   )  prepped_ratio <- prep(rec_ratio) result_ratio <- bake(prepped_ratio, new_data = NULL)  # View result columns names(result_ratio) #> [1] \"sample_id\"    \"ri\"           \"uv\"           \"elution_time\" \"uv_ri_ratio\""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"extracting-the-ratio-curve","dir":"Articles","previous_headings":"UV/RI Ratio Analysis","what":"Extracting the Ratio Curve","title":"Copolymer Composition Analysis","text":"","code":"# The uv_ri_ratio column contains a measure_list # Extract the ratio values at each elution time ratio_data <- result_ratio |>   select(sample_id, uv_ri_ratio) |>   tidyr::unnest(uv_ri_ratio)  # Plot ratio vs elution time ggplot(ratio_data, aes(location, value)) +   geom_line(color = \"#A23B72\") +   labs(     x = \"Elution Time (min)\",     y = \"UV/RI Ratio\",     title = \"UV/RI Ratio Profile for 40% Styrene Copolymer\",     subtitle = \"Flat ratio indicates uniform composition across MW\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"using-known-response-factors","dir":"Articles","previous_headings":"Composition Calculation","what":"Using Known Response Factors","title":"Copolymer Composition Analysis","text":"know response factors monomer, calculate actual composition:","code":"# Composition calculation with known response factors for styrene-acrylate rec_comp <- recipe(   ri_signal + uv_254_signal + elution_time ~ sample_id,   data = copoly_40 ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_254_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = c(\"ri\", \"uv\")) |>   # Calculate composition from UV/RI   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     # Response factors for styrene (UV-active)     component_a_uv = 1.0,    # Strong UV absorption at 254 nm     component_a_ri = 0.185,  # dn/dc in THF     # Response factors for acrylate (UV-inactive)     component_b_uv = 0.02,   # Weak UV absorption     component_b_ri = 0.084   # dn/dc in THF   )  prepped_comp <- prep(rec_comp) result_comp <- bake(prepped_comp, new_data = NULL)  # Result contains composition columns result_comp |>   select(sample_id, starts_with(\"composition_\")) #> # A tibble: 1 × 2 #>   sample_id  composition_a #>   <chr>             <meas> #> 1 Copoly-40S     [701 × 2]"},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"response-factor-determination","dir":"Articles","previous_headings":"Composition Calculation","what":"Response Factor Determination","title":"Copolymer Composition Analysis","text":"Response factors measured experimentally: dn/dc: Measure differential refractometer UV extinction: Measure UV-Vis spectrophotometer Typical values (THF, 25°C):","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"uniform-composition","dir":"Articles","previous_headings":"Interpreting Results","what":"Uniform Composition","title":"Copolymer Composition Analysis","text":"Characteristics: - Constant UV/RI ratio - Flat composition profile - Indicates random alternating copolymer","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"compositional-drift","dir":"Articles","previous_headings":"Interpreting Results","what":"Compositional Drift","title":"Copolymer Composition Analysis","text":"Characteristics: - Changing UV/RI ratio - Sloped composition profile - Indicates gradient copolymer reactivity differences","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"bimodal-composition","dir":"Articles","previous_headings":"Interpreting Results","what":"Bimodal Composition","title":"Copolymer Composition Analysis","text":"Characteristics: - Abrupt ratio changes - Step-like composition profile - Indicates blend block copolymer","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"comparing-multiple-copolymers","dir":"Articles","previous_headings":"","what":"Comparing Multiple Copolymers","title":"Copolymer Composition Analysis","text":"Analyze copolymer samples compare UV/RI ratios across compositions:","code":"# Analyze all samples (excluding homopolymers for this example) copolymers_only <- sec_copolymer |>   filter(stringr::str_starts(sample_id, \"Copoly\"))  # Process all copolymers rec_all <- recipe(   ri_signal + uv_254_signal + elution_time ~ sample_id,   data = copolymers_only ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_254_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = c(\"ri\", \"uv\")) |>   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\", smooth = TRUE)  prepped_all <- prep(rec_all) result_all <- bake(prepped_all, new_data = NULL)  # Extract ratio curves for plotting all_ratios <- result_all |>   select(sample_id, uv_ri_ratio) |>   tidyr::unnest(uv_ri_ratio)  # Plot UV/RI ratios - higher ratio = more styrene ggplot(all_ratios, aes(location, value, color = sample_id)) +   geom_line(linewidth = 1) +   labs(     x = \"Elution Time (min)\",     y = \"UV/RI Ratio\",     color = \"Sample\",     title = \"UV/RI Ratio Profiles by Styrene Content\",     subtitle = \"Higher ratio corresponds to more styrene (UV-absorbing)\"   ) +   scale_color_viridis_d() +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"detector-calibration","dir":"Articles","previous_headings":"Best Practices","what":"Detector Calibration","title":"Copolymer Composition Analysis","text":"Verify response factors homopolymer standards Account detector delay UV RI Use solvent response factor determination","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"data-quality","dir":"Articles","previous_headings":"Best Practices","what":"Data Quality","title":"Copolymer Composition Analysis","text":"Adequate signal--noise detectors Baseline correction ratio calculation Signal threshold avoid noise low-signal regions","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"interpretation-caveats","dir":"Articles","previous_headings":"Best Practices","what":"Interpretation Caveats","title":"Copolymer Composition Analysis","text":"UV/RI ratio relative, absolute composition Assumes specific interactions detector polymer Block copolymers may show different behavior random","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Copolymer Composition Analysis","text":"Getting Started - Basic SEC workflow concepts Multi-Detector SEC - Detector setup processing Calibration Management - Save reuse calibrations Exporting Results - Summary tables report generation","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/copolymer-analysis.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Copolymer Composition Analysis","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     stringr_1.6.0       compiler_4.5.2      #> [19] farver_2.1.2        textshaping_1.0.4   codetools_0.2-20    #> [22] htmltools_0.5.9     class_7.3-23        sass_0.4.10         #> [25] yaml_2.3.12         prodlim_2025.04.28  tidyr_1.3.2         #> [28] pillar_1.11.1       pkgdown_2.2.0       jquerylib_0.1.4     #> [31] MASS_7.3-65         cachem_1.1.0        gower_1.0.2         #> [34] rpart_4.1.24        parallelly_1.46.1   lava_1.8.2          #> [37] tidyselect_1.2.1    digest_0.6.39       stringi_1.8.7       #> [40] future_1.68.0       purrr_1.2.0         listenv_0.10.0      #> [43] labeling_0.4.3      splines_4.5.2       fastmap_1.2.0       #> [46] grid_4.5.2          cli_3.6.5           magrittr_2.0.4      #> [49] utf8_1.2.6          survival_3.8-3      future.apply_1.20.1 #> [52] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [55] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [58] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [61] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [64] viridisLite_0.4.2   rlang_1.1.6         Rcpp_1.1.0          #> [67] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [70] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Exporting Results","text":"processing SEC data measure.sec, ’ll need export results reports, analysis, regulatory submissions. guide covers: Creating summary tables MW averages Extracting slice--slice data detailed analysis Comparing multiple samples side--side Generating automated reports Exporting Excel, CSV, formats","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Exporting Results","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"creating-processed-data-for-export","dir":"Articles","previous_headings":"","what":"Creating Processed Data for Export","title":"Exporting Results","text":"real workflow, ’d process SEC data calibration MW averaging steps (see Getting Started vignette). , ’ll create representative processed data demonstrate export functions. multi-sample comparisons, let’s create data different polymer types:","code":"# Simulate processed SEC results with realistic MW values # In practice, these columns come from step_sec_mw_averages()  processed <- tibble::tibble(   sample_id = c(\"PS-50K\", \"PS-100K\", \"PS-200K\"),   polymer_type = \"polystyrene\",   # MW averages (typical for narrow PS standards)   mw_mn = c(48500, 97200, 195000),   mw_mw = c(50200, 101000, 203000),   mw_mz = c(52100, 105000, 211000),   mw_dispersity = c(1.035, 1.039, 1.041),   # Additional metadata   injection_volume = 100,  # µL   concentration = 2.0      # mg/mL )  processed #> # A tibble: 3 × 8 #>   sample_id polymer_type  mw_mn  mw_mw  mw_mz mw_dispersity injection_volume #>   <chr>     <chr>         <dbl>  <dbl>  <dbl>         <dbl>            <dbl> #> 1 PS-50K    polystyrene   48500  50200  52100          1.03              100 #> 2 PS-100K   polystyrene   97200 101000 105000          1.04              100 #> 3 PS-200K   polystyrene  195000 203000 211000          1.04              100 #> # ℹ 1 more variable: concentration <dbl> # Three batches with slight variations (typical QC scenario) batch1 <- tibble::tibble(   sample_id = \"Batch-001\",   mw_mn = 48200, mw_mw = 50100, mw_mz = 52000, mw_dispersity = 1.039 )  batch2 <- tibble::tibble(   sample_id = \"Batch-002\",   mw_mn = 49100, mw_mw = 51200, mw_mz = 53100, mw_dispersity = 1.043 )  batch3 <- tibble::tibble(   sample_id = \"Batch-003\",   mw_mn = 47800, mw_mw = 49800, mw_mz = 51900, mw_dispersity = 1.042 )"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"basic-summary-table","dir":"Articles","previous_headings":"Summary Tables","what":"Basic Summary Table","title":"Exporting Results","text":"measure_sec_summary_table() creates one-row-per-sample table key metrics:","code":"# Create summary table - automatically finds MW columns summary_tbl <- measure_sec_summary_table(   processed,   sample_id = \"sample_id\" )  print(summary_tbl) #> SEC Analysis Summary #> ============================================================  #> Samples: 3  #>  #> # A tibble: 3 × 5 #>   sample_id  mw_mn  mw_mw  mw_mz mw_dispersity #>   <chr>      <dbl>  <dbl>  <dbl>         <dbl> #> 1 PS-50K     48500  50200  52100          1.03 #> 2 PS-100K    97200 101000 105000          1.04 #> 3 PS-200K   195000 203000 211000          1.04"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"including-additional-columns","dir":"Articles","previous_headings":"Summary Tables","what":"Including Additional Columns","title":"Exporting Results","text":"can include numeric column data:","code":"# Include method metadata alongside MW results summary_with_meta <- measure_sec_summary_table(   processed,   sample_id = \"sample_id\",   additional_cols = c(\"injection_volume\", \"concentration\") )  print(summary_with_meta) #> SEC Analysis Summary #> ============================================================  #> Samples: 3  #>  #> # A tibble: 3 × 7 #>   sample_id  mw_mn  mw_mw  mw_mz mw_dispersity injection_volume concentration #>   <chr>      <dbl>  <dbl>  <dbl>         <dbl>            <dbl>         <dbl> #> 1 PS-50K     48500  50200  52100          1.03              100             2 #> 2 PS-100K    97200 101000 105000          1.04              100             2 #> 3 PS-200K   195000 203000 211000          1.04              100             2"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"controlling-decimal-places","dir":"Articles","previous_headings":"Summary Tables","what":"Controlling Decimal Places","title":"Exporting Results","text":"regulatory submissions require specific precision:","code":"# Higher precision for documentation summary_precise <- measure_sec_summary_table(   processed,   sample_id = \"sample_id\",   digits = 0  # Whole numbers for MW )  print(summary_precise) #> SEC Analysis Summary #> ============================================================  #> Samples: 3  #>  #> # A tibble: 3 × 5 #>   sample_id  mw_mn  mw_mw  mw_mz mw_dispersity #>   <chr>      <dbl>  <dbl>  <dbl>         <dbl> #> 1 PS-50K     48500  50200  52100             1 #> 2 PS-100K    97200 101000 105000             1 #> 3 PS-200K   195000 203000 211000             1"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"understanding-slice-data","dir":"Articles","previous_headings":"Slice Tables: Point-by-Point Data","what":"Understanding Slice Data","title":"Exporting Results","text":"SEC analysis works point--point basis across chromatogram. “slice” represents one data point elution time corresponding signal values. Use measure_sec_slice_table() extract detailed data recipes produce measure_list columns.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"creating-slice-data","dir":"Articles","previous_headings":"Slice Tables: Point-by-Point Data","what":"Creating Slice Data","title":"Exporting Results","text":"First, let’s process actual chromatogram data demonstrate slice extraction:","code":"# Load and process actual chromatogram data data(sec_triple_detect)  # Process a single sample ps_sample <- sec_triple_detect |>   filter(sample_id == \"PS-100K\")  rec <- recipe(   ri_signal + elution_time ~ sample_id,   data = ps_sample ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\")  chromatogram_data <- prep(rec) |> bake(new_data = NULL)"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"long-format-default","dir":"Articles","previous_headings":"Slice Tables: Point-by-Point Data","what":"Long Format (Default)","title":"Exporting Results","text":"Long format best plotting ggplot2:","code":"# Extract slice data in long format slices_long <- measure_sec_slice_table(   chromatogram_data,   measures = \"ri\",   sample_id = \"sample_id\" )  # View structure - one row per data point head(slices_long, 10) #> # A tibble: 10 × 5 #>    sample_id slice location measure   value #>    <chr>     <int>    <dbl> <chr>     <dbl> #>  1 PS-100K       1     5    ri      0.00132 #>  2 PS-100K       2     5.01 ri      0.00189 #>  3 PS-100K       3     5.02 ri      0.00156 #>  4 PS-100K       4     5.03 ri      0.00123 #>  5 PS-100K       5     5.04 ri      0.00157 #>  6 PS-100K       6     5.05 ri      0.00116 #>  7 PS-100K       7     5.06 ri      0.00188 #>  8 PS-100K       8     5.07 ri      0.00110 #>  9 PS-100K       9     5.08 ri      0.00135 #> 10 PS-100K      10     5.09 ri      0.00126 # Plot using the slice table ggplot(slices_long, aes(x = location, y = value)) +   geom_line(color = \"#2E86AB\") +   labs(     x = \"Elution Time (min)\",     y = \"RI Signal (baseline corrected)\",     title = \"Chromatogram from Slice Data\"   ) +   theme_minimal()"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"wide-format","dir":"Articles","previous_headings":"Slice Tables: Point-by-Point Data","what":"Wide Format","title":"Exporting Results","text":"Wide format better spreadsheet export correlating multiple measures:","code":"# Wide format puts each measure in its own column slices_wide <- measure_sec_slice_table(   chromatogram_data,   measures = \"ri\",   sample_id = \"sample_id\",   pivot = TRUE )  head(slices_wide) #> # A tibble: 6 × 4 #>   sample_id slice location      ri #>   <chr>     <int>    <dbl>   <dbl> #> 1 PS-100K       1     5    0.00132 #> 2 PS-100K       2     5.01 0.00189 #> 3 PS-100K       3     5.02 0.00156 #> 4 PS-100K       4     5.03 0.00123 #> 5 PS-100K       5     5.04 0.00157 #> 6 PS-100K       6     5.05 0.00116"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"exporting-slice-data-to-csv","dir":"Articles","previous_headings":"Slice Tables: Point-by-Point Data","what":"Exporting Slice Data to CSV","title":"Exporting Results","text":"","code":"# Export for external analysis write.csv(slices_long, \"sec_slice_data.csv\", row.names = FALSE)  # Or use readr for consistent formatting readr::write_csv(slices_long, \"sec_slice_data.csv\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"basic-comparison","dir":"Articles","previous_headings":"Comparing Multiple Samples","what":"Basic Comparison","title":"Exporting Results","text":"measure_sec_compare() provides side--side comparison differences reference:","code":"# Compare the three batches we created earlier comparison <- measure_sec_compare(   batch1, batch2, batch3,   samples = c(\"Batch 001\", \"Batch 002\", \"Batch 003\"),   metrics = \"mw_averages\",   plot = FALSE )  print(comparison) #> SEC Multi-Sample Comparison #> ============================================================  #> Samples: 3  #> Reference: Batch 001  #>  #> Summary: #> # A tibble: 3 × 5 #>   sample    mw_mn mw_mw mw_mz mw_dispersity #>   <chr>     <dbl> <dbl> <dbl>         <dbl> #> 1 Batch 001 48200 50100 52000          1.04 #> 2 Batch 002 49100 51200 53100          1.04 #> 3 Batch 003 47800 49800 51900          1.04 #>  #> Differences from reference: #> # A tibble: 3 × 9 #>   sample    mw_mn_diff mw_mn_pct mw_mw_diff mw_mw_pct mw_mz_diff mw_mz_pct #>   <chr>          <dbl>     <dbl>      <dbl>     <dbl>      <dbl>     <dbl> #> 1 Batch 001          0       0            0       0            0       0   #> 2 Batch 002        900       1.9       1100       2.2       1100       2.1 #> 3 Batch 003       -400      -0.8       -300      -0.6       -100      -0.2 #> # ℹ 2 more variables: mw_dispersity_diff <dbl>, mw_dispersity_pct <dbl>"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"understanding-the-comparison-output","dir":"Articles","previous_headings":"Comparing Multiple Samples","what":"Understanding the Comparison Output","title":"Exporting Results","text":"comparison object contains: $summary: samples metrics $differences: Absolute percent differences reference $plot: MWD overlay (requested available) $reference: sample reference","code":"# Access individual components comparison$summary      # Metrics for all samples comparison$differences  # Differences from reference comparison$reference    # Reference sample name"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"setting-a-different-reference","dir":"Articles","previous_headings":"Comparing Multiple Samples","what":"Setting a Different Reference","title":"Exporting Results","text":"default, first sample reference. can change :","code":"# Use PS 500K as reference comparison_ref <- measure_sec_compare(   ps100k, ps500k, pmma,   samples = c(\"PS 100K\", \"PS 500K\", \"PMMA High\"),   reference = \"PS 500K\" )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"batch-to-batch-comparison","dir":"Articles","previous_headings":"Comparing Multiple Samples","what":"Batch-to-Batch Comparison","title":"Exporting Results","text":"common use case comparing production batches reference lot:","code":"# Compare production batches batch_comparison <- measure_sec_compare(   reference_lot,   batch_001,   batch_002,   batch_003,   samples = c(\"Reference\", \"Batch 001\", \"Batch 002\", \"Batch 003\"),   reference = \"Reference\" )  # Check for significant deviations batch_comparison$differences |>   filter(abs(mw_mw_pct) > 5)  # Flag batches > 5% different"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"available-templates","dir":"Articles","previous_headings":"Automated Reports","what":"Available Templates","title":"Exporting Results","text":"","code":"# See available report templates list_sec_templates() #> # A tibble: 3 × 3 #>   template description                                         formats         #>   <chr>    <chr>                                               <chr>           #> 1 standard Summary table, chromatogram, and MWD plot           html, pdf, docx #> 2 detailed All plots, multi-detector view, optional slice data html, pdf, docx #> 3 qc       System suitability with pass/fail metrics           html, pdf, docx"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"standard-report","dir":"Articles","previous_headings":"Automated Reports","what":"Standard Report","title":"Exporting Results","text":"standard template includes: - Summary table MW averages - Chromatogram overlay - Molecular weight distribution plot","code":"# Generate HTML report measure_sec_report(   processed,   template = \"standard\",   output_format = \"html\",   title = \"Polymer SEC Analysis\",   author = \"Lab Analyst\" )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"detailed-report","dir":"Articles","previous_headings":"Automated Reports","what":"Detailed Report","title":"Exporting Results","text":"comprehensive documentation:","code":"measure_sec_report(   processed,   template = \"detailed\",   output_format = \"pdf\",   title = \"Comprehensive SEC Report\",   sample_id = \"sample_id\",   include_slice_table = TRUE  # Append raw data )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"qc-report","dir":"Articles","previous_headings":"Automated Reports","what":"QC Report","title":"Exporting Results","text":"system suitability testing:","code":"measure_sec_report(   sst_data,   template = \"qc\",   output_format = \"html\",   specs = list(     plate_count_min = 10000,     asymmetry_min = 0.8,     asymmetry_max = 1.5,     resolution_min = 1.5   ) )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"saving-reports-to-specific-locations","dir":"Articles","previous_headings":"Automated Reports","what":"Saving Reports to Specific Locations","title":"Exporting Results","text":"","code":"# Save to a specific path measure_sec_report(   processed,   template = \"standard\",   output_file = \"reports/polymer_analysis_2024-01-15.html\",   open = FALSE  # Don't open automatically )"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"export-to-excel","dir":"Articles","previous_headings":"Integration with Other Tools","what":"Export to Excel","title":"Exporting Results","text":"spreadsheet-based workflows:","code":"# Requires writexl package library(writexl)  # Create a workbook with multiple sheets write_xlsx(   list(     \"Summary\" = summary_tbl,     \"Slice Data\" = slices_long   ),   \"sec_results.xlsx\" )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"export-to-database","dir":"Articles","previous_headings":"Integration with Other Tools","what":"Export to Database","title":"Exporting Results","text":"LIMS integration:","code":"# Using DBI for database connection library(DBI)  con <- dbConnect(RSQLite::SQLite(), \"lims.db\")  # Write summary to database dbWriteTable(con, \"sec_results\", summary_tbl, append = TRUE)  dbDisconnect(con)"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"export-for-graphpad-prism","dir":"Articles","previous_headings":"Integration with Other Tools","what":"Export for GraphPad Prism","title":"Exporting Results","text":"Prism prefers wide format specific column arrangements:","code":"# Create Prism-friendly format prism_data <- slices_long |>   select(location, sample_id, value) |>   tidyr::pivot_wider(names_from = sample_id, values_from = value)  write.csv(prism_data, \"sec_for_prism.csv\", row.names = FALSE)"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"export-for-python-analysis","dir":"Articles","previous_headings":"Integration with Other Tools","what":"Export for Python Analysis","title":"Exporting Results","text":"interoperability Python workflows:","code":"# Save as feather for fast Python loading arrow::write_feather(slices_long, \"sec_data.feather\")  # Or as parquet for columnar storage arrow::write_parquet(slices_long, \"sec_data.parquet\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"traceability","dir":"Articles","previous_headings":"Best Practices","what":"Traceability","title":"Exporting Results","text":"Always include metadata regulatory compliance:","code":"# Add audit trail information summary_with_audit <- summary_tbl |>   mutate(     analysis_date = Sys.Date(),     analyst = \"JW\",     instrument = \"Agilent 1260\",     column = \"PLgel Mixed-C\",     software_version = packageVersion(\"measure.sec\")   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"file-naming-conventions","dir":"Articles","previous_headings":"Best Practices","what":"File Naming Conventions","title":"Exporting Results","text":"Use descriptive, consistent file names:","code":"# Good: includes key information \"sec_summary_batch123_2024-01-15.xlsx\" \"mwd_comparison_stability_t12m.pdf\"  # Avoid: ambiguous names \"results.xlsx\" \"output.csv\""},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"version-control-for-reports","dir":"Articles","previous_headings":"Best Practices","what":"Version Control for Reports","title":"Exporting Results","text":"Save report parameters reproducibility:","code":"# Save analysis parameters alongside results analysis_params <- list(   date = Sys.time(),   calibration = \"ps_2024-01.rds\",   baseline_method = \"linear\",   integration_limits = c(8, 18),   package_version = packageVersion(\"measure.sec\") )  saveRDS(analysis_params, \"sec_analysis_params.rds\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"missing-columns-in-summary","dir":"Articles","previous_headings":"Troubleshooting","what":"Missing Columns in Summary","title":"Exporting Results","text":"MW columns missing summary table, check ’ve run calibration MW averaging steps:","code":"# Ensure you have MW data names(processed)  # Should include Mn, Mw, Mz, or mw_mn, mw_mw, mw_mz"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"empty-slice-tables","dir":"Articles","previous_headings":"Troubleshooting","what":"Empty Slice Tables","title":"Exporting Results","text":"measure_sec_slice_table() returns data:","code":"# Check that measure columns exist find_measure_cols <- function(data) {   names(data)[vapply(data, inherits, logical(1), \"measure_list\")] } find_measure_cols(processed)"},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"report-generation-fails","dir":"Articles","previous_headings":"Troubleshooting","what":"Report Generation Fails","title":"Exporting Results","text":"measure_sec_report() fails: Verify Quarto installed: quarto::quarto_version() PDF output, ensure LaTeX installed Check data required columns","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Exporting Results","text":"Getting Started - Basic SEC workflow concepts Calibration Management - Save reuse calibrations System Suitability - QC metrics column performance Comprehensive SEC Analysis - Complete reference functions","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/exporting-results.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Exporting Results","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      utf8_1.2.6          survival_3.8-3      #> [49] future.apply_1.20.1 withr_3.0.2         scales_1.4.0        #> [52] lubridate_1.9.4     timechange_0.3.0    rmarkdown_2.30      #> [55] globals_0.18.0      nnet_7.3-20         timeDate_4051.111   #> [58] ragg_1.5.0          evaluate_1.0.5      knitr_1.51          #> [61] hardhat_1.4.2       rlang_1.1.6         Rcpp_1.1.0          #> [64] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [67] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"what-youll-learn","dir":"Articles","previous_headings":"","what":"What You’ll Learn","title":"Getting Started with measure.sec","text":"end tutorial, able : Load convert SEC chromatogram data measure format Build recipe processes detector signals Apply calibration convert retention time molecular weight Calculate MW averages (Mn, Mw, Mz, dispersity) Time complete: ~15 minutes","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Getting Started with measure.sec","text":"starting, : - Basic R knowledge (data frames, pipes, functions) - R RStudio installed - prior SEC/GPC knowledge required (’ll cover basics)","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Getting Started with measure.sec","text":"measure.sec provides preprocessing steps Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC) data analysis. extends measure package using recipes framework.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"what-is-secgpc","dir":"Articles","previous_headings":"","what":"What is SEC/GPC?","title":"Getting Started with measure.sec","text":"Size Exclusion Chromatography (SEC), also known Gel Permeation Chromatography (GPC), separates molecules size. Larger molecules elute faster (excluded pores), smaller molecules elute slower (enter pores). lets determine molecular weight averages (Mn, Mw, Mz) dispersity (distribution breadth). SEC data consists chromatograms (detector response vs. elution time). Common detectors include RI (concentration), UV (chromophores), light scattering (absolute MW). package processes signals extract molecular weight information.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"workflow-overview","dir":"Articles","previous_headings":"","what":"Workflow Overview","title":"Getting Started with measure.sec","text":"typical SEC analysis workflow follows steps: measure.sec, box becomes one recipe steps. chain steps together reproducible analysis pipeline.","code":"┌─────────────────────────────────────────────────────────────────────────┐ │                        SEC Analysis Workflow                            │ └─────────────────────────────────────────────────────────────────────────┘    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐   │   Raw Data   │────▶│ Preprocess   │────▶│  Calibrate   │   │ (CSV/Export) │     │  Signals     │     │   MW Scale   │   └──────────────┘     └──────────────┘     └──────────────┘          │                    │                    │          │                    │                    │          ▼                    ▼                    ▼    • Detector signals   • Baseline correct  • Apply standards    • Elution times      • Align detectors   • Or use MALS for    • Sample metadata    • Convert units       absolute MW                                                    │                                                    ▼                         ┌──────────────────────────────────────┐                         │          Calculate Results           │                         │  • MW averages (Mn, Mw, Mz)         │                         │  • Dispersity                        │                         │  • MW distribution                   │                         │  • Aggregate/fragment %              │                         └──────────────────────────────────────┘"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"basic-workflow-overview","dir":"Articles","previous_headings":"Workflow Overview","what":"Basic Workflow Overview","title":"Getting Started with measure.sec","text":"typical SEC analysis starts raw detector signals, converts measure format, applies baseline correction, processes detector signals appropriate normalization factors, either applies calibration standards (conventional) uses light scattering absolute molecular weight (MALS). Choose conventional calibration narrow MW standards polymer type. Choose MALS need absolute MW without polymer-specific standards analyzing unknown polymers.","code":"flowchart TD     A[Raw Chromatogram<br>RI, UV, MALS signals] --> B[step_measure_input_long<br>Convert to measure format]     B --> C[step_sec_baseline<br>Baseline correction]     C --> D[step_sec_ri / step_sec_uv<br>Detector processing with dn/dc or ε]     D --> E{Calibration<br>method?}     E -->|\"Standards available<br>(same polymer type)\"| F[step_sec_conventional_cal<br>Polynomial fit to standards]     E -->|\"MALS detector<br>(absolute MW needed)\"| G[step_sec_mals<br>Angular extrapolation<br>Zimm/Debye/Berry]     F --> H[step_sec_mw_averages<br>Calculate Mn, Mw, Mz]     G --> I[Absolute MW & Rg<br>directly from MALS]     H --> J[Results<br>MW averages, distributions, plots]     I --> J      style A fill:#e1f5fe     style J fill:#c8e6c9"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with measure.sec","text":"","code":"# Install from GitHub # install.packages(\"pak\") pak::pak(\"JamesHWade/measure\") pak::pak(\"JamesHWade/measure-sec\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Getting Started with measure.sec","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"the-data-model","dir":"Articles","previous_headings":"","what":"The Data Model","title":"Getting Started with measure.sec","text":"SEC data measure.sec uses measure package’s nested tibble structure. Understanding structure key working effectively package.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"measure_tbl-a-single-chromatogram","dir":"Articles","previous_headings":"The Data Model","what":"measure_tbl: A Single Chromatogram","title":"Getting Started with measure.sec","text":"measure_tbl tibble (data frame) representing single chromatogram two required columns: location: x-axis values—typically elution time (minutes) elution volume (mL) value: y-axis values—detector response (mV, AU, processed units) Think one line chromatogram plot. example, RI detector signal one injection stored measure_tbl.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"measure_list-multiple-chromatograms-internal-format","dir":"Articles","previous_headings":"The Data Model","what":"measure_list: Multiple Chromatograms (Internal Format)","title":"Getting Started with measure.sec","text":"measure_list list column containing multiple measure_tbl objects. internal format used measure.sec recipe steps—typically won’t create . Instead, step_measure_input_long() converts raw data format automatically. conversion, data look like : nested structure several advantages: Tidy organization: row one sample metadata chromatogram(s) Batch processing: Apply recipe many samples Multiple detectors: Store RI, UV, MALS signals separate nested columns Metadata preservation: Sample properties like dn_dc known_mw travel chromatogram","code":"┌──────────────────────────────────────────────────────────────┐ │  sample_id   known_mw   dn_dc       ri                      │ ├──────────────────────────────────────────────────────────────┤ │  \"PS-50K\"    50000      0.185       <measure_list[1]>       │ │  \"PS-100K\"   100000     0.185       <measure_list[1]>       │ │  \"PMMA-75K\"  75000      0.084       <measure_list[1]>       │ └──────────────────────────────────────────────────────────────┘                                            │                                            ▼                             Each entry contains a measure_tbl:                               location │ value                               ─────────┼────────                               5.0      │ 0.002                               5.1      │ 0.015                               5.2      │ 0.089                               ...      │ ..."},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Getting Started with measure.sec","text":"package includes sec_triple_detect, synthetic multi-detector SEC dataset long format (one row per time point). good starting point learning workflow analyzing data. dataset contains: 12 polymer samples: polystyrene (PS), PMMA, PEG, copolymers ~2,000 time points per sample: giving 24,012 total rows Three detector signals: RI, UV, MALS (numeric columns) Known molecular weights: validating analysis Optical constants: dn/dc extinction coefficients (needed quantitative analysis)","code":"# Load the example dataset data(sec_triple_detect, package = \"measure.sec\")  # View the structure - this is LONG format data (one row per time point) # The signal columns (ri_signal, uv_signal, mals_signal) are numeric vectors glimpse(sec_triple_detect) #> Rows: 24,012 #> Columns: 11 #> $ sample_id        <chr> \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\",… #> $ sample_type      <chr> \"standard\", \"standard\", \"standard\", \"standard\", \"stan… #> $ polymer_type     <chr> \"polystyrene\", \"polystyrene\", \"polystyrene\", \"polysty… #> $ elution_time     <dbl> 5.00, 5.01, 5.02, 5.03, 5.04, 5.05, 5.06, 5.07, 5.08,… #> $ ri_signal        <dbl> 6.926392e-04, 0.000000e+00, 3.199253e-04, 4.197175e-0… #> $ uv_signal        <dbl> 0.0002034583, 0.0000000000, 0.0000000000, 0.000000000… #> $ mals_signal      <dbl> 3.370385e-05, 3.483481e-05, 3.102092e-05, 3.261962e-0… #> $ known_mw         <dbl> 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,… #> $ known_dispersity <dbl> 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05,… #> $ dn_dc            <dbl> 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.18… #> $ extinction_coef  <dbl> 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2… # View the unique samples in the dataset # Each sample_id represents one injection; the chromatogram spans many rows sec_triple_detect |>   distinct(sample_id, sample_type, polymer_type) |>   print(n = 12) #> # A tibble: 12 × 3 #>    sample_id sample_type polymer_type #>    <chr>     <chr>       <chr>        #>  1 PS-1K     standard    polystyrene  #>  2 PS-10K    standard    polystyrene  #>  3 PS-50K    standard    polystyrene  #>  4 PS-100K   standard    polystyrene  #>  5 PS-500K   standard    polystyrene  #>  6 PMMA-Low  sample      pmma         #>  7 PMMA-Med  sample      pmma         #>  8 PMMA-High sample      pmma         #>  9 PEG-5K    sample      peg          #> 10 PEG-20K   sample      peg          #> 11 Copoly-A  sample      copolymer    #> 12 Copoly-B  sample      copolymer"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"basic-workflow-ri-detector-analysis","dir":"Articles","previous_headings":"","what":"Basic Workflow: RI Detector Analysis","title":"Getting Started with measure.sec","text":"Let’s walk complete analysis polystyrene sample using RI detector. demonstrates core pattern ’ll use SEC analysis.","code":"# Select a single polystyrene standard for this example # In practice, you'd often process many samples at once ps_sample <- sec_triple_detect |>   filter(sample_id == \"PS-50K\")  # View sample info - note this is still long format (many rows per sample) ps_sample |>   select(sample_id, polymer_type, known_mw, elution_time, ri_signal) |>   head() #> # A tibble: 6 × 5 #>   sample_id polymer_type known_mw elution_time ri_signal #>   <chr>     <chr>           <dbl>        <dbl>     <dbl> #> 1 PS-50K    polystyrene     50000         5     0        #> 2 PS-50K    polystyrene     50000         5.01  0.000279 #> 3 PS-50K    polystyrene     50000         5.02  0        #> 4 PS-50K    polystyrene     50000         5.03  0        #> 5 PS-50K    polystyrene     50000         5.04  0.000842 #> 6 PS-50K    polystyrene     50000         5.05  0.000483"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"step-1-create-a-recipe","dir":"Articles","previous_headings":"Basic Workflow: RI Detector Analysis","what":"Step 1: Create a Recipe","title":"Getting Started with measure.sec","text":"Recipes define sequence preprocessing steps. Think recipe blueprint analysis—describes , doesn’t yet. separation lets define workflow apply many samples.","code":"# Start a recipe with your data # The formula specifies: predictor columns ~ grouping column # sample_id identifies which rows belong to each chromatogram rec <- recipe(   ri_signal + elution_time + dn_dc ~ sample_id,   data = ps_sample ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert the ri_signal column to measure format   # This step tells recipes how to interpret your chromatogram data   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"step-2-add-preprocessing-steps","dir":"Articles","previous_headings":"Basic Workflow: RI Detector Analysis","what":"Step 2: Add Preprocessing Steps","title":"Getting Started with measure.sec","text":"Chain additional steps using pipe (|>). step transforms data sequence:","code":"rec <- recipe(   ri_signal + elution_time + dn_dc ~ sample_id,   data = ps_sample ) |>   update_role(sample_id, new_role = \"id\") |>   # First: convert raw signal to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   # Second: correct the baseline (removes drift and offset)   step_sec_baseline(measures = \"ri\") |>   # Third: process RI signal using the sample's dn/dc value   # Dividing by dn/dc converts the RI signal to concentration-proportional units   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"step-3-prep-and-bake","dir":"Articles","previous_headings":"Basic Workflow: RI Detector Analysis","what":"Step 3: Prep and Bake","title":"Getting Started with measure.sec","text":"Two functions execute recipe: prep(): Learns required parameters training data (like baseline fit coefficients) bake(): Applies transformations produce results two steps? design lets prep training data (like calibration standards), bake new samples without re-learning parameters. also makes analysis reproducible. ✓ Checkpoint: ’ve successfully converted raw detector data measure format applied baseline correction. result tibble now contains processed ri column ready calibration.","code":"# Prep: Learn parameters from the data prepped <- prep(rec)  # Bake: Apply transformations (new_data = NULL means use the training data) result <- bake(prepped, new_data = NULL)  # View the processed data - ri now contains the baseline-corrected, # concentration-converted chromatogram result |>   select(sample_id, ri) #> # A tibble: 1 × 2 #>   sample_id          ri #>   <chr>          <meas> #> 1 PS-50K    [2,001 × 2]"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"molecular-weight-averages","dir":"Articles","previous_headings":"","what":"Molecular Weight Averages","title":"Getting Started with measure.sec","text":"common outputs SEC analysis molecular weight averages: - Mn (number-average): Emphasizes lower MW species - Mw (weight-average): Emphasizes higher MW species - Mz (z-average): Even sensitive high MW species - Dispersity (Mw/Mn): Measures breadth MW distribution (1.0 = monodisperse) Use step_sec_mw_averages() calculate . step requires x-axis (location) values already represent log₁₀(MW)—step_sec_conventional_cal() provides. See Calibration section complete workflow.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"calibration-curves","dir":"Articles","previous_headings":"","what":"Calibration Curves","title":"Getting Started with measure.sec","text":"SEC analysis requires calibration convert retention time molecular weight. common approach uses narrow standards—polymers known molecular weights low dispersity—build calibration curve. Note: light scattering detector (MALS), can determine absolute molecular weights without calibration. See vignette(\"triple-detection\") details.  Apply calibration using step_sec_conventional_cal(): Important: Conventional calibration assumes sample similar hydrodynamic behavior standards. Polystyrene standards work well flexible polymers THF, proteins aqueous SEC, use protein standards light scattering. ✓ Checkpoint: ’ve completed full SEC analysis! result_cal tibble contains molecular weight averages (Mn, Mw, Mz) dispersity calculated chromatogram using conventional calibration.","code":"# Load polystyrene narrow standards # These are well-characterized polymers used to build the calibration curve data(sec_ps_standards, package = \"measure.sec\")  # View the standards - each has a known peak molecular weight (Mp) sec_ps_standards |>   select(standard_name, mp, log_mp, retention_time) |>   print(n = 8) #> # A tibble: 16 × 4 #>   standard_name      mp log_mp retention_time #>   <chr>           <dbl>  <dbl>          <dbl> #> 1 PS-3150000    3150000   6.50           11.2 #> 2 PS-1870000    1870000   6.27           11.6 #> 3 PS-1090000    1090000   6.04           12.1 #> 4 PS-630000      630000   5.80           12.6 #> 5 PS-430000      430000   5.63           13.2 #> 6 PS-216000      216000   5.33           13.8 #> 7 PS-120000      120000   5.08           14.3 #> 8 PS-67500        67500   4.83           15.0 #> # ℹ 8 more rows  # Visualize the calibration curve # The relationship between log(MW) and retention time is typically linear # or slightly curved, so we fit a polynomial ggplot(sec_ps_standards, aes(retention_time, log_mp)) +   geom_point(size = 3, color = \"#2E86AB\") +   geom_smooth(     method = \"lm\",     formula = y ~ poly(x, 3),     se = TRUE,     color = \"#A23B72\",     fill = \"#A23B72\",     alpha = 0.2   ) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     title = \"Polystyrene Calibration Curve\"   ) +   theme_minimal() # Prepare standards in the format expected by the calibration step # Needs columns: retention (time/volume) and log_mw ps_cal <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  rec_cal <- recipe(   ri_signal + elution_time + dn_dc ~ sample_id,   data = ps_sample ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   # Apply conventional calibration using polystyrene standards   # This converts retention time to log10(MW) on the x-axis   # fit_type options: \"linear\", \"quadratic\", \"cubic\" (most common)   step_sec_conventional_cal(     standards = ps_cal,     fit_type = \"cubic\"   ) |>   # Calculate MW averages from the calibrated chromatogram   # The calibration step converted location values to log10(MW)   step_sec_mw_averages()  prepped_cal <- prep(rec_cal) #> Warning: Standard at 12.58 has 14.4% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 1037 points (51.8%) are outside calibration range. #> ℹ Calibration range: 11.15 to 20.79 result_cal <- bake(prepped_cal, new_data = NULL)  # View molecular weight results # New columns are added with mw_ prefix result_cal |>   select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity) #> # A tibble: 1 × 5 #>   sample_id      mw_mn   mw_mw   mw_mz mw_dispersity #>   <chr>          <dbl>   <dbl>   <dbl>         <dbl> #> 1 PS-50K    419927756. 8.24e21 7.81e23       1.96e13"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"available-steps","dir":"Articles","previous_headings":"","what":"Available Steps","title":"Getting Started with measure.sec","text":"package provides comprehensive set recipe steps. ’s quick reference organized function:","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"preprocessing","dir":"Articles","previous_headings":"Available Steps","what":"Preprocessing","title":"Getting Started with measure.sec","text":"step_sec_baseline(): SEC-optimized baseline correction step_sec_detector_delay(): Correct inter-detector delays","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"detector-processing","dir":"Articles","previous_headings":"Available Steps","what":"Detector Processing","title":"Getting Started with measure.sec","text":"step_sec_ri(): RI detector dn/dc step_sec_uv(): UV detector extinction coefficient step_sec_mals(), step_sec_lals(), step_sec_rals(): Light scattering step_sec_dls(): Dynamic light scattering step_sec_viscometer(): Differential viscometer","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"molecular-weight","dir":"Articles","previous_headings":"Available Steps","what":"Molecular Weight","title":"Getting Started with measure.sec","text":"step_sec_mw_averages(): Mn, Mw, Mz, dispersity step_sec_mw_fractions(): MW fractions /cutoffs step_sec_mw_distribution(): Differential/cumulative MWD step_sec_conventional_cal(): Narrow standard calibration step_sec_universal_cal(): Universal calibration","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"composition-protein","dir":"Articles","previous_headings":"Available Steps","what":"Composition & Protein","title":"Getting Started with measure.sec","text":"step_sec_uv_ri_ratio(): UV/RI ratio heterogeneity step_sec_composition(): Copolymer composition step_sec_aggregates(): HMWS/monomer/LMWS quantitation step_sec_protein(): Complete protein SEC workflow","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"troubleshooting","dir":"Articles","previous_headings":"","what":"Troubleshooting","title":"Getting Started with measure.sec","text":"Common issues quick fixes:","code":"# Debugging tips: names(your_data)                    # Check column names measure::find_measure_cols(result)  # Find measure columns after bake result$ri[[1]] |> summary()         # Inspect chromatogram data"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with measure.sec","text":"Now understand basics, explore vignettes specialized workflows: can also browse available functions :","code":"# See all SEC/GPC steps registered with measure measure::measure_steps(techniques = \"SEC/GPC\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/getting-started.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Getting Started with measure.sec","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] nlme_3.1-168        parallelly_1.46.1   lava_1.8.2          #> [37] tidyselect_1.2.1    digest_0.6.39       future_1.68.0       #> [40] purrr_1.2.0         listenv_0.10.0      labeling_0.4.3      #> [43] splines_4.5.2       fastmap_1.2.0       grid_4.5.2          #> [46] cli_3.6.5           magrittr_2.0.4      utf8_1.2.6          #> [49] survival_3.8-3      future.apply_1.20.1 withr_3.0.2         #> [52] scales_1.4.0        lubridate_1.9.4     timechange_0.3.0    #> [55] rmarkdown_2.30      globals_0.18.0      nnet_7.3-20         #> [58] timeDate_4051.111   ragg_1.5.0          evaluate_1.0.5      #> [61] knitr_1.51          hardhat_1.4.2       mgcv_1.9-3          #> [64] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [67] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [70] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Single-Angle Light Scattering: LALS and RALS","text":"Single-angle light scattering detectors (LALS RALS) provide simpler, cost-effective alternative multi-angle detection (MALS) determining absolute molecular weight. don’t provide radius gyration (Rg) information, can excellent choices routine analysis smaller molecules. vignette covers: LALS (Low-Angle Light Scattering) principles usage RALS (Right-Angle Light Scattering) principles usage choose technique Comparison MALS","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Single-Angle Light Scattering: LALS and RALS","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"the-angular-dependence-problem","dir":"Articles","previous_headings":"","what":"The Angular Dependence Problem","title":"Single-Angle Light Scattering: LALS and RALS","text":"Light scattering polymer molecules angle-dependent. larger molecules, scattered intensity varies detection angle due intramolecular interference. described particle scattering function P(θ):  Key insight: low angles (approaching 0°), P(θ) → 1 regardless particle size. LALS can measure MW without knowing Rg.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"principle","dir":"Articles","previous_headings":"LALS: Low-Angle Light Scattering","what":"Principle","title":"Single-Angle Light Scattering: LALS and RALS","text":"LALS detectors measure scattering low angle (typically 7-15°). angles, particle scattering function P(θ) ≈ 1 polymer sizes, eliminating need angular extrapolation. simplified equation becomes: Mw=R(θ)K⋅cM_w = \\frac{R(\\theta)}{K \\cdot c} : - R(θ) = Rayleigh ratio (scattered intensity) - K = optical constant - c = concentration","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"when-to-use-lals","dir":"Articles","previous_headings":"LALS: Low-Angle Light Scattering","what":"When to Use LALS","title":"Single-Angle Light Scattering: LALS and RALS","text":"Best : - Proteins peptides (Rg < 10 nm) - Small synthetic polymers - Routine screening applications - Rg needed","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"lals-workflow","dir":"Articles","previous_headings":"LALS: Low-Angle Light Scattering","what":"LALS Workflow","title":"Single-Angle Light Scattering: LALS and RALS","text":"","code":"# LALS workflow example # Note: Requires LALS detector data  # Simulate sample data structure lals_samples <- tibble(   sample_id = \"Protein-A\",   ri_signal = list(c(0.1, 0.5, 1.0, 0.5, 0.1)),   lals_signal = list(c(0.05, 0.25, 0.5, 0.25, 0.05)),   elution_time = list(c(8, 9, 10, 11, 12)),   dn_dc = 0.185 )  rec_lals <- recipe(   ri_signal + lals_signal + elution_time + dn_dc ~ sample_id,   data = lals_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert signals to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(lals_signal, location = vars(elution_time), col_name = \"lals\") |>   # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"lals\")) |>   # Process RI for concentration   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>   # Process LALS for MW   step_sec_lals(     measures = \"lals\",     concentration_col = \"ri\",     angle = 7,                        # Detection angle     laser_wavelength = 670,           # nm     dn_dc = 0.185,                    # mL/g     solvent_ri = 1.333,               # Water     calibration_constant = 1.5e-5     # From instrument calibration   )  prepped_lals <- prep(rec_lals) result_lals <- bake(prepped_lals, new_data = NULL)"},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"principle-1","dir":"Articles","previous_headings":"RALS: Right-Angle Light Scattering","what":"Principle","title":"Single-Angle Light Scattering: LALS and RALS","text":"RALS detectors measure scattering 90°. angle shows angular dependence low angles, offers practical advantages: less sensitivity stray light easier optical design. small molecules Rg << λ/20 (roughly Rg < 15 nm 670 nm), angular dependence minimal RALS provides reasonable MW estimates.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"when-to-use-rals","dir":"Articles","previous_headings":"RALS: Right-Angle Light Scattering","what":"When to Use RALS","title":"Single-Angle Light Scattering: LALS and RALS","text":"Best : - Small molecules (Rg < 15 nm) - Quality control screening - Cost-sensitive applications - combined detectors","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"rals-workflow","dir":"Articles","previous_headings":"RALS: Right-Angle Light Scattering","what":"RALS Workflow","title":"Single-Angle Light Scattering: LALS and RALS","text":"","code":"# RALS workflow example # Note: Requires RALS detector data  # Simulate sample data structure rals_samples <- tibble(   sample_id = \"Polymer-X\",   ri_signal = list(c(0.1, 0.5, 1.0, 0.5, 0.1)),   rals_signal = list(c(0.04, 0.20, 0.40, 0.20, 0.04)),   elution_time = list(c(8, 9, 10, 11, 12)),   dn_dc = 0.185 )  rec_rals <- recipe(   ri_signal + rals_signal + elution_time + dn_dc ~ sample_id,   data = rals_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert signals to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(rals_signal, location = vars(elution_time), col_name = \"rals\") |>   # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"rals\")) |>   # Process RI for concentration   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>   # Process RALS for MW   step_sec_rals(     measures = \"rals\",     concentration_col = \"ri\",     angle = 90,                       # Right angle     laser_wavelength = 670,           # nm     dn_dc = 0.185,                    # mL/g     solvent_ri = 1.333,               # Water     calibration_constant = 1.2e-5     # From instrument calibration   )  prepped_rals <- prep(rec_rals) result_rals <- bake(prepped_rals, new_data = NULL)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"combining-lalsrals-with-mals","dir":"Articles","previous_headings":"","what":"Combining LALS/RALS with MALS","title":"Single-Angle Light Scattering: LALS and RALS","text":"instruments include low-angle right-angle detectors alongside MALS. provides: Redundancy: Cross-check MW values Extended range: LALS low angles, MALS extrapolation Sensitivity optimization: Use optimal detector MW range","code":"# Combined LALS + RALS + MALS workflow rec_combined <- recipe(   ri_signal + lals_signal + rals_signal + mals_signal + elution_time + dn_dc ~ sample_id,   data = multi_detector_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Input all detectors   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(lals_signal, location = vars(elution_time), col_name = \"lals\") |>   step_measure_input_long(rals_signal, location = vars(elution_time), col_name = \"rals\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   # Baseline and concentration   step_sec_baseline(measures = c(\"ri\", \"lals\", \"rals\", \"mals\")) |>   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>   # Process each LS detector   step_sec_lals(measures = \"lals\", concentration_col = \"ri\", dn_dc = 0.185) |>   step_sec_rals(measures = \"rals\", concentration_col = \"ri\", dn_dc = 0.185) |>   step_sec_mals(mals_col = \"mals\", dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"calibration-constants","dir":"Articles","previous_headings":"","what":"Calibration Constants","title":"Single-Angle Light Scattering: LALS and RALS","text":"step_sec_lals() step_sec_rals() require calibration_constant absolute MW values. Without , results relative units.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"determining-calibration-constants","dir":"Articles","previous_headings":"Calibration Constants","what":"Determining Calibration Constants","title":"Single-Angle Light Scattering: LALS and RALS","text":"Use well-characterized standard (e.g., BSA, narrow PS standard) Run standard experimental conditions Calculate constant yields known MW","code":"# Example: Calibrating with BSA (MW = 66,430 Da) # 1. Measure BSA with known concentration # 2. Calculate: cal_constant = (known_MW * K * c) / raw_signal  bsa_mw <- 66430  # Da bsa_conc <- 1.0  # mg/mL dn_dc_bsa <- 0.185 solvent_ri <- 1.333 wavelength <- 670  # Calculate K K <- 4 * pi^2 * solvent_ri^2 * dn_dc_bsa^2 / (6.022e23 * (wavelength * 1e-7)^4)  # If raw_signal at peak = 0.5, then: # cal_constant = bsa_mw * K * bsa_conc / raw_signal"},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"signal-to-noise-considerations","dir":"Articles","previous_headings":"Troubleshooting","what":"Signal-to-Noise Considerations","title":"Single-Angle Light Scattering: LALS and RALS","text":"Single-angle detectors sensitive noise MALS (averages multiple angles). Ensure: Adequate sample concentration Clean mobile phase (filtered, degassed) Stable flow rate Regular calibration","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Single-Angle Light Scattering: LALS and RALS","text":"MALS Detection - Multi-angle detection Rg large molecules Triple Detection - Combined RI + Viscometer + LS workflows Getting Started - Basic SEC workflow concepts Calibration Management - Save reuse calibrations","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/lals-rals-detection.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Single-Angle Light Scattering: LALS and RALS","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [64] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [67] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Multi-Angle Light Scattering (MALS) powerful technique provides absolute molecular weight without calibration standards. Unlike conventional calibration (gives MW relative polymer standards), MALS measures actual molecular weight sample based fundamental light scattering physics. vignette covers: MALS measures absolute molecular weight Key parameters: dn/dc, wavelength, angles Zimm, Debye, Berry formalisms Radius gyration (Rg) angular dependence Practical workflows step_sec_mals()","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"the-light-scattering-principle","dir":"Articles","previous_headings":"How MALS Works","what":"The Light Scattering Principle","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"light passes polymer solution, molecules scatter light directions. intensity scattered light depends : Molecular weight: Larger molecules scatter light Concentration: molecules = scattering Scattering angle: Angular dependence reveals molecular size fundamental relationship Rayleigh-Debye equation: KcR(θ)=1Mw⋅P(θ)+2A2c\\frac{Kc}{R(\\theta)} = \\frac{1}{M_w \\cdot P(\\theta)} + 2A_2 c :","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"the-optical-constant-k","dir":"Articles","previous_headings":"How MALS Works","what":"The Optical Constant K","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"optical constant depends experimental setup: K=4π2n02(dn/dc)2NAλ4K = \\frac{4\\pi^2 n_0^2 (dn/dc)^2}{N_A \\lambda^4} : n₀: Solvent refractive index dn/dc: Refractive index increment polymer λ: Laser wavelength Nₐ: Avogadro’s number  Key insight: Accurate dn/dc critical. 10% error dn/dc causes ~20% error MW.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"conventional-calibration-limitations","dir":"Articles","previous_headings":"Why Use MALS?","what":"Conventional Calibration Limitations","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Conventional (relative) calibration significant limitations:  MALS essential : - Analyzing polymers different calibration standards - Studying branched star polymers - Characterizing copolymers - Absolute MW required regulatory submissions","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"why-multiple-angles","dir":"Articles","previous_headings":"Angular Dependence and Rg","what":"Why Multiple Angles?","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Large molecules (Rg > λ/20) scatter light differently different angles. angular dependence reveals radius gyration (Rg) - measure molecular size.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"calculating-rg","dir":"Articles","previous_headings":"Angular Dependence and Rg","what":"Calculating Rg","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Zimm equation, slope Kc/R(θ) vs sin²(θ/2) gives Rg: KcR(θ)=1Mw(1+16π2n023λ2Rg2sin2(θ/2))\\frac{Kc}{R(\\theta)} = \\frac{1}{M_w}\\left(1 + \\frac{16\\pi^2 n_0^2}{3\\lambda^2}R_g^2 \\sin^2(\\theta/2)\\right) y-intercept gives 1/Mw, slope gives Rg².","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"zimm-debye-and-berry","dir":"Articles","previous_headings":"Formalisms for Angular Extrapolation","what":"Zimm, Debye, and Berry","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Three common approaches angular extrapolation:  Choosing formalism: Start Zimm - works polymers Use Berry Zimm plot shows significant curvature Berry essential Rg > 50 nm aggregates","code":"#> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"","code":"data(sec_triple_detect, package = \"measure.sec\")  # Select samples with MALS data mals_samples <- sec_triple_detect |>   filter(sample_type == \"sample\")  glimpse(mals_samples) #> Rows: 14,007 #> Columns: 11 #> $ sample_id        <chr> \"PMMA-Low\", \"PMMA-Low\", \"PMMA-Low\", \"PMMA-Low\", \"PMMA… #> $ sample_type      <chr> \"sample\", \"sample\", \"sample\", \"sample\", \"sample\", \"sa… #> $ polymer_type     <chr> \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma… #> $ elution_time     <dbl> 5.00, 5.01, 5.02, 5.03, 5.04, 5.05, 5.06, 5.07, 5.08,… #> $ ri_signal        <dbl> 2.177879e-04, 0.000000e+00, 2.307149e-04, 1.490633e-0… #> $ uv_signal        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 6.442527e-0… #> $ mals_signal      <dbl> 3.454417e-06, 1.210776e-05, 1.804800e-05, 2.001408e-0… #> $ known_mw         <dbl> 25000, 25000, 25000, 25000, 25000, 25000, 25000, 2500… #> $ known_dispersity <dbl> 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8… #> $ dn_dc            <dbl> 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.08… #> $ extinction_coef  <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1…"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"basic-mals-analysis","dir":"Articles","previous_headings":"MALS Workflow with measure.sec","what":"Basic MALS Analysis","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"","code":"# Complete MALS workflow for absolute MW rec_mals <- recipe(   ri_signal + mals_signal + elution_time + dn_dc ~ sample_id,   data = mals_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert signals to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"mals\")) |>   # Process RI for concentration   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   # Convert RI to concentration   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,       # µL     sample_concentration = 2.0    # mg/mL   ) |>   # MALS processing for absolute MW   step_sec_mals(     mals_col = \"mals\",     dn_dc_column = \"dn_dc\",     wavelength = 658,             # nm (common MALS laser)     solvent_ri = 1.407,           # THF     angles = 90                   # Single angle for this example   )  prepped_mals <- prep(rec_mals) result_mals <- bake(prepped_mals, new_data = NULL)  # View results result_mals |>   select(sample_id, ri, mals, mw_mals) |>   head(3) #> # A tibble: 3 × 4 #>   sample_id          ri        mals     mw_mals #>   <chr>          <meas>      <meas>      <meas> #> 1 PMMA-Low  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 2 PMMA-Med  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 3 PMMA-High [2,001 × 2] [2,001 × 2] [2,001 × 2]"},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"what-is-dndc","dir":"Articles","previous_headings":"The Critical Role of dn/dc","what":"What is dn/dc?","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"refractive index increment (dn/dc) change solution refractive index per unit concentration: dndc=nsolution−nsolventc\\frac{dn}{dc} = \\frac{n_{solution} - n_{solvent}}{c}","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"measuring-dndc","dir":"Articles","previous_headings":"The Critical Role of dn/dc","what":"Measuring dn/dc","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"accurate MALS, measure dn/dc using: Differential refractometer known concentrations Batch-mode measurement (accurate) Online measurement SEC (convenient less accurate) Warning: Using literature dn/dc values can introduce 5-20% error MW.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"setting-up-multi-angle-analysis","dir":"Articles","previous_headings":"Multi-Angle Detection","what":"Setting Up Multi-Angle Analysis","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Rg determination, provide multiple detection angles:","code":"# Multi-angle MALS for MW and Rg step_sec_mals(   mals_col = \"mals\",   dn_dc = 0.185,   wavelength = 658,   solvent_ri = 1.407,   angles = c(35, 50, 75, 90, 105, 120, 145),  # Typical MALS detector angles   formalism = \"zimm\"                           # Try \"berry\" for large particles )"},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"rg-vs-mw-relationship","dir":"Articles","previous_headings":"Conformation Analysis","what":"Rg vs MW Relationship","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"relationship Rg MW reveals polymer conformation: Rg=K⋅MwνR_g = K \\cdot M_w^\\nu ν (scaling exponent) indicates conformation:","code":""},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"signal-to-noise-requirements","dir":"Articles","previous_headings":"Troubleshooting","what":"Signal-to-Noise Requirements","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"MALS requires good signal--noise accurate results: Minimum concentration: 0.5-1 mg/mL polymers Higher low MW: Small molecules scatter less Lower high MW: Large molecules scatter strongly","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"detector-alignment","dir":"Articles","previous_headings":"Troubleshooting","what":"Detector Alignment","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Ensure proper detector alignment: Inter-detector delay - Correct time offset RI MALS Normalization - Calibrate MALS using toluene known standard Angle calibration - Verify detector angles accurate","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"Getting Started - Basic SEC workflow LALS RALS Detection - Simpler light scattering alternatives Multi-Detector SEC - RI + Viscometer + LS workflows System Suitability - QC metrics MALS","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/mals-detection.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Multi-Angle Light Scattering (MALS) for Absolute Molecular Weight","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] nlme_3.1-168        parallelly_1.46.1   lava_1.8.2          #> [37] tidyselect_1.2.1    digest_0.6.39       future_1.68.0       #> [40] purrr_1.2.0         listenv_0.10.0      labeling_0.4.3      #> [43] splines_4.5.2       fastmap_1.2.0       grid_4.5.2          #> [46] cli_3.6.5           magrittr_2.0.4      utf8_1.2.6          #> [49] survival_3.8-3      future.apply_1.20.1 withr_3.0.2         #> [52] scales_1.4.0        lubridate_1.9.4     timechange_0.3.0    #> [55] rmarkdown_2.30      globals_0.18.0      nnet_7.3-20         #> [58] timeDate_4051.111   ragg_1.5.0          evaluate_1.0.5      #> [61] knitr_1.51          hardhat_1.4.2       mgcv_1.9-3          #> [64] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [67] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [70] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Protein SEC Analysis","text":"Size Exclusion Chromatography (SEC) critical analytical technique biopharmaceutical characterization. separates proteins based hydrodynamic size, enabling quantification : High Molecular Weight Species (HMWS): Aggregates, dimers, oligomers Monomer: intended product Low Molecular Weight Species (LMWS): Fragments, degradation products vignette covers: Protein SEC basics Aggregate quantitation workflows Detailed oligomer analysis Regulatory considerations","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"the-unique-demands-of-protein-characterization","dir":"Articles","previous_headings":"Why SEC for Biopharmaceutical Analysis?","what":"The Unique Demands of Protein Characterization","title":"Protein SEC Analysis","text":"Proteins inherently complex small molecules synthetic polymers. fold precise three-dimensional structures, associate quaternary complexes, can aggregate multiple pathways. biopharmaceutical products—monoclonal antibodies, enzymes, vaccines—understanding size distribution species solution critical efficacy safety. SEC become primary analytical technique protein aggregation analysis separates species non-destructively native conditions. Unlike SDS-PAGE (denatures proteins) analytical ultracentrifugation (requires specialized equipment long run times), SEC provides quantitative, reproducible data 30 minutes per sample standard HPLC instrumentation. technique preserves non-covalent interactions, enabling detection reversible irreversible aggregates.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"how-protein-aggregates-form","dir":"Articles","previous_headings":"Why SEC for Biopharmaceutical Analysis?","what":"How Protein Aggregates Form","title":"Protein SEC Analysis","text":"Aggregation refers association protein molecules higher-order species beyond intended quaternary structure. Aggregates can form several mechanisms: Native aggregation: Properly folded monomers associate surface interactions. aggregates often form high concentrations, interfaces (air-water, container surfaces), mechanical stress. Non-native aggregation: Partially unfolded proteins expose hydrophobic regions drive irreversible association. Heat stress, freeze-thaw cycles, oxidation promote unfolding. Covalent aggregation: Disulfide scrambling chemical crosslinks create species persist even denaturing conditions. size aggregates matters: small oligomers (dimers, trimers) may reduced activity, large aggregates (visible subvisible particles) primary concern immunogenicity.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"why-aggregate-monitoring-matters","dir":"Articles","previous_headings":"Why SEC for Biopharmaceutical Analysis?","what":"Why Aggregate Monitoring Matters","title":"Protein SEC Analysis","text":"Regulatory agencies (FDA, EMA, ) require comprehensive aggregate characterization biopharmaceutical approval lot release. focus stems immunogenicity concerns: aggregated proteins can activate immune system, potentially leading anti-drug antibodies reduce efficacy cause adverse reactions. connection aggregation immunogenicity well-established clinical experience: early insulin growth hormone products immunogenicity problems traced aggregation, modern monoclonal antibody products face similar scrutiny. ICH Q6B specifically identifies aggregate content critical quality attribute (CQA), product specifications typically limit high molecular weight species (HMWS) less 5%—tighter limits high-dose frequently administered products. SEC aggregate quantitation common release test biopharmaceuticals precisely fast, robust, directly measures regulators care : distribution species size.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Protein SEC Analysis","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"elution-order","dir":"Articles","previous_headings":"Protein SEC Principles","what":"Elution Order","title":"Protein SEC Analysis","text":"SEC, proteins elute order decreasing size:","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"detection","dir":"Articles","previous_headings":"Protein SEC Principles","what":"Detection","title":"Protein SEC Analysis","text":"Protein SEC typically uses UV detection 280 nm (tryptophan/tyrosine absorbance).","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"using-step_sec_aggregates","dir":"Articles","previous_headings":"Basic Aggregate Quantitation","what":"Using step_sec_aggregates()","title":"Protein SEC Analysis","text":"simple HMWS/monomer/LMWS quantitation:","code":"# Load protein SEC data - mAb samples with reference and stressed conditions data(sec_protein, package = \"measure.sec\")  # Start with the reference sample protein_ref <- sec_protein |>   filter(sample_id == \"mAb-Reference\")  # Aggregate quantitation using tallest peak detection rec_agg <- recipe(   uv_280_signal + elution_time ~ sample_id,   data = protein_ref ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert UV 280 nm signal to measure format   step_measure_input_long(     uv_280_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   # Baseline correction   step_sec_baseline(measures = \"uv\") |>   # Aggregate quantitation - auto-detect monomer peak   step_sec_aggregates(     measures = \"uv\",     method = \"tallest\"   )  prepped_agg <- prep(rec_agg) result_agg <- bake(prepped_agg, new_data = NULL)  # View aggregate results result_agg |>   select(sample_id, purity_hmws, purity_monomer, purity_lmws) #> # A tibble: 1 × 4 #>   sample_id     purity_hmws purity_monomer purity_lmws #>   <chr>               <dbl>          <dbl>       <dbl> #> 1 mAb-Reference       0.681           98.1        1.15"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"manual-peak-boundaries","dir":"Articles","previous_headings":"Basic Aggregate Quantitation","what":"Manual Peak Boundaries","title":"Protein SEC Analysis","text":"precise control integration limits:","code":"# When you know the exact monomer elution window step_sec_aggregates(   measures = \"uv\",   monomer_start = 14.5,  # Monomer peak start (min)   monomer_end = 17.5,    # Monomer peak end (min)   method = \"manual\" )"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"using-step_sec_protein","dir":"Articles","previous_headings":"Complete Protein Workflow","what":"Using step_sec_protein()","title":"Protein SEC Analysis","text":"step_sec_protein() function provides streamlined workflow combining baseline correction, aggregate analysis, optional oligomer detection:","code":"# Analyze all mAb samples with the protein step rec_protein <- recipe(   uv_280_signal + elution_time ~ sample_id,   data = sec_protein ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     uv_280_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   step_sec_protein(     measures = \"uv\",     type = \"native\",     monomer_mw = 150000,        # mAb ~150 kDa     baseline_method = \"linear\"   )  prepped_protein <- prep(rec_protein) result_protein <- bake(prepped_protein, new_data = NULL)  # View results for all samples result_protein |>   select(sample_id, starts_with(\"protein_\")) #> # A tibble: 5 × 12 #>   sample_id       protein_hmws_pct protein_monomer_pct protein_lmws_pct #>   <chr>                      <dbl>               <dbl>            <dbl> #> 1 mAb-Reference              0.680                98.1             1.15 #> 2 mAb-Stressed-1             0.644                98.1             1.18 #> 3 mAb-Stressed-2             0.745                97.9             1.34 #> 4 mAb-Aged                   0.651                98.2             1.10 #> 5 mAb-Freeze-Thaw            0.730                98.0             1.23 #> # ℹ 8 more variables: protein_main_start <dbl>, protein_main_end <dbl>, #> #   protein_monomer_oligo_pct <dbl>, protein_dimer_pct <dbl>, #> #   protein_trimer_pct <dbl>, protein_hmw_oligo_pct <dbl>, #> #   protein_lmw_oligo_pct <dbl>, protein_species_count <int>"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"output-columns","dir":"Articles","previous_headings":"Complete Protein Workflow","what":"Output Columns","title":"Protein SEC Analysis","text":"step_sec_protein() step creates: include_oligomer = TRUE:","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"native-sec","dir":"Articles","previous_headings":"Native vs Denaturing SEC","what":"Native SEC","title":"Protein SEC Analysis","text":"Preserves non-covalent interactions: Use : - Detecting reversible aggregates - Oligomer state assessment - Native quaternary structure","code":"step_sec_protein(   type = \"native\",   monomer_mw = 150000 )"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"denaturing-sec-sds-sec","dir":"Articles","previous_headings":"Native vs Denaturing SEC","what":"Denaturing SEC (SDS-SEC)","title":"Protein SEC Analysis","text":"Disrupts non-covalent interactions: Use : - Covalent aggregate detection - Clipped/truncated species - Heavy/light chain analysis","code":"step_sec_protein(   type = \"denaturing\",   monomer_mw = 150000 )"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"using-step_sec_oligomer","dir":"Articles","previous_headings":"Detailed Oligomer Analysis","what":"Using step_sec_oligomer()","title":"Protein SEC Analysis","text":"control oligomer detection:","code":"# Detailed oligomer analysis with explicit control rec_oligo <- recipe(   uv_280_signal + elution_time ~ sample_id,   data = sec_protein ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     uv_280_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   step_sec_baseline(measures = \"uv\") |>   step_sec_oligomer(     measures = \"uv\",     monomer_mw = 150000,     mw_tolerance = 0.15,     # 15% MW tolerance for species assignment     min_area_pct = 0.1       # Minimum 0.1% to report   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"species-assignment","dir":"Articles","previous_headings":"Detailed Oligomer Analysis","what":"Species Assignment","title":"Protein SEC Analysis","text":"oligomer step identifies species based expected MW:","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"ich-guidelines","dir":"Articles","previous_headings":"Regulatory Considerations","what":"ICH Guidelines","title":"Protein SEC Analysis","text":"Aggregate content critical quality attribute Typical specification: HMWS < 5% Aggregate profiles comparable","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"usp-guidelines","dir":"Articles","previous_headings":"Regulatory Considerations","what":"USP Guidelines","title":"Protein SEC Analysis","text":"USP <129>: Analytical procedures proteins USP <1032>: Design development biological assays","code":""},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"sample-preparation","dir":"Articles","previous_headings":"Best Practices","what":"Sample Preparation","title":"Protein SEC Analysis","text":"Filter samples 0.22 μm injection Minimize time prep analysis Use appropriate buffer (match formulation buffer) Control temperature autosampler storage","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"method-parameters","dir":"Articles","previous_headings":"Best Practices","what":"Method Parameters","title":"Protein SEC Analysis","text":"Column selection: Appropriate exclusion limit aggregates Mobile phase: Typically PBS phosphate buffer Flow rate: 0.5-1.0 mL/min Injection volume: 10-100 μL (depending concentration) Detection: 280 nm (standard) 214 nm (higher sensitivity)","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"integration","dir":"Articles","previous_headings":"Best Practices","what":"Integration","title":"Protein SEC Analysis","text":"Consistent baseline selection across samples integration limits samples study Report detection limit minor species","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"example-comparing-stressed-samples","dir":"Articles","previous_headings":"","what":"Example: Comparing Stressed Samples","title":"Protein SEC Analysis","text":"sec_protein dataset includes samples various stress conditions, simulating stability study:","code":"# Analyze all samples including stressed conditions result_protein |>   select(sample_id, protein_hmws_pct, protein_monomer_pct, protein_lmws_pct) |>   arrange(desc(protein_hmws_pct)) #> # A tibble: 5 × 4 #>   sample_id       protein_hmws_pct protein_monomer_pct protein_lmws_pct #>   <chr>                      <dbl>               <dbl>            <dbl> #> 1 mAb-Stressed-2             0.745                97.9             1.34 #> 2 mAb-Freeze-Thaw            0.730                98.0             1.23 #> 3 mAb-Reference              0.680                98.1             1.15 #> 4 mAb-Aged                   0.651                98.2             1.10 #> 5 mAb-Stressed-1             0.644                98.1             1.18 # Compare aggregate content across conditions library(tidyr)  plot_data <- result_protein |>   select(sample_id, protein_hmws_pct, protein_monomer_pct, protein_lmws_pct) |>   pivot_longer(     cols = starts_with(\"protein_\"),     names_to = \"species\",     values_to = \"percent\"   ) |>   mutate(     species = case_when(       species == \"protein_hmws_pct\" ~ \"HMWS\",       species == \"protein_monomer_pct\" ~ \"Monomer\",       species == \"protein_lmws_pct\" ~ \"LMWS\"     ),     species = factor(species, levels = c(\"HMWS\", \"Monomer\", \"LMWS\"))   )  # Focus on non-monomer species for clarity plot_data |>   filter(species != \"Monomer\") |>   ggplot(aes(x = sample_id, y = percent, fill = species)) +   geom_col(position = \"dodge\") +   geom_hline(yintercept = 5, linetype = \"dashed\", color = \"red\") +   annotate(\"text\", x = 1, y = 5.5, label = \"Typical spec: < 5%\", color = \"red\", hjust = 0) +   scale_fill_manual(values = c(\"HMWS\" = \"#E8751A\", \"LMWS\" = \"#2E86AB\")) +   labs(     x = NULL,     y = \"% of Total\",     fill = \"Species\",     title = \"Aggregate and Fragment Content by Sample\",     subtitle = \"Comparing reference vs stressed mAb samples\"   ) +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Protein SEC Analysis","text":"Getting Started - Basic SEC workflow concepts System Suitability - QC metrics biopharm compliance Multi-Detector SEC - MALS absolute MW determination Exporting Results - Summary tables report generation","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/protein-sec.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Protein SEC Analysis","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] tidyr_1.3.2            ggplot2_4.0.1          measure.sec_0.0.0.9000 #> [4] measure_0.0.1.9002     recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  pillar_1.11.1       pkgdown_2.2.0       #> [28] jquerylib_0.1.4     MASS_7.3-65         cachem_1.1.0        #> [31] gower_1.0.2         rpart_4.1.24        parallelly_1.46.1   #> [34] lava_1.8.2          tidyselect_1.2.1    digest_0.6.39       #> [37] future_1.68.0       purrr_1.2.0         listenv_0.10.0      #> [40] labeling_0.4.3      splines_4.5.2       fastmap_1.2.0       #> [43] grid_4.5.2          cli_3.6.5           magrittr_2.0.4      #> [46] utf8_1.2.6          survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [64] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [67] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Size Exclusion Chromatography (SEC), also known Gel Permeation Chromatography (GPC), fundamental technique characterizing molecular weight distribution polymers, proteins, macromolecules. measure.sec package extends measure package specialized preprocessing steps SEC/GPC data analysis. vignette demonstrates : Process multi-detector SEC data (RI, UV/DAD, MALS, LALS, RALS, DLS) Calculate molecular weight averages distributions Analyze copolymer composition Quantify protein aggregates Perform quality control checks","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(tidyr) library(purrr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"the-measure-sec-data-model","dir":"Articles","previous_headings":"","what":"The measure.sec Data Model","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package uses measure framework, chromatographic signals stored nested tibbles. sample measure_tbl containing: location: Elution time volume value: Detector response Multiple samples combined measure_list column.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package includes sec_triple_detect, synthetic dataset representing multi-detector SEC analysis:","code":"data(sec_triple_detect, package = \"measure.sec\")  # Overview of the dataset glimpse(sec_triple_detect) #> Rows: 24,012 #> Columns: 11 #> $ sample_id        <chr> \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\", \"PS-1K\",… #> $ sample_type      <chr> \"standard\", \"standard\", \"standard\", \"standard\", \"stan… #> $ polymer_type     <chr> \"polystyrene\", \"polystyrene\", \"polystyrene\", \"polysty… #> $ elution_time     <dbl> 5.00, 5.01, 5.02, 5.03, 5.04, 5.05, 5.06, 5.07, 5.08,… #> $ ri_signal        <dbl> 6.926392e-04, 0.000000e+00, 3.199253e-04, 4.197175e-0… #> $ uv_signal        <dbl> 0.0002034583, 0.0000000000, 0.0000000000, 0.000000000… #> $ mals_signal      <dbl> 3.370385e-05, 3.483481e-05, 3.102092e-05, 3.261962e-0… #> $ known_mw         <dbl> 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,… #> $ known_dispersity <dbl> 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05,… #> $ dn_dc            <dbl> 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.185, 0.18… #> $ extinction_coef  <dbl> 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2…  # Sample types included sec_triple_detect |>   distinct(sample_id, sample_type, polymer_type) |>   print(n = 12) #> # A tibble: 12 × 3 #>    sample_id sample_type polymer_type #>    <chr>     <chr>       <chr>        #>  1 PS-1K     standard    polystyrene  #>  2 PS-10K    standard    polystyrene  #>  3 PS-50K    standard    polystyrene  #>  4 PS-100K   standard    polystyrene  #>  5 PS-500K   standard    polystyrene  #>  6 PMMA-Low  sample      pmma         #>  7 PMMA-Med  sample      pmma         #>  8 PMMA-High sample      pmma         #>  9 PEG-5K    sample      peg          #> 10 PEG-20K   sample      peg          #> 11 Copoly-A  sample      copolymer    #> 12 Copoly-B  sample      copolymer"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"basic-workflow-single-detector-analysis","dir":"Articles","previous_headings":"","what":"Basic Workflow: Single Detector Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Let’s start simple RI detector workflow polystyrene standards:","code":"# Filter to PS standards ps_standards <- sec_triple_detect |>   filter(polymer_type == \"polystyrene\")  # Create the preprocessing recipe # Note: The formula specifies which columns to use and sample_id as grouping rec <- recipe(   ri_signal + elution_time + dn_dc ~ sample_id,   data = ps_standards ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   # Apply baseline correction   step_sec_baseline(measures = \"ri\") |>   # Process RI detector with dn/dc   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\")  # Prep and bake prepped <- prep(rec) result <- bake(prepped, new_data = NULL)  # View RI signal results (MW calculation requires calibration - see below) result |>   select(sample_id, ri) #> # A tibble: 5 × 2 #>   sample_id          ri #>   <chr>          <meas> #> 1 PS-1K     [2,001 × 2] #> 2 PS-10K    [2,001 × 2] #> 3 PS-50K    [2,001 × 2] #> 4 PS-100K   [2,001 × 2] #> 5 PS-500K   [2,001 × 2]"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"conventional-calibration","dir":"Articles","previous_headings":"","what":"Conventional Calibration","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Conventional (relative) calibration uses narrow molecular weight standards establish relationship elution time molecular weight. common approach routine polymer analysis.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"calibration-standards","dir":"Articles","previous_headings":"Conventional Calibration","what":"Calibration Standards","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package includes comprehensive polystyrene PMMA calibration standards:","code":"# Load polystyrene calibration standards data(sec_ps_standards, package = \"measure.sec\")  # View the standards (16 standards from 162 Da to 3.15 MDa) sec_ps_standards |>   select(standard_name, mp, log_mp, retention_time, dispersity) |>   print(n = 8) #> # A tibble: 16 × 5 #>   standard_name      mp log_mp retention_time dispersity #>   <chr>           <dbl>  <dbl>          <dbl>      <dbl> #> 1 PS-3150000    3150000   6.50           11.2       1.04 #> 2 PS-1870000    1870000   6.27           11.6       1.04 #> 3 PS-1090000    1090000   6.04           12.1       1.03 #> 4 PS-630000      630000   5.80           12.6       1.04 #> 5 PS-430000      430000   5.63           13.2       1.04 #> 6 PS-216000      216000   5.33           13.8       1.03 #> 7 PS-120000      120000   5.08           14.3       1.03 #> 8 PS-67500        67500   4.83           15.0       1.03 #> # ℹ 8 more rows"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"visualizing-the-calibration-curve","dir":"Articles","previous_headings":"Conventional Calibration","what":"Visualizing the Calibration Curve","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"fitting, ’s good practice visualize standards:","code":"ggplot(sec_ps_standards, aes(retention_time, log_mp)) +   geom_point(size = 3, color = \"#2E86AB\") +   geom_smooth(     method = \"lm\",     formula = y ~ poly(x, 3),     se = TRUE,     color = \"#A23B72\",     fill = \"#A23B72\",     alpha = 0.2   ) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     title = \"Polystyrene Calibration Curve\",     subtitle = \"Cubic polynomial fit with 95% confidence band\"   ) +   theme_minimal() +   theme(     plot.title = element_text(face = \"bold\"),     axis.title = element_text(size = 11)   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"building-a-calibration-curve","dir":"Articles","previous_headings":"Conventional Calibration","what":"Building a Calibration Curve","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Use step_sec_conventional_cal() fit calibration apply samples. step_sec_conventional_cal() Parameters:","code":"# Prepare standards for the step (needs 'retention' and 'log_mw' columns) ps_cal <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  # Filter to a polystyrene sample for demonstration ps_sample <- sec_triple_detect |>   filter(sample_id == \"PS-50K\")  # Build the calibration recipe # Note: Use explicit formula with sample_id as the grouping variable rec_cal <- recipe(   ri_signal + elution_time + dn_dc ~ sample_id,   data = ps_sample ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   # Apply calibration to convert elution time to log(MW)   step_sec_conventional_cal(     measures = \"ri\",     standards = ps_cal,     fit_type = \"cubic\",     output_col = \"mw\",     extrapolation = \"none\"   ) |>   # Calculate MW averages from RI signal weighted by MW   step_sec_mw_averages(measures = \"ri\")  # Prep and bake prepped <- prep(rec_cal) #> Warning: Standard at 12.58 has 14.4% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. result <- bake(prepped, new_data = NULL)  # View molecular weight results result |>   select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity) #> # A tibble: 1 × 5 #>   sample_id      mw_mn   mw_mw   mw_mz mw_dispersity #>   <chr>          <dbl>   <dbl>   <dbl>         <dbl> #> 1 PS-50K    419927756. 8.24e21 7.81e23       1.96e13"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"assessing-calibration-quality","dir":"Articles","previous_headings":"Conventional Calibration","what":"Assessing Calibration Quality","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"tidy() method provides comprehensive diagnostics evaluating calibration quality: Key quality metrics:","code":"# Get calibration diagnostics diagnostics <- tidy(prepped, number = 3)  # step_sec_conventional_cal is step 3  # Overview metrics diagnostics |>   select(fit_type, n_standards, r_squared, rmse_log_mw, max_abs_pct_deviation) #> # A tibble: 1 × 5 #>   fit_type n_standards r_squared rmse_log_mw max_abs_pct_deviation #>   <chr>          <int>     <dbl>       <dbl>                 <dbl> #> 1 cubic             16     0.999      0.0294                  14.4  # Access per-standard residuals std_results <- diagnostics$standard_results[[1]] std_results |>   select(     location,     actual_log_mw,     predicted_log_mw,     residual_log_mw,     pct_deviation   ) #> # A tibble: 16 × 5 #>    location actual_log_mw predicted_log_mw residual_log_mw pct_deviation #>       <dbl>         <dbl>            <dbl>           <dbl>         <dbl> #>  1     11.2          6.50             6.47         0.0294         -6.55  #>  2     11.6          6.27             6.28        -0.00364         0.841 #>  3     12.1          6.04             6.06        -0.0192          4.51  #>  4     12.6          5.80             5.86        -0.0585         14.4   #>  5     13.2          5.63             5.59         0.0421         -9.24  #>  6     13.8          5.33             5.32         0.0126         -2.87  #>  7     14.3          5.08             5.11        -0.0300          7.15  #>  8     15.0          4.83             4.79         0.0413         -9.07  #>  9     15.5          4.53             4.55        -0.0262          6.22  #> 10     16.1          4.30             4.26         0.0352         -7.78  #> 11     16.7          3.99             4.01        -0.0197          4.63  #> 12     17.4          3.70             3.70         0.00359        -0.823 #> 13     17.9          3.47             3.46         0.0146         -3.31  #> 14     18.9          3.02             3.02         0.00222        -0.511 #> 15     19.4          2.76             2.81        -0.0419         10.1   #> 16     20.8          2.21             2.19         0.0181         -4.07"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"comparing-fit-types","dir":"Articles","previous_headings":"Conventional Calibration","what":"Comparing Fit Types","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Different polynomial orders may appropriate depending column behavior:","code":"# Compare linear, quadratic, and cubic fits library(tidyr)  fits <- tibble(   fit_type = c(\"Linear\", \"Quadratic\", \"Cubic\"),   degree = c(1, 2, 3) ) |>   mutate(     predictions = map(degree, function(d) {       model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)       tibble(         retention_time = seq(11, 21, by = 0.1),         log_mp = predict(model, newdata = tibble(retention_time = seq(11, 21, by = 0.1)))       )     }),     r_squared = map_dbl(degree, function(d) {       model <- lm(log_mp ~ poly(retention_time, d), data = sec_ps_standards)       summary(model)$r.squared     })   )  fit_curves <- fits |>   unnest(predictions)  ggplot() +   geom_point(     data = sec_ps_standards,     aes(retention_time, log_mp),     size = 3,     alpha = 0.7   ) +   geom_line(     data = fit_curves,     aes(retention_time, log_mp, color = fit_type),     linewidth = 1   ) +   scale_color_manual(     values = c(\"Linear\" = \"#E8751A\", \"Quadratic\" = \"#2E86AB\", \"Cubic\" = \"#A23B72\")   ) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     color = \"Fit Type\",     title = \"Calibration Curve Fit Comparison\",     subtitle = sprintf(       \"R²: Linear=%.5f, Quadratic=%.5f, Cubic=%.5f\",       fits$r_squared[1], fits$r_squared[2], fits$r_squared[3]     )   ) +   theme_minimal() +   theme(     legend.position = \"bottom\",     plot.title = element_text(face = \"bold\")   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"polymer-specific-calibration","dir":"Articles","previous_headings":"Conventional Calibration","what":"Polymer-Specific Calibration","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Conventional calibration polymer-specific different polymers different hydrodynamic volumes molecular weight:  Key insight: Using PS calibration PMMA samples underestimate molecular weight. cross-polymer analysis, use universal calibration Mark-Houwink parameters.","code":"data(sec_pmma_standards, package = \"measure.sec\")  # Combine PS and PMMA for comparison combined <- bind_rows(   sec_ps_standards |> mutate(polymer = \"Polystyrene\"),   sec_pmma_standards |> mutate(polymer = \"PMMA\") )  ggplot(combined, aes(retention_time, log_mp, color = polymer, shape = polymer)) +   geom_point(size = 3) +   geom_smooth(     method = \"lm\",     formula = y ~ poly(x, 3),     se = FALSE,     linewidth = 1   ) +   scale_color_manual(values = c(\"Polystyrene\" = \"#2E86AB\", \"PMMA\" = \"#A23B72\")) +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     color = \"Polymer\",     shape = \"Polymer\",     title = \"PS vs PMMA Calibration Curves\",     subtitle = \"At same MW, PMMA elutes later (smaller hydrodynamic volume in THF)\"   ) +   theme_minimal() +   theme(     legend.position = \"bottom\",     plot.title = element_text(face = \"bold\")   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"multi-detector-sec-workflow","dir":"Articles","previous_headings":"","what":"Multi-Detector SEC Workflow","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"accurate molecular weight determination, multi-detector SEC uses RI concentration MALS absolute molecular weight:","code":"# Multi-detector SEC workflow for absolute molecular weight # Note: MALS processing requires additional detector configuration rec_multi <- recipe(   ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef ~ sample_id,   data = sec_triple_detect ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert each detector to measure format   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_measure_input_long(     uv_signal,     location = vars(elution_time),     col_name = \"uv\"   ) |>   step_measure_input_long(     mals_signal,     location = vars(elution_time),     col_name = \"mals\"   ) |>   # Correct inter-detector delays   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.10)   ) |>   # Apply baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Process detectors   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>   step_sec_mals(mals_col = \"mals\", dn_dc_column = \"dn_dc\") |>   # Convert to concentration (requires injection info)   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,       # µL     sample_concentration = 2.0    # mg/mL   )  prepped_multi <- prep(rec_multi) result_multi <- bake(prepped_multi, new_data = NULL)  # View multi-detector results result_multi |>   select(sample_id, ri, uv, mals) |>   head(3) #> # A tibble: 3 × 4 #>   sample_id          ri          uv        mals #>   <chr>          <meas>      <meas>      <meas> #> 1 PS-1K     [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 2 PS-10K    [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 3 PS-50K    [2,001 × 2] [2,001 × 2] [2,001 × 2]"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"copolymer-composition-analysis","dir":"Articles","previous_headings":"","what":"Copolymer Composition Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"UV/RI ratio can reveal compositional heterogeneity across molecular weight distribution:","code":"# Filter to copolymer samples copolymers <- sec_triple_detect |>   filter(polymer_type == \"copolymer\")  rec_comp <- recipe(   ri_signal + uv_signal + elution_time ~ sample_id,   data = copolymers ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = c(\"ri\", \"uv\")) |>   # Calculate UV/RI ratio   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\", smooth = TRUE) |>   # Calculate composition (requires known response factors)   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     component_a_uv = 1.0,   # UV response factor for component A     component_a_ri = 0.185, # RI response factor for component A     component_b_uv = 0.1,   # UV response factor for component B     component_b_ri = 0.084  # RI response factor for component B   )  prepped_comp <- prep(rec_comp) result_comp <- bake(prepped_comp, new_data = NULL)  # The result contains: # - uv_ri_ratio: Point-by-point UV/RI ratio # - composition_a: Weight fraction of component A at each point"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"protein-sec-aggregate-quantitation","dir":"Articles","previous_headings":"","what":"Protein SEC: Aggregate Quantitation","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"protein therapeutics, SEC used quantify high molecular weight species (HMWS/aggregates) low molecular weight species (LMWS/fragments):","code":"# Create protein-like data (using UV at 280 nm) # Filter to a single sample for demonstration protein_data <- sec_triple_detect |>   filter(sample_type == \"sample\") |>   filter(sample_id == first(sample_id))  rec_protein <- recipe(   uv_signal + elution_time ~ sample_id,   data = protein_data ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline(measures = \"uv\") |>   # Quantify aggregates with manual peak boundaries   step_sec_aggregates(     measures = \"uv\",     monomer_start = 10,  # Monomer peak start time     monomer_end = 14,    # Monomer peak end time     method = \"manual\"   )  prepped_protein <- prep(rec_protein) result_protein <- bake(prepped_protein, new_data = NULL)  # Results include: # - purity_hmws: % high MW species (before monomer) # - purity_monomer: % main peak # - purity_lmws: % low MW species (after monomer) result_protein |>   select(sample_id, purity_hmws, purity_monomer, purity_lmws) #> # A tibble: 1 × 4 #>   sample_id purity_hmws purity_monomer purity_lmws #>   <chr>           <dbl>          <dbl>       <dbl> #> 1 PMMA-Low         2.05           25.7        72.1"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"molecular-weight-distribution","dir":"Articles","previous_headings":"","what":"Molecular Weight Distribution","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Generate differential cumulative molecular weight distributions:","code":"rec_mwd <- recipe(   ri_signal + elution_time + dn_dc + known_mw ~ sample_id,   data = sec_triple_detect ) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline(measures = \"ri\") |>   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   # Add MW distribution curves   step_sec_mw_distribution(     measures = \"ri\",     type = \"both\",  # \"differential\", \"cumulative\", or \"both\"     calibration = NULL  # Assumes x-axis is already log10(MW)   )  prepped_mwd <- prep(rec_mwd) result_mwd <- bake(prepped_mwd, new_data = NULL)  # The result contains: # - mwd_differential: dw/d(logM) vs logM # - mwd_cumulative: cumulative weight fraction vs logM"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"quality-control-functions","dir":"Articles","previous_headings":"","what":"Quality Control Functions","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"package provides functions chromatographic system suitability testing:","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"peak-resolution","dir":"Articles","previous_headings":"Quality Control Functions","what":"Peak Resolution","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Calculate USP resolution between two peaks Rs <- measure_sec_resolution(   retention_1 = 8.5,   retention_2 = 10.0,   width_1 = 0.3,   width_2 = 0.35,   method = \"usp\" )  cat(\"Resolution (Rs):\", round(Rs, 2), \"\\n\") #> Resolution (Rs): 4.62"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"plate-count","dir":"Articles","previous_headings":"Quality Control Functions","what":"Plate Count","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Calculate theoretical plates N <- measure_sec_plate_count(   retention = 10.0,   width = 0.25,   width_type = \"half_height\" )  cat(\"Theoretical plates:\", round(N), \"\\n\") #> Theoretical plates: 8864"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"system-suitability","dir":"Articles","previous_headings":"Quality Control Functions","what":"System Suitability","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"# Comprehensive system suitability testing peaks <- data.frame(   name = c(\"dimer\", \"monomer\"),   retention = c(8.5, 10.0),   width = c(0.3, 0.35),   area = c(5, 95) )  sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\") )  print(sst) #> SEC System Suitability Test #> ==================================================  #>  #> Overall Status: FAILED #>  #> Results: #> --------------------------------------------------  #> resolution          : 4.615385 (>= 1.5) [PASS] #> plate count         : 4522.0 (>= 5000) [FAIL]  #> --------------------------------------------------"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"polymer-analysis-mark-houwink-parameters","dir":"Articles","previous_headings":"","what":"Polymer Analysis: Mark-Houwink Parameters","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Estimate Mark-Houwink parameters intrinsic viscosity data:","code":"# Molecular weight and intrinsic viscosity data mw <- c(10000, 25000, 50000, 100000, 250000) iv <- 0.0001 * mw^0.7  # Simulated data  mh <- measure_mh_parameters(mw, iv) #> Warning in summary.lm(fit): essentially perfect fit: summary may be unreliable print(mh) #> Mark-Houwink Parameters #> ========================================  #>  #> K = 1.0000e-04 #> a = 0.700 #>  #> R-squared: 1.0000 #> Data points: 5 #> MW range: 10000 - 250000 #>  #> Equation: [eta] = K * M^a"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"branching-analysis","dir":"Articles","previous_headings":"","what":"Branching Analysis","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Calculate branching indices branched polymers:","code":"# Compare branched polymer to linear reference mw <- c(100000, 200000, 500000) rg_branched <- c(10, 15, 25) rg_linear <- c(12, 18, 32)  g <- measure_branching_index(   mw = mw,   rg = rg_branched,   reference = data.frame(mw = mw, rg = rg_linear),   method = \"g\" )  print(g) #> Branching Analysis Results #> ==================================================  #>  #> MW Range: 100000 - 500000 #> g (Rg ratio): 0.610 - 0.694 (mean: 0.666) #>  #> Estimated branches/molecule: 2.1 - 2.7 #>  #> # A tibble: 3 × 2 #>       mw     g #>    <dbl> <dbl> #> 1 100000 0.694 #> 2 200000 0.694 #> 3 500000 0.610 # g < 1 indicates branching (smaller Rg than linear)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"slice-by-slice-data","dir":"Articles","previous_headings":"Exporting Results","what":"Slice-by-Slice Data","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Extract point--point chromatographic data:","code":"# Extract point-by-point data from the processed result slices <- measure_sec_slice_table(   result,   measures = \"ri\",   sample_id = \"sample_id\",   pivot = TRUE )  head(slices) #> # A tibble: 6 × 4 #>   sample_id slice location      ri #>   <chr>     <int>    <dbl>   <dbl> #> 1 PS-50K        1     5    0.00143 #> 2 PS-50K        2     5.01 0.00167 #> 3 PS-50K        3     5.02 0.00136 #> 4 PS-50K        4     5.03 0.00132 #> 5 PS-50K        5     5.04 0.00213 #> 6 PS-50K        6     5.05 0.00174"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"summary-table","dir":"Articles","previous_headings":"Exporting Results","what":"Summary Table","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"Generate summary table reporting:","code":"# Generate a summary table with key metrics summary_tbl <- measure_sec_summary_table(   result,   sample_id = \"sample_id\",   digits = 0 )  print(summary_tbl) #> SEC Analysis Summary #> ============================================================  #> Samples: 1  #>  #> # A tibble: 1 × 5 #>   sample_id     mw_mn   mw_mw   mw_mz mw_dispersity #>   <chr>         <dbl>   <dbl>   <dbl>         <dbl> #> 1 PS-50K    419927756 8.24e21 7.81e23       1.96e13"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"complete-workflow-example","dir":"Articles","previous_headings":"","what":"Complete Workflow Example","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"’s complete workflow analyzing polymer standards:","code":"# Complete multi-detector SEC workflow # Note: This example demonstrates the full processing pipeline  # Create comprehensive recipe with explicit formula rec_complete <- recipe(   ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef + polymer_type ~ sample_id,   data = sec_triple_detect ) |>   update_role(sample_id, new_role = \"id\") |>   # Input conversion - all three detectors   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   # Preprocessing   step_sec_detector_delay(reference = \"ri\", delay_volumes = c(uv = -0.05, mals = 0.10)) |>   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Detector processing   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>   step_sec_mals(mals_col = \"mals\", dn_dc_column = \"dn_dc\") |>   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>   # Composition analysis   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\")  # Process prepped_complete <- prep(rec_complete) result_complete <- bake(prepped_complete, new_data = NULL)  # View processed results result_complete |>   select(sample_id, polymer_type, ri, uv, mals) |>   head(6) #> # A tibble: 6 × 5 #>   sample_id polymer_type          ri          uv        mals #>   <chr>     <fct>             <meas>      <meas>      <meas> #> 1 PS-1K     polystyrene  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 2 PS-10K    polystyrene  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 3 PS-50K    polystyrene  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 4 PS-100K   polystyrene  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 5 PS-500K   polystyrene  [2,001 × 2] [2,001 × 2] [2,001 × 2] #> 6 PMMA-Low  pmma         [2,001 × 2] [2,001 × 2] [2,001 × 2]"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"focused -guides specific workflows: Getting Started - Introduction basic workflow Multi-Detector SEC - MALS, viscometer, absolute MW Protein SEC Analysis - Biopharm aggregate/fragment analysis Copolymer Composition - UV/RI ratio methods Calibration Management - Save/load calibrations System Suitability - QC metrics SST","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-analysis.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Size Exclusion Chromatography Analysis with measure.sec","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          purrr_1.2.0            tidyr_1.3.2            #> [4] measure.sec_0.0.0.9000 measure_0.0.1.9002     recipes_1.3.1          #> [7] dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  pillar_1.11.1       pkgdown_2.2.0       #> [28] jquerylib_0.1.4     MASS_7.3-65         cachem_1.1.0        #> [31] gower_1.0.2         rpart_4.1.24        nlme_3.1-168        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       listenv_0.10.0      #> [40] labeling_0.4.3      splines_4.5.2       fastmap_1.2.0       #> [43] grid_4.5.2          cli_3.6.5           magrittr_2.0.4      #> [46] utf8_1.2.6          survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] mgcv_1.9-3          rlang_1.1.6         Rcpp_1.1.0          #> [64] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [67] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"about-this-guide","dir":"Articles","previous_headings":"","what":"About This Guide","title":"SEC Concepts: A Practical Guide","text":"guide explains SEC concepts practical perspective—need know use measure.sec effectively. ’s textbook; every concept ties back package functionality guidance use different approaches. : Users chemistry background new SEC want understand use package features. use : Read straight conceptual foundation, jump specific sections need decision guidance.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"the-processing-pipeline","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"The Processing Pipeline","title":"SEC Concepts: A Practical Guide","text":"SEC data processing follows consistent pattern: raw detector signals converted common format, processed remove artifacts, calibrated molecular weight, used calculate results. Understanding flow helps build recipes make sense.","code":"#> Warning in geom_segment(aes(x = 1.15, xend = 4.85, y = 1, yend = 1), arrow = arrow(length = unit(0.3, : All aesthetics have length 1, but the data has 5 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row."},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"stage-1-input-signals","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"Stage 1: Input Signals","title":"SEC Concepts: A Practical Guide","text":"Every recipe starts converting raw detector signals measure format using step_measure_input_long(). standardizes different detectors common structure measurement location (elution time volume) value (signal intensity).","code":"recipe(...) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"stage-2-preprocessing","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"Stage 2: Preprocessing","title":"SEC Concepts: A Practical Guide","text":"calibration, signals need cleaning: Order matters: Detector delay correction must come first. Baseline correction precede normalization. Concentration needed MALS calculations.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"stage-3-calibration","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"Stage 3: Calibration","title":"SEC Concepts: A Practical Guide","text":"Calibration converts elution time molecular weight. right approach depends standards goals:","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"stage-4-mw-calculation","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"Stage 4: MW Calculation","title":"SEC Concepts: A Practical Guide","text":"calibration complete, calculate molecular weight results:","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"stage-5-export-and-visualization","dir":"Articles","previous_headings":"How SEC Data Flows Through measure.sec","what":"Stage 5: Export and Visualization","title":"SEC Concepts: A Practical Guide","text":"Extract results reporting: measure_sec_summary_table(): Publication-ready summary statistics measure_sec_slice_table(): Point--point data custom analysis plot_sec_*() family: Chromatograms, MWDs, calibration curves","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"choosing-your-calibration-approach","dir":"Articles","previous_headings":"","what":"Choosing Your Calibration Approach","title":"SEC Concepts: A Practical Guide","text":"Calibration users face first major decision. section helps choose right approach.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"conventional-calibration","dir":"Articles","previous_headings":"Choosing Your Calibration Approach","what":"Conventional Calibration","title":"SEC Concepts: A Practical Guide","text":"use: narrow MW standards (low dispersity) polymer type samples. works: Fit polynomial relationship log(MW) elution time using standards. Apply curve unknown samples. Advantages: Simple, well-understood, widely used. Calibration curve provides diagnostics (R2, residuals). Limitations: Assumes sample behaves like standards. branched polymer report incorrect MW elutes later linear polymer MW. Best practices: Use 5+ standards spanning MW range interest Check residuals—systematic patterns indicate poor fit Don’t extrapolate far beyond calibration range","code":"step_sec_conventional_cal(   standards_data = standards,   degree = 3              # Polynomial order (usually 3) )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"broad-standard-calibration","dir":"Articles","previous_headings":"Choosing Your Calibration Approach","what":"Broad Standard Calibration","title":"SEC Concepts: A Practical Guide","text":"use: one well-characterized broad-distribution reference material instead multiple narrow standards. works: Uses known MWD reference establish MW-elution relationship single injection. Advantages: Single injection, good routine QC. Convenient narrow standards aren’t available. Limitations: Accuracy depends entirely well know reference material’s MWD. error reference propagates samples.","code":"step_sec_broad_standard(   reference_mwd = known_distribution,   reference_mn = 50000,   reference_mw = 150000 )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"universal-calibration","dir":"Articles","previous_headings":"Choosing Your Calibration Approach","what":"Universal Calibration","title":"SEC Concepts: A Practical Guide","text":"use: samples different polymer type available standards. works: Calibrates hydrodynamic volume ([η] × M) rather molecular weight directly. Uses Mark-Houwink parameters convert polymer types. Requires: Intrinsic viscosity data (viscometer) Mark-Houwink parameters polymer types. Advantages: Accurate MW different polymer types using common standards. Limitations: need reliable K values sample, may require literature search independent measurement. Doesn’t work well highly branched polymers Mark-Houwink parameters aren’t constant.","code":"step_sec_universal_cal(   # Calibration standards (e.g., polystyrene)   reference_k = 1.14e-4,   reference_a = 0.716,   # Your sample (e.g., PMMA)   sample_k = 6.0e-5,   sample_a = 0.73 )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"absolute-mw-light-scattering","dir":"Articles","previous_headings":"Choosing Your Calibration Approach","what":"Absolute MW (Light Scattering)","title":"SEC Concepts: A Practical Guide","text":"use: need true molecular weight independent polymer structure, appropriate standards. works: Light scattering intensity directly proportional molecular weight × concentration. column calibration needed. Requires: Light scattering detector (MALS, LALS, RALS), accurate dn/dc value, good signal quality. Advantages: True absolute MW. Works polymer type. Reveals branching Rg-MW relationships. Required proteins complex polymers. Limitations: expensive instrumentation. Sensitive dust bubbles. Low MW samples may weak scattering signal.","code":"step_sec_mals(   dn_dc_column = \"dn_dc\"   # Refractive index increment )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"understanding-your-detectors","dir":"Articles","previous_headings":"","what":"Understanding Your Detectors","title":"SEC Concepts: A Practical Guide","text":"detector type provides different information. Knowing measures helps interpret results troubleshoot problems.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"concentration-detectors","dir":"Articles","previous_headings":"Understanding Your Detectors","what":"Concentration Detectors","title":"SEC Concepts: A Practical Guide","text":"tell much material present elution slice.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"refractive-index-ri","dir":"Articles","previous_headings":"Understanding Your Detectors > Concentration Detectors","what":"Refractive Index (RI)","title":"SEC Concepts: A Practical Guide","text":"measures: Change refractive index proportional concentration. Key parameter: dn/dc (refractive index increment, mL/g) use: Default concentration detector polymer SEC. Essential MW calculations.","code":"step_sec_ri(dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"uv-detector","dir":"Articles","previous_headings":"Understanding Your Detectors > Concentration Detectors","what":"UV Detector","title":"SEC Concepts: A Practical Guide","text":"measures: Absorbance specific wavelength(s). Key parameter: Extinction coefficient (ε, mL/(g·cm)) use: Proteins (280 nm), aromatic polymers, combined RI composition analysis.","code":"step_sec_uv(extinction_column = \"extinction_coef\", wavelength = 280)"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"dad-diode-array","dir":"Articles","previous_headings":"Understanding Your Detectors > Concentration Detectors","what":"DAD (Diode Array)","title":"SEC Concepts: A Practical Guide","text":"measures: Full UV-Vis spectrum point. use: Complex samples spectral information helps identify components. Copolymer composition wavelength-dependent absorption.","code":"step_sec_dad(wavelengths = c(254, 280, 320))"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"molecular-weight-detectors","dir":"Articles","previous_headings":"Understanding Your Detectors","what":"Molecular Weight Detectors","title":"SEC Concepts: A Practical Guide","text":"measure MW directly, independent calibration.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"multi-angle-light-scattering-mals","dir":"Articles","previous_headings":"Understanding Your Detectors > Molecular Weight Detectors","what":"Multi-Angle Light Scattering (MALS)","title":"SEC Concepts: A Practical Guide","text":"measures: Scattered light intensity multiple angles. Provides: Absolute MW radius gyration (Rg) slice. See also: MALS Detection vignette","code":"step_sec_mals(dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"low-angle-light-scattering-lals","dir":"Articles","previous_headings":"Understanding Your Detectors > Molecular Weight Detectors","what":"Low-Angle Light Scattering (LALS)","title":"SEC Concepts: A Practical Guide","text":"measures: Scattered light near 0° angle.","code":"step_sec_lals(dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"right-angle-light-scattering-rals","dir":"Articles","previous_headings":"Understanding Your Detectors > Molecular Weight Detectors","what":"Right-Angle Light Scattering (RALS)","title":"SEC Concepts: A Practical Guide","text":"measures: Scattered light 90°. See also: LALS/RALS Detection vignette","code":"step_sec_rals(dn_dc_column = \"dn_dc\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"hydrodynamic-detectors","dir":"Articles","previous_headings":"Understanding Your Detectors","what":"Hydrodynamic Detectors","title":"SEC Concepts: A Practical Guide","text":"measure molecular size conformation solution.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"viscometer","dir":"Articles","previous_headings":"Understanding Your Detectors > Hydrodynamic Detectors","what":"Viscometer","title":"SEC Concepts: A Practical Guide","text":"measures: Differential pressure across capillary, related solution viscosity. Provides: Intrinsic viscosity [η] combined concentration.","code":"step_sec_viscometer() step_sec_intrinsic_visc(visc_col = \"visc\", conc_col = \"concentration\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"dynamic-light-scattering-dls","dir":"Articles","previous_headings":"Understanding Your Detectors > Hydrodynamic Detectors","what":"Dynamic Light Scattering (DLS)","title":"SEC Concepts: A Practical Guide","text":"measures: Time-dependent intensity fluctuations Brownian motion. Provides: Hydrodynamic radius (Rh).","code":"step_sec_dls()"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"common-pitfalls-and-solutions","dir":"Articles","previous_headings":"","what":"Common Pitfalls and Solutions","title":"SEC Concepts: A Practical Guide","text":"section addresses problems ’re likely encounter measure.sec helps fix .","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"baseline-issues","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Baseline Issues","title":"SEC Concepts: A Practical Guide","text":"Symptoms: Sloped baseline, wavy baseline, baseline doesn’t return zero. Causes: Temperature drift (RI), mobile phase mixing, column equilibration, late-eluting contaminants. Solution: Use step_sec_baseline() appropriate method: method choose: linear: Fast, works baseline truly straight spline: Better gradual drift temperature effects asymmetric: Best noisy data peak tails affect baseline","code":"step_sec_baseline(   measures = \"ri\",   method = \"linear\",       # Simple start-to-end connection   # or   method = \"spline\",       # Follows gradual curves   # or   method = \"asymmetric\"    # Handles uneven noise )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"inter-detector-delay","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Inter-Detector Delay","title":"SEC Concepts: A Practical Guide","text":"Symptoms: Calculated MW varies injection volume, MW appears vary across peak uniform. Cause: Detectors series experience different delays. 150 µL delay volume 1 mL/min means 9 seconds offset—can shift MW orders magnitude. Solution: Use step_sec_detector_delay() MW calculations: measure delays: Inject low-MW marker (toluene, polymer standard) Record peak apex time detector Convert time difference volume: delay = Δt × flow_rate Tip: Re-measure column changes major maintenance.","code":"step_sec_detector_delay(   reference = \"ri\",   delay_volumes = c(uv = -0.05, mals = 0.15)  # mL )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"band-broadening","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Band Broadening","title":"SEC Concepts: A Practical Guide","text":"Symptoms: MWD appears broader expected. High MW tail low MW shoulder. Cause: Peak spreading extra-column volume, column dispersion, injection effects. Solution: Use step_sec_band_broadening() deconvolve true distribution: Estimate sigma using narrow standard—peak width entirely broadening:","code":"step_sec_band_broadening(   sigma = 0.03  # Peak spreading parameter (mL) ) sigma <- estimate_sigma(   narrow_standard_data,   signal_col = \"ri\" )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"out-of-range-calibration","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Out-of-Range Calibration","title":"SEC Concepts: A Practical Guide","text":"Symptoms: Extrapolated MW values seem unreasonable. high low MW fractions. Cause: Sample contains material outside MW range calibration standards. Solution: Options step_sec_conventional_cal(): Best practice: Use standards span sample’s MW range. extrapolation unavoidable, use “linear” caution flag results.","code":"step_sec_conventional_cal(   standards_data = standards,   extrapolate = \"linear\",    # Continue slope beyond range   # or   extrapolate = \"constant\",  # Clamp at boundary   # or   extrapolate = \"none\"       # Return NA outside range )"},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"noisy-light-scattering","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Noisy Light Scattering","title":"SEC Concepts: A Practical Guide","text":"Symptoms: Jagged LS signal, especially low concentration regions. Causes: Dust, bubbles, low sample concentration, detector noise. Solutions: Filter samples: 0.22 µm minimum, 0.1 µm MALS Degas mobile phase: Remove dissolved gases Increase concentration: sample = scattering signal Apply smoothing: step parameters post-processing","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"molecular-weight-averages","dir":"Articles","previous_headings":"Interpreting Results","what":"Molecular Weight Averages","title":"SEC Concepts: A Practical Guide","text":"SEC produces multiple MW averages. tells something different: Practical interpretation: Mn tells numerous species Mw tells mass Mz warns high MW contamination aggregation","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"dispersity-đ","dir":"Articles","previous_headings":"Interpreting Results","what":"Dispersity (Đ)","title":"SEC Concepts: A Practical Guide","text":"Dispersity = Mw/Mn measures breadth distribution. Tip: Đ < 1.0, something wrong—often calibration integration problem.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"when-results-look-wrong","dir":"Articles","previous_headings":"Interpreting Results","what":"When Results Look Wrong","title":"SEC Concepts: A Practical Guide","text":"MW seems high low: Check calibration: standards correctly identified? Check detector delays: Misalignment shifts apparent MW Check dn/dc: Wrong value directly scales MW LS Dispersity seems narrow: Check integration limits: narrow excludes real distribution Check band broadening: Unaccounted broadening inflates apparent width Sample may genuinely narrow MW varies injections: Check baseline reproducibility Check column equilibration Check sample stability (aggregation, degradation) Negative MW distribution edges: Normal low signal—noise can go negative Set appropriate thresholds MW calculation steps Focus region good signal--noise","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/sec-concepts.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"SEC Concepts: A Practical Guide","text":"Getting Started - first SEC analysis Comprehensive SEC Analysis - Full reference features Multi-Detector SEC - Detailed multi-detector workflows Calibration Management - Saving reusing calibrations","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"System Suitability and QC","text":"System Suitability Testing (SST) ensures SEC system performing adequately analyzing samples. guide shows : 1. Extract peak parameters chromatogram data 2. Calculate key SST metrics (resolution, plate count, asymmetry) 3. Run comprehensive system suitability tests 4. Track column performance time","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"the-foundation-of-reliable-results","dir":"Articles","previous_headings":"Why System Suitability Matters","what":"The Foundation of Reliable Results","title":"System Suitability and QC","text":"System Suitability Testing just regulatory checkbox—’s foundation analytical reliability. SEC system many components can drift fail: pumps, columns, detectors, tubing, fittings. Without verification, might analyze samples degraded system generate data looks normal fundamentally wrong. Consider happens column efficiency degrades: peaks broaden, overlapping species resolved merge together, molecular weight calculations shift systematically. ’re quantifying protein aggregates 5% specification, running column 30% lower plate count might cause underestimate aggregate content—potentially releasing --specification material. SST prevents verifying system performance analytical batch.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"how-column-degradation-affects-results","dir":"Articles","previous_headings":"Why System Suitability Matters","what":"How Column Degradation Affects Results","title":"System Suitability and QC","text":"SEC columns degrade gradually several mechanisms: Void formation: Packing material settles dissolves, creating dead volume column head. causes peak fronting, reduced plate count, shifted retention times. Surface contamination: Sample components adsorb irreversibly reduce available surface area. Resolution decreases, especially polar analytes. Frit blockage: Particulates samples mobile phase clog inlet frits. Back-pressure increases, eventually flow becomes inconsistent. Mechanical damage: Pressure shocks physical impact can fracture particles, creating fine particles block flow paths. degradation modes produce characteristic SST failures: plate count drops resolution ; asymmetry changes symmetric tailing; retention times shift earlier (void formation) later (contamination). Tracking metrics time lets predict column failure affects sample results.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"where-acceptance-criteria-come-from","dir":"Articles","previous_headings":"Why System Suitability Matters","what":"Where Acceptance Criteria Come From","title":"System Suitability and QC","text":"acceptance criteria commonly used SEC—Rs ≥ 1.5, N ≥ 5000, Tf 0.8 1.5—derive pharmacopeial methods (USP, EP, JP) decades chromatographic practice. represent minimum performance levels separation quality acceptable quantitative work. Resolution ≥ 1.5 ensures baseline separation critical pairs (~99.7% peak purity). Plate count ≥ 5000 provides sufficient peak sharpness accurate integration. Tailing factor 0.8 1.5 indicates column free significant void formation secondary interactions. regulated environments, limits may tightened based method validation data. biopharmaceutical method might require Rs ≥ 2.0 monomer dimer ’s demonstrated validation. principle consistent: SST criteria reflect performance level method validated shown give accurate results.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"System Suitability and QC","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"starting-from-chromatogram-data","dir":"Articles","previous_headings":"","what":"Starting from Chromatogram Data","title":"System Suitability and QC","text":"real-world SST, start chromatogram SEC system. Let’s use sec_protein dataset contains UV detection data protein SEC analysis multiple species.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"visualize-the-chromatogram","dir":"Articles","previous_headings":"Starting from Chromatogram Data","what":"Visualize the Chromatogram","title":"System Suitability and QC","text":"","code":"# Load protein SEC data data(sec_protein)  # Look at the reference standard reference <- sec_protein |>   filter(sample_id == \"mAb-Reference\")  # Plot the chromatogram ggplot(reference, aes(x = elution_time, y = uv_280_signal)) +   geom_line(color = \"#2E86AB\", linewidth = 0.8) +   labs(     x = \"Elution Time (min)\",     y = \"UV 280 nm Signal (AU)\",     title = \"Protein SEC Chromatogram\",     subtitle = \"mAb Reference Standard\"   ) +   theme_minimal()"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"understanding-peak-parameters","dir":"Articles","previous_headings":"Starting from Chromatogram Data","what":"Understanding Peak Parameters","title":"System Suitability and QC","text":"chromatography software typically reports peak table key parameters: example, let’s define peak parameters based chromatogram . practice, come integration software:","code":"# Peak parameters from integration (typical protein SEC) # These represent what your software would report peaks <- data.frame(   name = c(\"HMW\", \"Dimer\", \"Monomer\", \"Fragment\"),   retention = c(6.8, 8.2, 10.5, 13.1),   # minutes   width = c(0.35, 0.28, 0.42, 0.38),      # width at half height (for SST)   width_base = c(0.70, 0.56, 0.84, 0.76), # width at baseline   area = c(0.8, 1.2, 96.5, 1.5),          # % of total   height = c(0.018, 0.025, 0.350, 0.022)  # AU )  peaks #>       name retention width width_base area height #> 1      HMW       6.8  0.35       0.70  0.8  0.018 #> 2    Dimer       8.2  0.28       0.56  1.2  0.025 #> 3  Monomer      10.5  0.42       0.84 96.5  0.350 #> 4 Fragment      13.1  0.38       0.76  1.5  0.022"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"resolution-measuring-peak-separation","dir":"Articles","previous_headings":"How QC Metrics Are Calculated","what":"Resolution: Measuring Peak Separation","title":"System Suitability and QC","text":"Resolution quantifies well two adjacent peaks separated. uses retention times peak widths peak table. Interpretation: - Rs < 1.0: Peaks overlap significantly - Rs = 1.5: Baseline separation (~99.7% resolved) - Rs > 2.0: Complete separation baseline gap","code":"# Extract parameters for dimer and monomer peaks dimer <- peaks |> filter(name == \"Dimer\") monomer <- peaks |> filter(name == \"Monomer\")  # Show the calculation cat(\"Dimer retention:\", dimer$retention, \"min\\n\") #> Dimer retention: 8.2 min cat(\"Monomer retention:\", monomer$retention, \"min\\n\") #> Monomer retention: 10.5 min cat(\"Dimer baseline width:\", dimer$width_base, \"min\\n\") #> Dimer baseline width: 0.56 min cat(\"Monomer baseline width:\", monomer$width_base, \"min\\n\") #> Monomer baseline width: 0.84 min cat(\"\\n\")  # USP Resolution formula: Rs = 2(t2 - t1) / (w1 + w2) Rs <- measure_sec_resolution(   retention_1 = dimer$retention,   retention_2 = monomer$retention,   width_1 = dimer$width_base,   width_2 = monomer$width_base,   method = \"usp\" )  cat(\"Resolution (USP) = 2 ×\", monomer$retention - dimer$retention,     \"/ (\", dimer$width_base, \"+\", monomer$width_base, \")\\n\") #> Resolution (USP) = 2 × 2.3 / ( 0.56 + 0.84 ) cat(\"                 =\", round(Rs, 2), \"\\n\") #>                  = 3.29"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"plate-count-measuring-column-efficiency","dir":"Articles","previous_headings":"How QC Metrics Are Calculated","what":"Plate Count: Measuring Column Efficiency","title":"System Suitability and QC","text":"Plate count measures sharp peaks . Sharper peaks = plates = better efficiency. uses retention time peak width. affects plate count: - Column packing quality - Flow rate (fast = lower N) - Sample overloading - Extra-column dispersion (tubing, fittings)","code":"# For the monomer peak (main peak) cat(\"Monomer retention:\", monomer$retention, \"min\\n\") #> Monomer retention: 10.5 min cat(\"Monomer half-height width:\", monomer$width, \"min\\n\") #> Monomer half-height width: 0.42 min cat(\"\\n\")  # USP formula for half-height: N = 5.54 × (tR / w0.5)² N <- measure_sec_plate_count(   retention = monomer$retention,   width = monomer$width,   width_type = \"half_height\" )  cat(\"Plate count = 5.54 × (\", monomer$retention, \"/\", monomer$width, \")²\\n\") #> Plate count = 5.54 × ( 10.5 / 0.42 )² cat(\"            = 5.54 ×\", round((monomer$retention / monomer$width)^2, 1), \"\\n\") #>             = 5.54 × 625 cat(\"            =\", round(N), \"plates\\n\") #>             = 3462 plates"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"peak-asymmetry-checking-peak-shape","dir":"Articles","previous_headings":"How QC Metrics Are Calculated","what":"Peak Asymmetry: Checking Peak Shape","title":"System Suitability and QC","text":"Asymmetry measures whether peak symmetric (ideal) tailing/fronting. compares leading half-width tailing half-width specific height.","code":"# For asymmetry, we need leading and tailing half-widths # (measured at 5% height for USP, 10% height for EP) # Let's assume slight tailing for the monomer: leading_width <- 0.20   # front half-width at 5% height tailing_width <- 0.24   # back half-width at 5% height  cat(\"Leading half-width (at 5%):\", leading_width, \"min\\n\") #> Leading half-width (at 5%): 0.2 min cat(\"Tailing half-width (at 5%):\", tailing_width, \"min\\n\") #> Tailing half-width (at 5%): 0.24 min cat(\"\\n\")  # USP Tailing Factor: Tf = (a + b) / 2a Tf <- measure_sec_asymmetry(   leading = leading_width,   tailing = tailing_width,   method = \"usp\" )  cat(\"Tailing factor = (\", leading_width, \"+\", tailing_width, \") / (2 ×\", leading_width, \")\\n\") #> Tailing factor = ( 0.2 + 0.24 ) / (2 × 0.2 ) cat(\"               =\", round(Tf, 2), \"\\n\") #>                = 1.1 cat(\"\\nInterpretation: Tf =\", round(Tf, 2)) #>  #> Interpretation: Tf = 1.1 if (Tf >= 0.8 && Tf <= 1.5) {   cat(\" → Pass (acceptable range 0.8-1.5)\\n\") } else {   cat(\" → Investigate\\n\") } #>  → Pass (acceptable range 0.8-1.5)"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"mass-recovery-verifying-complete-detection","dir":"Articles","previous_headings":"How QC Metrics Are Calculated","what":"Mass Recovery: Verifying Complete Detection","title":"System Suitability and QC","text":"Recovery checks injected sample detected. requires knowing injected mass comparing detected mass integration. Low recovery causes: - Sample adsorption column/tubing - Aggregation analysis - Detector calibration drift - Baseline integration errors","code":"# Typical protein SEC injection injected_mass <- 0.050   # mg (50 µg) detected_mass <- 0.048   # mg from integration area and response factor  recovery <- measure_sec_recovery(   detected_mass = detected_mass,   injected_mass = injected_mass )  cat(\"Injected mass:\", injected_mass * 1000, \"µg\\n\") #> Injected mass: 50 µg cat(\"Detected mass:\", detected_mass * 1000, \"µg\\n\") #> Detected mass: 48 µg cat(\"Recovery:\", round(recovery, 1), \"%\\n\") #> Recovery: 96 %"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"running-comprehensive-sst","dir":"Articles","previous_headings":"","what":"Running Comprehensive SST","title":"System Suitability and QC","text":"understand metric calculated, can run complete SST evaluation.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"basic-system-suitability-test","dir":"Articles","previous_headings":"Running Comprehensive SST","what":"Basic System Suitability Test","title":"System Suitability and QC","text":"output shows metric value, acceptance criterion, pass/fail status. summary end indicates overall system suitability.","code":"# Use the peak table we defined earlier sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"Dimer\", \"Monomer\"),  # Critical pair for resolution   column_length = 30  # cm )  # View results with pass/fail status print(sst) #> SEC System Suitability Test #> ==================================================  #>  #> Overall Status: FAILED #>  #> Results: #> --------------------------------------------------  #> resolution          : 6.571429 (>= 1.5) [PASS] #> plate count         : 3462.0 (>= 5000) [FAIL] #> plates per meter    : 11542.0 (informational) [INFO]  #> --------------------------------------------------"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"sst-with-custom-stricter-criteria","dir":"Articles","previous_headings":"Running Comprehensive SST","what":"SST with Custom (Stricter) Criteria","title":"System Suitability and QC","text":"validated biopharmaceutical methods, may need tighter criteria: Tip: Document acceptance criteria method validation protocol. defaults measure_sec_suitability() typical starting points verified specific application.","code":"strict_criteria <- list(   resolution_min = 2.0,       # Higher than default 1.5   plate_count_min = 8000,     # Higher than default 5000   tailing_min = 0.9,          # Tighter than default 0.8   tailing_max = 1.3,          # Tighter than default 1.5   recovery_min = 97,          # Tighter than default 95%   recovery_max = 103,         # Tighter than default 105%   retention_rsd_max = 0.5,    # Tighter precision   area_rsd_max = 1.0 )  sst_strict <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"Dimer\", \"Monomer\"),   criteria = strict_criteria )  print(sst_strict) #> SEC System Suitability Test #> ==================================================  #>  #> Overall Status: FAILED #>  #> Results: #> --------------------------------------------------  #> resolution          : 6.571429 (>= 2) [PASS] #> plate count         : 3462.0 (>= 8000) [FAIL]  #> --------------------------------------------------"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"sst-with-replicate-injections","dir":"Articles","previous_headings":"Running Comprehensive SST","what":"SST with Replicate Injections","title":"System Suitability and QC","text":"precision assessment, peak table includes multiple injections:","code":"# 6 replicate injections of the same sample peaks_reps <- data.frame(   name = rep(c(\"Dimer\", \"Monomer\"), each = 6),   replicate = rep(1:6, 2),   retention = c(     8.22, 8.21, 8.23, 8.20, 8.22, 8.21,  # Dimer     10.50, 10.51, 10.49, 10.52, 10.50, 10.51   # Monomer   ),   width = c(     0.28, 0.27, 0.28, 0.28, 0.29, 0.28,     0.42, 0.41, 0.42, 0.41, 0.42, 0.42   ),   area = c(     1.2, 1.3, 1.2, 1.1, 1.2, 1.2,     96.5, 96.2, 96.7, 96.4, 96.5, 96.6   ) )  sst_reps <- measure_sec_suitability(   peaks = peaks_reps,   reference_peaks = c(\"Dimer\", \"Monomer\") )  summary(sst_reps) #> SEC System Suitability Summary #>  #> Metrics evaluated: 3  #>   Passed: 2  #>   Failed: 1  #>  #> Overall: FAILED"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"what-to-do-when-sst-fails","dir":"Articles","previous_headings":"Running Comprehensive SST","what":"What to Do When SST Fails","title":"System Suitability and QC","text":"Decision tree: 1. Single failure → Re-inject re-evaluate 2. Repeated failure → Investigate root cause (see Troubleshooting) 3. Multiple metrics fail → proceed sample analysis","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"tracking-column-performance-over-time","dir":"Articles","previous_headings":"","what":"Tracking Column Performance Over Time","title":"System Suitability and QC","text":"Use SST data daily runs monitor column aging.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"column-performance-log","dir":"Articles","previous_headings":"Tracking Column Performance Over Time","what":"Column Performance Log","title":"System Suitability and QC","text":"","code":"# SST results collected over several months set.seed(42) dates <- seq(as.Date(\"2024-01-01\"), as.Date(\"2024-06-01\"), by = \"week\") n_weeks <- length(dates)  # Simulated gradual column degradation column_log <- tibble(   date = dates,   plates = seq(25000, 19500, length.out = n_weeks) + rnorm(n_weeks, 0, 300),   resolution = seq(2.5, 1.95, length.out = n_weeks) + rnorm(n_weeks, 0, 0.05),   asymmetry = seq(1.02, 1.25, length.out = n_weeks) + rnorm(n_weeks, 0, 0.02) )"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"visualizing-trends","dir":"Articles","previous_headings":"Tracking Column Performance Over Time","what":"Visualizing Trends","title":"System Suitability and QC","text":"","code":"ggplot(column_log, aes(date)) +   geom_line(aes(y = plates / 10000), color = \"#2E86AB\", linewidth = 1) +   geom_point(aes(y = plates / 10000), color = \"#2E86AB\", size = 2) +   geom_line(aes(y = resolution), color = \"#A23B72\", linewidth = 1) +   geom_point(aes(y = resolution), color = \"#A23B72\", size = 2) +   geom_hline(yintercept = 1.5, linetype = \"dashed\", color = \"#A23B72\", alpha = 0.7) +   geom_hline(yintercept = 1.0, linetype = \"dashed\", color = \"#2E86AB\", alpha = 0.7) +   annotate(\"text\", x = as.Date(\"2024-01-15\"), y = 1.55,            label = \"Rs limit (1.5)\", color = \"#A23B72\", size = 3) +   annotate(\"text\", x = as.Date(\"2024-01-15\"), y = 1.05,            label = \"N limit (10k)\", color = \"#2E86AB\", size = 3) +   scale_y_continuous(     name = \"Resolution\",     sec.axis = sec_axis(~ . * 10000, name = \"Theoretical Plates\")   ) +   labs(     x = \"Date\",     title = \"Column Performance Tracking\",     subtitle = \"Resolution (pink) and plate count (blue) over time\"   ) +   theme_minimal() +   theme(     axis.title.y.left = element_text(color = \"#A23B72\"),     axis.title.y.right = element_text(color = \"#2E86AB\")   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"predicting-column-replacement","dir":"Articles","previous_headings":"Tracking Column Performance Over Time","what":"Predicting Column Replacement","title":"System Suitability and QC","text":"","code":"min_plates <- 10000 min_resolution <- 1.5  column_log <- column_log |>   mutate(     plates_ok = plates > min_plates,     resolution_ok = resolution > min_resolution,     overall_ok = plates_ok & resolution_ok   )  first_failure <- which(!column_log$overall_ok)[1]  if (!is.na(first_failure)) {   cat(\"Column replacement needed at week:\", first_failure, \"\\n\")   cat(\"Date:\", format(column_log$date[first_failure]), \"\\n\")   cat(\"Resolution at failure:\", round(column_log$resolution[first_failure], 2), \"\\n\")   cat(\"Plates at failure:\", round(column_log$plates[first_failure]), \"\\n\") } else {   cat(\"Column still within specifications\\n\") } #> Column still within specifications"},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"column-qualification","dir":"Articles","previous_headings":"","what":"Column Qualification","title":"System Suitability and QC","text":"installing new column, perform full qualification using calibration standards. provides baseline metrics track column’s lifetime. Key qualification metrics:","code":"# Calibration data from polymer standards cal_standards <- data.frame(   retention = c(5.2, 6.1, 7.0, 8.2, 9.5, 10.8),   mw = c(1200000, 400000, 100000, 30000, 5000, 580),   width = c(0.40, 0.35, 0.30, 0.28, 0.25, 0.30) )  # Evaluate column performance col_perf <- measure_sec_column_performance(   cal_standards,   column_length = 30,    # cm   particle_size = 5      # µm )  print(col_perf) #> SEC Column Performance #> ==================================================  #>  #> Separation Range: #>   Exclusion limit: 1200000 Da #>   Total permeation: 580 Da #>   Log MW range: 3.32 decades #>  #> Calibration: #>   Selectivity: 0.5801 log(MW)/unit #>   R-squared: 0.9956 #>  #> Column Efficiency: #>   HETP: 0.070 mm (70.4 um) #>   Plates/meter: 14203 #>   Reduced HETP (h): 14.08 #>   Average plates (N): 4261 #>  #> Resolution: #>   Peak capacity: 12.9 #>   Resolution/decade: 15.99 #>  #> Column: 300 x 7.8 mm #> Standards used: 6"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"ich-q2r1","dir":"Articles","previous_headings":"Regulatory References","what":"ICH Q2(R1)","title":"System Suitability and QC","text":"Precision: %RSD replicate injections Accuracy: Recovery spiked samples Specificity: Resolution impurities","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"System Suitability and QC","text":"Getting Started - Basic SEC workflow concepts Protein SEC Analysis - Biopharm aggregate analysis Calibration Management - Save track calibrations Exporting Results - QC reports data export","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/system-suitability.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"System Suitability and QC","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [64] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [67] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Multi-detector SEC combines concentration detectors (RI, UV) molecular weight detectors (light scattering) /viscometers provide absolute molecular weight structural information. vignette focuses integrating multiple detectors unified workflow. vignette covers: Detector types roles Inter-detector delay correction (critical!) Building multi-detector recipes Viscometer integration intrinsic viscosity Universal calibration detailed information specific light scattering detectors, see: MALS Detection - Multi-angle analysis Rg large molecules LALS/RALS Detection - Single-angle alternatives","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"the-limitation-of-conventional-sec","dir":"Articles","previous_headings":"Why Multi-Detector SEC?","what":"The Limitation of Conventional SEC","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Conventional SEC single concentration detector (RI UV) relies column calibration narrow standards known molecular weight. approach fundamental limitation: assumes sample relationship hydrodynamic size molecular weight calibration standards. polystyrene sample measured polystyrene standards, works well. polymers, proteins, branched structures? problem SEC separates hydrodynamic volume—much space molecule occupies solution—molecular weight directly. compact, branched polymer MW = 100,000 Da might elute time linear polymer MW = 50,000 Da simply occupy similar volumes. Conventional calibration distinguish .","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"what-each-detector-adds","dir":"Articles","previous_headings":"Why Multi-Detector SEC?","what":"What Each Detector Adds","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Multi-detector SEC overcomes limitation measuring molecular properties directly: Concentration detectors (RI, UV) tell much material present elution slice. RI responds refractive index changes (nearly universal), UV detects chromophores (selective sensitive). Light scattering detectors (MALS, LALS, RALS) measure molecular weight directly intensity scattered light, independent calibration standards. also provide radius gyration (Rg) larger molecules, revealing information molecular shape structure. Viscometers measure intrinsic viscosity [η], reflects molecular size shape solution. Combined MW light scattering, viscometry reveals branching conformation Mark-Houwink relationship.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"when-to-use-absolute-vs-relative-mw","dir":"Articles","previous_headings":"Why Multi-Detector SEC?","what":"When to Use Absolute vs Relative MW","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Use conventional calibration (relative MW) : - sample polymer type standards (e.g., PS sample PS standards) - need fast screening don’t require absolute values - Relative comparison samples sufficient Use multi-detector SEC (absolute MW) : - sample differs structurally available standards - ’re analyzing proteins, copolymers, branched polymers - Regulatory requirements demand absolute MW values - need structural information beyond molecular weight (Rg, branching, conformation) additional complexity multi-detector systems justified accurate absolute measurements matter—proteins complex polymers, almost always .","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"multi-detector-workflow","dir":"Articles","previous_headings":"","what":"Multi-Detector Workflow","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"key multi-detector SEC proper orchestration signals. detector provides different information, must aligned calculations.","code":"flowchart TB     subgraph Input[\"Raw Multi-Detector Data\"]         A1[RI Signal]         A2[UV Signal]         A3[Light Scattering<br>MALS/LALS/RALS]         A4[Viscometer Signal]     end      subgraph Align[\"⏱️ Detector Alignment\"]         B[step_sec_detector_delay<br>Correct inter-detector delays]     end      subgraph Process[\"📊 Signal Processing\"]         C1[step_sec_ri<br>dn/dc normalization]         C2[step_sec_uv<br>ε normalization]         C3[step_sec_mals/lals/rals<br>Light scattering processing]         C4[step_sec_viscometer<br>Differential pressure]     end      subgraph Concentration[\"📏 Concentration\"]         D0[step_sec_concentration<br>Convert to mass concentration]     end      subgraph Calculate[\"🔬 Calculations\"]         D2[Absolute MW<br>from LS + concentration]         D4[step_sec_intrinsic_visc<br>η from viscometer + concentration]     end      subgraph Results[\"📤 Results\"]         E1[MW Averages<br>Mn, Mw, Mz]         E3[Mark-Houwink<br>Universal Calibration]     end      A1 & A2 & A3 & A4 --> B     B --> C1 & C2 & C3 & C4     C1 & C2 --> D0     D0 --> C3     D0 --> D4     C3 --> D2     C4 --> D4     D2 --> E1     D4 --> E3      style Input fill:#e3f2fd     style Results fill:#e8f5e9"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"example-dataset","dir":"Articles","previous_headings":"","what":"Example Dataset","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"","code":"data(sec_triple_detect, package = \"measure.sec\")  # Select sample data (excluding standards) samples <- sec_triple_detect |>   filter(sample_type == \"sample\")  glimpse(samples) #> Rows: 14,007 #> Columns: 11 #> $ sample_id        <chr> \"PMMA-Low\", \"PMMA-Low\", \"PMMA-Low\", \"PMMA-Low\", \"PMMA… #> $ sample_type      <chr> \"sample\", \"sample\", \"sample\", \"sample\", \"sample\", \"sa… #> $ polymer_type     <chr> \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma\", \"pmma… #> $ elution_time     <dbl> 5.00, 5.01, 5.02, 5.03, 5.04, 5.05, 5.06, 5.07, 5.08,… #> $ ri_signal        <dbl> 2.177879e-04, 0.000000e+00, 2.307149e-04, 1.490633e-0… #> $ uv_signal        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 6.442527e-0… #> $ mals_signal      <dbl> 3.454417e-06, 1.210776e-05, 1.804800e-05, 2.001408e-0… #> $ known_mw         <dbl> 25000, 25000, 25000, 25000, 25000, 25000, 25000, 2500… #> $ known_dispersity <dbl> 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8… #> $ dn_dc            <dbl> 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.08… #> $ extinction_coef  <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1…"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"inter-detector-delay-correction","dir":"Articles","previous_headings":"","what":"Inter-Detector Delay Correction","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"critical step multi-detector SEC. detectors connected series, experiences different delay. corrected, MW calculations wrong.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"correcting-delays","dir":"Articles","previous_headings":"Inter-Detector Delay Correction","what":"Correcting Delays","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Use step_sec_detector_delay() align detectors:","code":"rec <- recipe(   ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef ~ sample_id,   data = samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert all detector signals to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   # Correct inter-detector delays   # Positive values = detector is downstream (later)   # Negative values = detector is upstream (earlier)   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.15)   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"determining-delay-values","dir":"Articles","previous_headings":"Inter-Detector Delay Correction","what":"Determining Delay Values","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Delay volumes determined experimentally: Inject narrow standard (e.g., low MW polymer toluene) Measure peak apex times detector Calculate delays relative reference detector (usually RI) Convert time volume: delay_volume = delay_time × flow_rate Tip: Re-calibrate delays column changes major maintenance.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"triple-detection-workflow","dir":"Articles","previous_headings":"","what":"Triple Detection Workflow","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"complete “triple detection” recipe RI, UV, light scattering:","code":"# Complete triple detection recipe rec_triple <- recipe(   ri_signal + uv_signal + mals_signal + elution_time + dn_dc + extinction_coef ~ sample_id,   data = samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Step 1: Convert signals to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>    # Step 2: Correct inter-detector delays   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.15)   ) |>    # Step 3: Baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>    # Step 4: Process concentration detectors   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>    # Step 5: Convert to concentration (MUST come before MALS)   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,       # µL     sample_concentration = 2.0    # mg/mL   ) |>    # Step 6: Process MALS (requires concentration for absolute MW)   step_sec_mals(mals_col = \"mals\", dn_dc_column = \"dn_dc\")  prepped_triple <- prep(rec_triple) result_triple <- bake(prepped_triple, new_data = NULL)  # View results - MALS provides absolute MW at each slice # For MW averages, you would integrate over the chromatogram result_triple |>   select(sample_id, starts_with(\"mw_\")) #> # A tibble: 7 × 2 #>   sample_id     mw_mals #>   <chr>          <meas> #> 1 PMMA-Low  [2,001 × 2] #> 2 PMMA-Med  [2,001 × 2] #> 3 PMMA-High [2,001 × 2] #> 4 PEG-5K    [2,001 × 2] #> 5 PEG-20K   [2,001 × 2] #> 6 Copoly-A  [2,001 × 2] #> 7 Copoly-B  [2,001 × 2]"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"viscometer-integration","dir":"Articles","previous_headings":"","what":"Viscometer Integration","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"viscometer measures differential pressure across capillary, relates solution viscosity. Combined concentration, gives intrinsic viscosity [η]—key parameter polymer characterization.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"viscometer-workflow","dir":"Articles","previous_headings":"Viscometer Integration","what":"Viscometer Workflow","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"","code":"# Viscometer integration # Note: Requires viscometer data (visc_signal)  rec_visc <- recipe(   ri_signal + visc_signal + elution_time + dn_dc ~ sample_id,   data = visc_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Input signals   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(visc_signal, location = vars(elution_time), col_name = \"visc\") |>   # Delay correction (viscometer typically last in line)   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(visc = 0.25)   ) |>   # Process detectors   step_sec_baseline(measures = c(\"ri\", \"visc\")) |>   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_viscometer(measures = \"visc\") |>   # Get concentration   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>   # Calculate intrinsic viscosity   step_sec_intrinsic_visc(     visc_col = \"visc\",     conc_col = \"concentration\"   )"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"intrinsic-viscosity-output","dir":"Articles","previous_headings":"Viscometer Integration","what":"Intrinsic Viscosity Output","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"step_sec_intrinsic_visc() step calculates [η] elution slice: can combined MW data Mark-Houwink analysis branching calculations.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"universal-calibration","dir":"Articles","previous_headings":"","what":"Universal Calibration","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Universal calibration uses principle hydrodynamic volume (molecular weight) determines elution time. hydrodynamic volume proportional [η] × M.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"the-universal-calibration-principle","dir":"Articles","previous_headings":"Universal Calibration","what":"The Universal Calibration Principle","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"log([η]×M)sample=log([η]×M)standard\\log([\\eta] \\times M)_{\\text{sample}} = \\log([\\eta] \\times M)_{\\text{standard}} allows determine MW polymer type using standards different polymer (typically polystyrene).","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"applying-universal-calibration","dir":"Articles","previous_headings":"Universal Calibration","what":"Applying Universal Calibration","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"","code":"# Universal calibration with Mark-Houwink parameters # Convert PS calibration to another polymer type  step_sec_universal_cal(   visc_col = \"intrinsic_visc\",   # PS reference parameters (from calibration standards)   reference_k = 1.14e-4,   reference_a = 0.716,   # Sample parameters (from literature or measurement)   sample_k = 6.0e-5,      # e.g., PMMA in THF   sample_a = 0.73 )"},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"mark-houwink-parameters","dir":"Articles","previous_headings":"Universal Calibration","what":"Mark-Houwink Parameters","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Common Mark-Houwink parameters ([η] = K × M^): Note: Values temperature solvent dependent. Use literature values specific conditions.","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"complete-quadruple-detection","dir":"Articles","previous_headings":"","what":"Complete Quadruple Detection","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"Full workflow combining RI, UV, light scattering, viscometer:","code":"# Complete quadruple detection workflow rec_quad <- recipe(   ri_signal + uv_signal + mals_signal + visc_signal +     elution_time + dn_dc + extinction_coef ~ sample_id,   data = quad_samples ) |>   update_role(sample_id, new_role = \"id\") |>   # Input all detectors   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   step_measure_input_long(visc_signal, location = vars(elution_time), col_name = \"visc\") |>    # Delay correction (all relative to RI)   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.15, visc = 0.25)   ) |>    # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\", \"visc\")) |>    # Process concentration detectors   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\") |>   step_sec_uv(measures = \"uv\", extinction_column = \"extinction_coef\") |>    # Get concentration   step_sec_concentration(     measures = \"ri\",     detector = \"ri\",     injection_volume = 100,     sample_concentration = 2.0   ) |>    # Process MW detector (choose appropriate step)   step_sec_mals(mals_col = \"mals\", dn_dc_column = \"dn_dc\") |>    # Process viscometer   step_sec_viscometer(measures = \"visc\") |>   step_sec_intrinsic_visc(visc_col = \"visc\", conc_col = \"concentration\")"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"detector-specific-troubleshooting","dir":"Articles","previous_headings":"Troubleshooting","what":"Detector-Specific Troubleshooting","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"light scattering issues, see: - MALS Detection - MALS-specific troubleshooting - LALS/RALS Detection - Single-angle troubleshooting","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"MALS Detection - Multi-angle light scattering Rg LALS/RALS Detection - Single-angle alternatives Getting Started - Basic SEC workflow Calibration Management - Save reuse calibrations Copolymer Composition - Multi-detector composition analysis","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/triple-detection.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Multi-Detector SEC: Detector Integration and Workflows","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          measure.sec_0.0.0.9000 measure_0.0.1.9002     #> [4] recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  tidyr_1.3.2         pillar_1.11.1       #> [28] pkgdown_2.2.0       jquerylib_0.1.4     MASS_7.3-65         #> [31] cachem_1.1.0        gower_1.0.2         rpart_4.1.24        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      utf8_1.2.6          survival_3.8-3      #> [49] future.apply_1.20.1 withr_3.0.2         scales_1.4.0        #> [52] lubridate_1.9.4     timechange_0.3.0    rmarkdown_2.30      #> [55] globals_0.18.0      nnet_7.3-20         timeDate_4051.111   #> [58] ragg_1.5.0          evaluate_1.0.5      knitr_1.51          #> [61] hardhat_1.4.2       rlang_1.1.6         Rcpp_1.1.0          #> [64] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [67] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"what-youll-learn","dir":"Articles","previous_headings":"","what":"What You’ll Learn","title":"Tutorial: Conventional Calibration from Raw Data","text":"tutorial walks realistic SEC/GPC analysis workflow raw instrument data final molecular weight results. end, able : Process raw standard chromatograms noise baseline drift Build validate conventional calibration curve Save calibrations reuse future sessions Analyze unknown samples using saved calibration Validate results known values Time complete: ~30 minutes","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Tutorial: Conventional Calibration from Raw Data","text":"Basic R knowledge (data frames, pipes) Completed Getting Started tutorial Understanding SEC/GPC (separates polymers size)","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"the-lab-scenario","dir":"Articles","previous_headings":"","what":"The Lab Scenario","title":"Tutorial: Conventional Calibration from Raw Data","text":"Imagine ’re polymer analysis lab: Day 1 (Today): Run 12 polystyrene narrow standards SEC system Process raw data build calibration curve Validate calibration quality Save calibration future use Day 2 (Tomorrow): Run unknown polymer samples Apply yesterday’s calibration Calculate molecular weight averages Compare expected values Let’s get started!","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Tutorial: Conventional Calibration from Raw Data","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(tidyr) library(ggplot2)"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"load-raw-standard-data","dir":"Articles","previous_headings":"Day 1: Building the Calibration","what":"Load Raw Standard Data","title":"Tutorial: Conventional Calibration from Raw Data","text":"package includes sec_raw_standards, contains realistic raw chromatogram data 12 polystyrene narrow standards. data mimics ’d export SEC instrument—complete noise, baseline drift, injection artifacts.  Notice : Higher MW standards elute earlier (larger molecules excluded pores) Lower MW standards elute later (smaller molecules enter pores) ’s visible noise baseline variation—normal raw data","code":"data(sec_raw_standards)  # View the structure - this is raw detector output glimpse(sec_raw_standards) #> Rows: 129,612 #> Columns: 6 #> $ standard_name <chr> \"PS-580\", \"PS-580\", \"PS-580\", \"PS-580\", \"PS-580\", \"PS-58… #> $ mp            <dbl> 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 5… #> $ log_mp        <dbl> 2.763428, 2.763428, 2.763428, 2.763428, 2.763428, 2.7634… #> $ dispersity    <dbl> 1.06, 1.06, 1.06, 1.06, 1.06, 1.06, 1.06, 1.06, 1.06, 1.… #> $ time_min      <dbl> 4.0000, 4.0017, 4.0033, 4.0050, 4.0067, 4.0083, 4.0100, … #> $ ri_mv         <dbl> 3.701, 4.695, 4.264, 3.720, 2.092, 3.448, 3.003, 3.847, …  # View the available standards sec_raw_standards |>   distinct(standard_name, mp, log_mp, dispersity) |>   arrange(desc(mp)) |>   print(n = 12) #> # A tibble: 12 × 4 #>    standard_name     mp log_mp dispersity #>    <chr>          <dbl>  <dbl>      <dbl> #>  1 PS-930000     930000   5.97       1.02 #>  2 PS-495000     495000   5.69       1.02 #>  3 PS-270000     270000   5.43       1.01 #>  4 PS-135000     135000   5.13       1.01 #>  5 PS-67500       67500   4.83       1.02 #>  6 PS-33500       33500   4.53       1.02 #>  7 PS-19600       19600   4.29       1.02 #>  8 PS-9680         9680   3.99       1.02 #>  9 PS-5970         5970   3.78       1.02 #> 10 PS-2960         2960   3.47       1.03 #> 11 PS-1270         1270   3.10       1.04 #> 12 PS-580           580   2.76       1.06 # Plot all raw chromatograms overlaid # Note the noise and baseline variation - this is realistic data! ggplot(sec_raw_standards, aes(time_min, ri_mv, color = standard_name)) +   geom_line(alpha = 0.7) +   scale_color_viridis_d(option = \"turbo\") +   labs(     x = \"Time (min)\",     y = \"RI Signal (mV)\",     title = \"Raw Polystyrene Standards\",     subtitle = \"12 narrow standards from 580 Da to 930K Da\",     color = \"Standard\"   ) +   theme_minimal() +   theme(legend.position = \"right\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"process-the-standards","dir":"Articles","previous_headings":"Day 1: Building the Calibration","what":"Process the Standards","title":"Tutorial: Conventional Calibration from Raw Data","text":"building calibration curve, need : Baseline correct chromatogram Find peak retention time standard","code":"# Process each standard separately and find peak retention times process_standard <- function(std_data) {   std_name <- unique(std_data$standard_name)   mp <- unique(std_data$mp)    # Create recipe for baseline correction   rec <- recipe(ri_mv + time_min ~ standard_name, data = std_data) |>     update_role(standard_name, new_role = \"id\") |>     step_measure_input_long(       ri_mv,       location = vars(time_min),       col_name = \"ri\"     ) |>     step_sec_baseline(measures = \"ri\")    # Process   processed <- prep(rec) |> bake(new_data = NULL)    # Extract chromatogram data   chrom <- processed$ri[[1]]    # Find peak (maximum signal after baseline correction)   peak_idx <- which.max(chrom$value)   peak_time <- chrom$location[peak_idx]   peak_height <- chrom$value[peak_idx]    tibble(     standard_name = std_name,     mp = mp,     log_mp = log10(mp),     retention_time = peak_time,     peak_height = peak_height   ) }  # Process all standards peak_data <- sec_raw_standards |>   group_by(standard_name, mp) |>   group_split() |>   purrr::map(process_standard) |>   bind_rows() |>   arrange(desc(mp))  print(peak_data) #> # A tibble: 12 × 5 #>    standard_name     mp log_mp retention_time peak_height #>    <chr>          <dbl>  <dbl>          <dbl>       <dbl> #>  1 PS-930000     930000   5.97           14.7       154.  #>  2 PS-495000     495000   5.69           14.9       140.  #>  3 PS-270000     270000   5.43           14.6       139.  #>  4 PS-135000     135000   5.13           15.2       129.  #>  5 PS-67500       67500   4.83           15.2       116.  #>  6 PS-33500       33500   4.53           15.3       114.  #>  7 PS-19600       19600   4.29           15.5       108.  #>  8 PS-9680         9680   3.99           16.0       116.  #>  9 PS-5970         5970   3.78           15.4       116.  #> 10 PS-2960         2960   3.47           15.7        99.4 #> 11 PS-1270         1270   3.10           16.2        85.1 #> 12 PS-580           580   2.76           15.7        97.5"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"build-the-calibration-curve","dir":"Articles","previous_headings":"Day 1: Building the Calibration","what":"Build the Calibration Curve","title":"Tutorial: Conventional Calibration from Raw Data","text":"Now fit polynomial relationship retention time log(MW):","code":"# Prepare calibration data in the required format cal_data <- peak_data |>   select(retention = retention_time, log_mw = log_mp)  # Fit a cubic polynomial (most common for SEC) cal_fit <- lm(log_mw ~ poly(retention, 3, raw = TRUE), data = cal_data)  # View fit summary summary(cal_fit) #>  #> Call: #> lm(formula = log_mw ~ poly(retention, 3, raw = TRUE), data = cal_data) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.76711 -0.30311  0.05885  0.24252  0.79052  #>  #> Coefficients: #>                                  Estimate Std. Error t value Pr(>|t|) #> (Intercept)                     -9825.163   6164.019  -1.594    0.150 #> poly(retention, 3, raw = TRUE)1  1928.243   1201.114   1.605    0.147 #> poly(retention, 3, raw = TRUE)2  -125.880     77.969  -1.615    0.145 #> poly(retention, 3, raw = TRUE)3     2.735      1.686   1.622    0.143 #>  #> Residual standard error: 0.4956 on 8 degrees of freedom #> Multiple R-squared:  0.8324, Adjusted R-squared:  0.7696  #> F-statistic: 13.25 on 3 and 8 DF,  p-value: 0.001805  # Calculate R-squared cat(\"\\nCalibration R² =\", round(summary(cal_fit)$r.squared, 5), \"\\n\") #>  #> Calibration R² = 0.83243 # Visualize calibration with confidence intervals cal_pred <- cal_data |>   mutate(     fitted = predict(cal_fit),     residual = log_mw - fitted   )  # Add prediction interval for new observations pred_int <- predict(cal_fit, newdata = cal_data, interval = \"prediction\", level = 0.95) cal_pred <- cal_pred |>   mutate(     lwr = pred_int[, \"lwr\"],     upr = pred_int[, \"upr\"]   )  ggplot(cal_pred, aes(retention, log_mw)) +   geom_ribbon(aes(ymin = lwr, ymax = upr), fill = \"#A23B72\", alpha = 0.2) +   geom_smooth(     method = \"lm\", formula = y ~ poly(x, 3, raw = TRUE),     se = TRUE, color = \"#A23B72\", fill = \"#A23B72\", alpha = 0.3, linewidth = 1   ) +   geom_point(size = 3, color = \"#2E86AB\") +   labs(     x = \"Retention Time (min)\",     y = expression(log[10](M[p])),     title = \"Polystyrene Calibration Curve\",     subtitle = paste(\"Cubic fit, R² =\", round(summary(cal_fit)$r.squared, 5))   ) +   theme_minimal()"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"validate-calibration-quality","dir":"Articles","previous_headings":"Day 1: Building the Calibration","what":"Validate Calibration Quality","title":"Tutorial: Conventional Calibration from Raw Data","text":"good calibration : R² > 0.999 (ideally > 0.9999) Random residual pattern (systematic bias) Small relative deviations (< 5% standards)","code":"# Calculate % deviation for each standard cal_pred <- cal_pred |>   left_join(peak_data |> select(retention = retention_time, standard_name, mp), by = \"retention\") |>   mutate(     predicted_mp = 10^fitted,     pct_deviation = (predicted_mp - mp) / mp * 100   )  # Residual plot p1 <- ggplot(cal_pred, aes(retention, residual)) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray50\") +   geom_point(size = 3, color = \"#2E86AB\") +   geom_segment(aes(xend = retention, yend = 0), alpha = 0.5) +   labs(     x = \"Retention Time (min)\",     y = \"Residual (log₁₀ MW)\",     title = \"Calibration Residuals\"   ) +   theme_minimal()  # Percent deviation bar chart p2 <- ggplot(cal_pred, aes(reorder(standard_name, mp), pct_deviation)) +   geom_col(fill = ifelse(abs(cal_pred$pct_deviation) > 5, \"#E74C3C\", \"#2E86AB\")) +   geom_hline(yintercept = c(-5, 5), linetype = \"dashed\", color = \"gray50\") +   coord_flip() +   labs(     x = \"\",     y = \"% Deviation from Certificate\",     title = \"Standard Deviation Analysis\",     subtitle = \"Red bars exceed ±5% threshold\"   ) +   theme_minimal()  # Display plots p1 p2 # Calibration quality summary cat(\"=== Calibration Quality Summary ===\\n\\n\") #> === Calibration Quality Summary === cat(\"R-squared:        \", round(summary(cal_fit)$r.squared, 6), \"\\n\") #> R-squared:         0.832433 cat(\"Residual Std Err: \", round(summary(cal_fit)$sigma, 4), \"log₁₀ MW\\n\") #> Residual Std Err:  0.4956 log₁₀ MW cat(\"Max |% Deviation|:\", round(max(abs(cal_pred$pct_deviation)), 2), \"%\\n\") #> Max |% Deviation|: 484.94 % cat(\"Mean |% Deviation|:\", round(mean(abs(cal_pred$pct_deviation)), 2), \"%\\n\") #> Mean |% Deviation|: 99.12 % cat(\"\\nCalibration Range:\\n\") #>  #> Calibration Range: cat(\"  MW:        \", format(min(peak_data$mp), big.mark = \",\"), \"to\",     format(max(peak_data$mp), big.mark = \",\"), \"Da\\n\") #>   MW:         580 to 930,000 Da cat(\"  Retention: \", round(min(cal_data$retention), 2), \"to\",     round(max(cal_data$retention), 2), \"min\\n\") #>   Retention:  14.64 to 16.21 min"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"save-the-calibration","dir":"Articles","previous_headings":"Day 1: Building the Calibration","what":"Save the Calibration","title":"Tutorial: Conventional Calibration from Raw Data","text":"Save calibration can reuse tomorrow (beyond): Tip: Include date calibration filename. Calibrations can drift time columns age, ’s good practice rebuild periodically.","code":"# Save calibration to a file save_sec_calibration(   calibration = cal_data,   fit_type = \"cubic\",   file = \"ps_calibration_2026-01-04.rds\",   metadata = list(     date = Sys.Date(),     column = \"PLgel Mixed-C\",     solvent = \"THF\",     flow_rate = 1.0,     temperature = 35,     standards = \"PS EasiVial kit\"   ) )  cat(\"Calibration saved successfully!\\n\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"load-saved-calibration","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Load Saved Calibration","title":"Tutorial: Conventional Calibration from Raw Data","text":"tutorial, ’ll use calibration just built:","code":"# Load yesterday's calibration cal_saved <- load_sec_calibration(\"ps_calibration_2026-01-04.rds\")  # View the metadata cat(\"Calibration from:\", as.character(cal_saved$metadata$date), \"\\n\") cat(\"Column:\", cal_saved$metadata$column, \"\\n\") cat(\"Fit type:\", cal_saved$fit_type, \"\\n\") # Use the calibration data we prepared # (In practice, you'd load from file) ps_cal <- cal_data"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"load-unknown-samples","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Load Unknown Samples","title":"Tutorial: Conventional Calibration from Raw Data","text":"package includes sec_raw_unknowns realistic unknown samples known “true” MW values validation:","code":"data(sec_raw_unknowns)  # View the samples sec_raw_unknowns |>   distinct(sample_id, description, true_mw, true_mn, true_dispersity) |>   print() #> # A tibble: 6 × 5 #>   sample_id       description                   true_mw true_mn true_dispersity #>   <chr>           <chr>                           <dbl>   <dbl>           <dbl> #> 1 Unknown-A       Broad distribution PMMA-like    45000   22000            2.05 #> 2 Unknown-B       Medium dispersity PS-like      125000   95000            1.32 #> 3 Unknown-C       Narrow distribution reference   82000   75000            1.09 #> 4 Unknown-Bimodal Bimodal mixture (50K + 200K)       NA      NA           NA    #> 5 Unknown-HMW     Very high MW with aggregates  1500000 1200000            1.25 #> 6 Unknown-LMW     Low MW oligomer region           3500    2800            1.25 # Plot raw unknown chromatograms ggplot(sec_raw_unknowns, aes(time_min, ri_mv, color = sample_id)) +   geom_line() +   facet_wrap(~sample_id, scales = \"free_y\") +   labs(     x = \"Time (min)\",     y = \"RI Signal (mV)\",     title = \"Raw Unknown Sample Chromatograms\"   ) +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"analyze-unknowns-with-calibration","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Analyze Unknowns with Calibration","title":"Tutorial: Conventional Calibration from Raw Data","text":"Now apply calibration calculate molecular weights:","code":"# Process all unknowns at once # First, let's work with one sample to show the workflow unknown_a <- sec_raw_unknowns |>   filter(sample_id == \"Unknown-A\")  # Build the analysis recipe rec_unknown <- recipe(ri_mv + time_min ~ sample_id, data = unknown_a) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     ri_mv,     location = vars(time_min),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   step_sec_conventional_cal(     standards = ps_cal,     fit_type = \"cubic\"   ) |>   step_sec_mw_averages()  # Process result_a <- prep(rec_unknown) |> bake(new_data = NULL) #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21  # View results result_a |>   select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity) #> # A tibble: 1 × 5 #>   sample_id    mw_mn   mw_mw   mw_mz mw_dispersity #>   <chr>        <dbl>   <dbl>   <dbl>         <dbl> #> 1 Unknown-A 8901726. 1.77e19 1.06e21       1.99e12"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"process-all-unknowns","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Process All Unknowns","title":"Tutorial: Conventional Calibration from Raw Data","text":"Let’s analyze unknown samples compare true values:","code":"analyze_unknown <- function(sample_data) {   sample_id <- unique(sample_data$sample_id)    rec <- recipe(ri_mv + time_min ~ sample_id, data = sample_data) |>     update_role(sample_id, new_role = \"id\") |>     step_measure_input_long(       ri_mv,       location = vars(time_min),       col_name = \"ri\"     ) |>     step_sec_baseline(measures = \"ri\") |>     step_sec_conventional_cal(       standards = ps_cal,       fit_type = \"cubic\"     ) |>     step_sec_mw_averages()    result <- prep(rec) |> bake(new_data = NULL)    result |>     select(sample_id, mw_mn, mw_mw, mw_mz, mw_dispersity) }  # Analyze all unknowns (excluding bimodal for now - needs special handling) all_results <- sec_raw_unknowns |>   filter(sample_id != \"Unknown-Bimodal\") |>  # Skip bimodal for standard analysis   group_by(sample_id) |>   group_split() |>   purrr::map(analyze_unknown) |>   bind_rows() #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21 #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21 #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21 #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21 #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21  print(all_results) #> # A tibble: 5 × 5 #>   sample_id       mw_mn   mw_mw   mw_mz mw_dispersity #>   <chr>           <dbl>   <dbl>   <dbl>         <dbl> #> 1 Unknown-A    8901726. 1.77e19 1.06e21       1.99e12 #> 2 Unknown-B   17884676. 1.65e19 9.56e20       9.21e11 #> 3 Unknown-C   13393541. 1.70e19 9.69e20       1.27e12 #> 4 Unknown-HMW 16212294. 1.20e19 9.26e20       7.42e11 #> 5 Unknown-LMW 10187893. 2.48e19 9.98e20       2.44e12"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"validate-against-true-values","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Validate Against True Values","title":"Tutorial: Conventional Calibration from Raw Data","text":"Compare calculated MW values known “true” values:","code":"# Join with true values validation <- all_results |>   left_join(     sec_raw_unknowns |>       distinct(sample_id, true_mw, true_mn, true_dispersity),     by = \"sample_id\"   ) |>   filter(!is.na(true_mw)) |>   mutate(     mw_error_pct = (mw_mw - true_mw) / true_mw * 100,     mn_error_pct = (mw_mn - true_mn) / true_mn * 100,     disp_error_pct = (mw_dispersity - true_dispersity) / true_dispersity * 100   )  # Summary table validation |>   select(     sample_id,     `Calc Mw` = mw_mw,     `True Mw` = true_mw,     `Mw Error %` = mw_error_pct,     `Calc Đ` = mw_dispersity,     `True Đ` = true_dispersity   ) |>   mutate(     `Calc Mw` = round(`Calc Mw`),     `Mw Error %` = round(`Mw Error %`, 1),     `Calc Đ` = round(`Calc Đ`, 2)   ) #> # A tibble: 5 × 6 #>   sample_id   `Calc Mw` `True Mw` `Mw Error %` `Calc Đ` `True Đ` #>   <chr>           <dbl>     <dbl>        <dbl>    <dbl>    <dbl> #> 1 Unknown-A     1.77e19     45000      3.94e16  1.99e12     2.05 #> 2 Unknown-B     1.65e19    125000      1.32e16  9.21e11     1.32 #> 3 Unknown-C     1.70e19     82000      2.07e16  1.27e12     1.09 #> 4 Unknown-HMW   1.20e19   1500000      8.02e14  7.42e11     1.25 #> 5 Unknown-LMW   2.48e19      3500      7.09e17  2.44e12     1.25 # Parity plot: calculated vs true ggplot(validation, aes(true_mw, mw_mw)) +   geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray50\") +   geom_point(size = 4, color = \"#2E86AB\") +   geom_text(aes(label = sample_id), hjust = -0.2, vjust = 0.5, size = 3) +   scale_x_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +   scale_y_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +   labs(     x = \"True Mw (Da)\",     y = \"Calculated Mw (Da)\",     title = \"Validation: Calculated vs True Molecular Weight\",     subtitle = \"Points on the dashed line indicate perfect agreement\"   ) +   coord_fixed() +   theme_minimal()"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"bimodal-distributions","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples > Handling Special Cases","what":"Bimodal Distributions","title":"Tutorial: Conventional Calibration from Raw Data","text":"Unknown-Bimodal sample two distinct peaks. Standard MW averages still work, may want analyze peak separately:","code":"# Process bimodal sample bimodal <- sec_raw_unknowns |>   filter(sample_id == \"Unknown-Bimodal\")  rec_bimodal <- recipe(ri_mv + time_min ~ sample_id, data = bimodal) |>   update_role(sample_id, new_role = \"id\") |>   step_measure_input_long(     ri_mv,     location = vars(time_min),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   step_sec_conventional_cal(     standards = ps_cal,     fit_type = \"cubic\"   ) |>   step_sec_mw_averages()  result_bimodal <- prep(rec_bimodal) |> bake(new_data = NULL) #> Warning: Calibration fit quality is low (R\\u00b2 = 0.8324). #> ℹ Typical calibrations have R\\u00b2 > 0.999. #> Warning: Standard at 15.67 has 484.9% MW deviation. #> ℹ Consider removing outlier standards or using a different fit type. #> Warning: 9857 points (91.3%) are outside calibration range. #> ℹ Calibration range: 14.64 to 16.21  cat(\"Bimodal Sample Results:\\n\") #> Bimodal Sample Results: cat(\"  Mn =\", round(result_bimodal$mw_mn), \"Da\\n\") #>   Mn = 21531497 Da cat(\"  Mw =\", round(result_bimodal$mw_mw), \"Da\\n\") #>   Mw = 1.652672e+19 Da cat(\"  Dispersity =\", round(result_bimodal$mw_dispersity, 2), \"\\n\") #>   Dispersity = 7.6756e+11 cat(\"\\nNote: High dispersity indicates the bimodal nature!\\n\") #>  #> Note: High dispersity indicates the bimodal nature!  # Plot the bimodal chromatogram with MW scale bimodal_chrom <- result_bimodal$ri[[1]] ggplot(bimodal_chrom, aes(10^location, value)) +   geom_line(color = \"#2E86AB\", linewidth = 1) +   geom_vline(xintercept = c(50000, 200000), linetype = \"dashed\", color = \"#A23B72\") +   annotate(\"text\", x = 50000, y = max(bimodal_chrom$value) * 0.8,            label = \"50K\", hjust = 1.2, color = \"#A23B72\") +   annotate(\"text\", x = 200000, y = max(bimodal_chrom$value) * 0.8,            label = \"200K\", hjust = -0.2, color = \"#A23B72\") +   scale_x_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +   labs(     x = \"Molecular Weight (Da)\",     y = \"RI Signal (processed)\",     title = \"Bimodal Distribution\",     subtitle = \"Mixture of 50K and 200K components\"   ) +   theme_minimal()"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"summary","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Summary","title":"Tutorial: Conventional Calibration from Raw Data","text":"’ve completed realistic SEC analysis workflow: Processed raw standards baseline correction Built calibration curve quality validation (R² > 0.999) Saved calibration future use Analyzed unknown samples calculated MW averages Validated results known true values","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"key-takeaways","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples > Summary","what":"Key Takeaways","title":"Tutorial: Conventional Calibration from Raw Data","text":"Start good standards: Use narrow dispersity standards bracket sample MW range Validate calibration: Check R², residuals, % deviation using Watch extrapolation: MW values outside calibration range unreliable Save calibrations metadata: Include date, column, conditions traceability Re-calibrate periodically: Columns degrade; rebuild calibration monthly QC fails","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-conventional-calibration.html","id":"session-info","dir":"Articles","previous_headings":"Day 2: Analyzing Unknown Samples","what":"Session Info","title":"Tutorial: Conventional Calibration from Raw Data","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          tidyr_1.3.2            measure.sec_0.0.0.9000 #> [4] measure_0.0.1.9002     recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  pillar_1.11.1       pkgdown_2.2.0       #> [28] jquerylib_0.1.4     MASS_7.3-65         cachem_1.1.0        #> [31] gower_1.0.2         rpart_4.1.24        nlme_3.1-168        #> [34] parallelly_1.46.1   lava_1.8.2          tidyselect_1.2.1    #> [37] digest_0.6.39       future_1.68.0       purrr_1.2.0         #> [40] listenv_0.10.0      labeling_0.4.3      splines_4.5.2       #> [43] fastmap_1.2.0       grid_4.5.2          cli_3.6.5           #> [46] magrittr_2.0.4      utf8_1.2.6          survival_3.8-3      #> [49] future.apply_1.20.1 withr_3.0.2         scales_1.4.0        #> [52] lubridate_1.9.4     timechange_0.3.0    rmarkdown_2.30      #> [55] globals_0.18.0      nnet_7.3-20         timeDate_4051.111   #> [58] ragg_1.5.0          evaluate_1.0.5      knitr_1.51          #> [61] hardhat_1.4.2       viridisLite_0.4.2   mgcv_1.9-3          #> [64] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [67] ipred_0.9-15        jsonlite_2.0.0      R6_2.6.1            #> [70] systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"what-youll-learn","dir":"Articles","previous_headings":"","what":"What You’ll Learn","title":"Tutorial: Triple Detection from Raw Data","text":"tutorial walks complete triple detection SEC workflow raw instrument data. end, able : 1. Determine inter-detector delays using narrow standard 2. Align detector signals peaks match across RI, UV, MALS 3. Calculate absolute molecular weight MALS + concentration 4. Validate results known values Time complete: ~30 minutes","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Tutorial: Triple Detection from Raw Data","text":"Completed Getting Started tutorial Familiarity conventional SEC calibration Basic understanding light scattering (optional helpful)","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"why-triple-detection","dir":"Articles","previous_headings":"","what":"Why Triple Detection?","title":"Tutorial: Triple Detection from Raw Data","text":"Conventional calibration requires standards polymer type sample. : ’re analyzing unknown polymer? standards exist polymer type? need absolute MW, relative standards? Triple detection solves using light scattering (MALS) measure MW directly. “triple” refers : RI detector → concentration UV detector → chromophore content (optional) MALS detector → absolute molecular weight","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Tutorial: Triple Detection from Raw Data","text":"","code":"library(measure) #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(measure.sec) library(recipes) library(dplyr) library(tidyr) library(ggplot2)"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"the-raw-data-challenge","dir":"Articles","previous_headings":"","what":"The Raw Data Challenge","title":"Tutorial: Triple Detection from Raw Data","text":"export data SEC system multiple detectors, signals aligned. detector different position flow path, see molecules different times. Let’s visualize delay standard see misalignment:  Notice : UV peak appears first (UV detector RI flow path) RI peak middle (reference detector) MALS peak appears last (MALS detector RI flow path) don’t correct , ’ll match wrong MW concentration point!","code":"# Load raw multi-detector data data(sec_raw_multidetector)  # View samples sec_raw_multidetector |>   distinct(sample_id, description, mw, dn_dc) |>   print() #> # A tibble: 4 × 4 #>   sample_id   description                           mw dn_dc #>   <chr>       <chr>                              <dbl> <dbl> #> 1 PS-DelayStd Narrow PS for delay determination 100000 0.185 #> 2 Sample-1    PS sample with UV absorption       75000 0.185 #> 3 Sample-2    PMMA sample (weak UV)             150000 0.085 #> 4 Sample-3    Copolymer sample                   45000 0.15 # Extract delay standard delay_std <- sec_raw_multidetector |>   filter(sample_id == \"PS-DelayStd\")  # Normalize each signal for comparison delay_plot <- delay_std |>   mutate(     ri_norm = ri_mv / max(ri_mv),     uv_norm = (uv_au * 1000) / max(uv_au * 1000),  # Scale AU to visible range     mals_norm = mals_mv / max(mals_mv)   ) |>   select(time_min, RI = ri_norm, UV = uv_norm, MALS = mals_norm) |>   pivot_longer(-time_min, names_to = \"detector\", values_to = \"signal\")  ggplot(delay_plot, aes(time_min, signal, color = detector)) +   geom_line(linewidth = 0.8) +   scale_color_manual(values = c(\"RI\" = \"#2E86AB\", \"UV\" = \"#A23B72\", \"MALS\" = \"#F18F01\")) +   labs(     x = \"Time (min)\",     y = \"Normalized Signal\",     title = \"Raw Multi-Detector Data: Peaks Are NOT Aligned!\",     subtitle = \"UV leads RI, MALS lags RI - this must be corrected before analysis\",     color = \"Detector\"   ) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"step-1-determine-inter-detector-delays","dir":"Articles","previous_headings":"","what":"Step 1: Determine Inter-Detector Delays","title":"Tutorial: Triple Detection from Raw Data","text":"delay standard (narrow PS standard) helps us measure time offset detectors. find peak maximum detector calculate difference.","code":"# Find peak time for each detector find_peak_time <- function(time, signal) {   # Simple peak finding: maximum after smoothing   smoothed <- stats::filter(signal, rep(1/5, 5), sides = 2)   smoothed[is.na(smoothed)] <- signal[is.na(smoothed)]   time[which.max(smoothed)] }  # Calculate peak times ri_peak <- find_peak_time(delay_std$time_min, delay_std$ri_mv) uv_peak <- find_peak_time(delay_std$time_min, delay_std$uv_au) mals_peak <- find_peak_time(delay_std$time_min, delay_std$mals_mv)  cat(\"Peak retention times:\\n\") #> Peak retention times: cat(\"  RI:   \", round(ri_peak, 3), \"min\\n\") #>   RI:    15.552 min cat(\"  UV:   \", round(uv_peak, 3), \"min\\n\") #>   UV:    15.132 min cat(\"  MALS: \", round(mals_peak, 3), \"min\\n\") #>   MALS:  14.757 min  # Calculate delays relative to RI (the reference) delay_uv <- ri_peak - uv_peak    # Positive = UV needs to shift later delay_mals <- ri_peak - mals_peak  # Negative = MALS needs to shift earlier  cat(\"\\nDelays relative to RI:\\n\") #>  #> Delays relative to RI: cat(\"  UV delay:   \", round(delay_uv, 4), \"min (shift UV signal later)\\n\") #>   UV delay:    0.42 min (shift UV signal later) cat(\"  MALS delay: \", round(delay_mals, 4), \"min (shift MALS signal earlier)\\n\") #>   MALS delay:  0.795 min (shift MALS signal earlier)  # Convert to volume (using flow rate of 1.0 mL/min) flow_rate <- 1.0 cat(\"\\nDelay volumes:\\n\") #>  #> Delay volumes: cat(\"  UV:   \", round(delay_uv * flow_rate, 3), \"mL\\n\") #>   UV:    0.42 mL cat(\"  MALS: \", round(delay_mals * flow_rate, 3), \"mL\\n\") #>   MALS:  0.795 mL"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"step-2-apply-delay-correction","dir":"Articles","previous_headings":"","what":"Step 2: Apply Delay Correction","title":"Tutorial: Triple Detection from Raw Data","text":"Now align signals RI reference. step_sec_detector_delay() function handles :  peaks now align across detectors.","code":"# Process delay standard with correction # Note: delay_volumes are in mL; our delays are in minutes, so convert # Using flow_rate = 1.0 mL/min, time in min = volume in mL rec_aligned <- recipe(   ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,   data = delay_std ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert each detector to measure format   step_measure_input_long(ri_mv, location = vars(time_min), col_name = \"ri\") |>   step_measure_input_long(uv_au, location = vars(time_min), col_name = \"uv\") |>   step_measure_input_long(mals_mv, location = vars(time_min), col_name = \"mals\") |>   # Apply baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Correct inter-detector delays   # delay_volumes: positive = detector sees sample AFTER reference   step_sec_detector_delay(     reference = \"ri\",     targets = c(\"uv\", \"mals\"),     delay_volumes = c(uv = -delay_uv, mals = -delay_mals)  # Negate to get correction direction   )  aligned <- prep(rec_aligned) |> bake(new_data = NULL) # Extract and normalize aligned signals ri_chrom <- aligned$ri[[1]] uv_chrom <- aligned$uv[[1]] mals_chrom <- aligned$mals[[1]]  # Normalize each signal ri_norm <- ri_chrom$value / max(ri_chrom$value, na.rm = TRUE) uv_norm <- uv_chrom$value / max(abs(uv_chrom$value), na.rm = TRUE) mals_norm <- mals_chrom$value / max(mals_chrom$value, na.rm = TRUE)  # Build plot data aligned_plot <- tibble(   location = rep(ri_chrom$location, 3),   signal = c(ri_norm, uv_norm, mals_norm),   detector = rep(c(\"RI\", \"UV\", \"MALS\"), each = length(ri_norm)) )  ggplot(aligned_plot, aes(location, signal, color = detector)) +   geom_line(linewidth = 0.8) +   scale_color_manual(values = c(\"RI\" = \"#2E86AB\", \"UV\" = \"#A23B72\", \"MALS\" = \"#F18F01\")) +   labs(     x = \"Time (min)\",     y = \"Normalized Signal\",     title = \"After Delay Correction: Peaks Are Now Aligned!\",     subtitle = \"All detectors see the same molecules at the same time\",     color = \"Detector\"   ) +   theme_minimal() +   theme(legend.position = \"bottom\") #> Warning: Removed 729 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"step-3-process-unknown-samples","dir":"Articles","previous_headings":"","what":"Step 3: Process Unknown Samples","title":"Tutorial: Triple Detection from Raw Data","text":"Let’s analyze unknown samples using determined delays:","code":"# Select a sample sample_1 <- sec_raw_multidetector |>   filter(sample_id == \"Sample-1\")  # Full triple detection recipe rec_triple <- recipe(   ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,   data = sample_1 ) |>   update_role(sample_id, new_role = \"id\") |>   # Convert to measure format   step_measure_input_long(ri_mv, location = vars(time_min), col_name = \"ri\") |>   step_measure_input_long(uv_au, location = vars(time_min), col_name = \"uv\") |>   step_measure_input_long(mals_mv, location = vars(time_min), col_name = \"mals\") |>   # Baseline correction   step_sec_baseline(measures = c(\"ri\", \"uv\", \"mals\")) |>   # Delay correction   step_sec_detector_delay(     reference = \"ri\",     targets = c(\"uv\", \"mals\"),     delay_volumes = c(uv = -delay_uv, mals = -delay_mals)   ) |>   # Process RI for concentration   step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\")  result_sample <- prep(rec_triple) |> bake(new_data = NULL)  # View the processed data result_sample |>   select(sample_id, ri, uv, mals, dn_dc) #> # A tibble: 1 × 5 #>   sample_id           ri           uv         mals dn_dc #>   <chr>           <meas>       <meas>       <meas> <dbl> #> 1 Sample-1  [12,001 × 2] [12,001 × 2] [12,001 × 2] 0.185"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"step-4-calculate-absolute-mw-from-mals","dir":"Articles","previous_headings":"","what":"Step 4: Calculate Absolute MW from MALS","title":"Tutorial: Triple Detection from Raw Data","text":"full workflow, use step_sec_mals() calculate molecular weight light scattering signal combined concentration. basic relationship : Mw=RθK*⋅c⋅P(θ)M_w = \\frac{R_\\theta}{K^* \\cdot c \\cdot P(\\theta)} : - RθR_\\theta = excess Rayleigh ratio (MALS signal) - K*K^* = optical constant (depends dn/dc, wavelength) - cc = concentration (RI) - P(θ)P(\\theta) = form factor (angular dependence)","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"complete-multi-sample-analysis","dir":"Articles","previous_headings":"","what":"Complete Multi-Sample Analysis","title":"Tutorial: Triple Detection from Raw Data","text":"Let’s process samples compare results known values:","code":"analyze_sample <- function(sample_data) {   sample_id <- unique(sample_data$sample_id)   known_mw <- unique(sample_data$mw)    rec <- recipe(     ri_mv + uv_au + mals_mv + time_min + dn_dc ~ sample_id,     data = sample_data   ) |>     update_role(sample_id, new_role = \"id\") |>     step_measure_input_long(ri_mv, location = vars(time_min), col_name = \"ri\") |>     step_measure_input_long(mals_mv, location = vars(time_min), col_name = \"mals\") |>     step_sec_baseline(measures = c(\"ri\", \"mals\")) |>     step_sec_detector_delay(       reference = \"ri\",       targets = \"mals\",       delay_volumes = c(mals = -delay_mals)     ) |>     step_sec_ri(measures = \"ri\", dn_dc_column = \"dn_dc\")    result <- prep(rec) |> bake(new_data = NULL)    # Extract peak info for summary   ri_chrom <- result$ri[[1]]   peak_idx <- which.max(ri_chrom$value)   peak_time <- ri_chrom$location[peak_idx]    tibble(     sample_id = sample_id,     known_mw = known_mw,     peak_time = peak_time,     dn_dc = unique(sample_data$dn_dc)   ) }  # Analyze all samples all_results <- sec_raw_multidetector |>   group_by(sample_id) |>   group_split() |>   purrr::map(analyze_sample) |>   bind_rows()  print(all_results) #> # A tibble: 4 × 4 #>   sample_id   known_mw peak_time dn_dc #>   <chr>          <dbl>     <dbl> <dbl> #> 1 PS-DelayStd   100000      15.6 0.185 #> 2 Sample-1       75000      14.6 0.185 #> 3 Sample-2      150000      14.1 0.085 #> 4 Sample-3       45000      16.0 0.15"},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"comparison-overlay-all-processed-chromatograms","dir":"Articles","previous_headings":"","what":"Comparison: Overlay All Processed Chromatograms","title":"Tutorial: Triple Detection from Raw Data","text":"","code":"# Process all samples for plotting process_for_plot <- function(sample_data) {   sid <- unique(sample_data$sample_id)   known_mw <- unique(sample_data$mw)    rec <- recipe(     ri_mv + time_min + dn_dc ~ sample_id,     data = sample_data   ) |>     update_role(sample_id, new_role = \"id\") |>     step_measure_input_long(ri_mv, location = vars(time_min), col_name = \"ri\") |>     step_sec_baseline(measures = \"ri\")    result <- prep(rec) |> bake(new_data = NULL)   chrom <- result$ri[[1]]    tibble(     location = chrom$location,     value = chrom$value,     sample_id = sid,     mw = known_mw,     label = paste0(sid, \"\\n(\", scales::comma(known_mw), \" Da)\")   ) }  plot_data <- sec_raw_multidetector |>   group_by(sample_id) |>   group_split() |>   purrr::map(process_for_plot) |>   bind_rows()  ggplot(plot_data, aes(location, value, color = label)) +   geom_line(linewidth = 0.8) +   scale_color_viridis_d(option = \"turbo\") +   labs(     x = \"Elution Time (min)\",     y = \"RI Signal (baseline corrected)\",     title = \"Processed Multi-Detector Samples\",     subtitle = \"Higher MW samples elute earlier\",     color = \"Sample\"   ) +   theme_minimal() +   theme(legend.position = \"right\")"},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Tutorial: Triple Detection from Raw Data","text":"’ve completed triple detection workflow: Identified delay problem - raw detector signals aligned Determined delays using narrow standard Applied corrections step_sec_detector_delay() Processed samples complete workflow","code":""},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"key-takeaways","dir":"Articles","previous_headings":"Summary","what":"Key Takeaways","title":"Tutorial: Triple Detection from Raw Data","text":"Always determine delays narrow standard analyzing unknowns RI typically reference detector (delay = 0) UV leads, MALS lags instrument configurations Delay values depend flow rate, tubing length, flow cell volumes Re-check delays change plumbing flow rates","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/articles/tutorial-triple-detection.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Tutorial: Triple Detection from Raw Data","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1          tidyr_1.3.2            measure.sec_0.0.0.9000 #> [4] measure_0.0.1.9002     recipes_1.3.1          dplyr_1.1.4            #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.55           bslib_0.9.0         #>  [4] lattice_0.22-7      vctrs_0.6.5         tools_4.5.2         #>  [7] generics_0.1.4      parallel_4.5.2      tibble_3.3.0        #> [10] pkgconfig_2.0.3     Matrix_1.7-4        data.table_1.18.0   #> [13] RColorBrewer_1.1-3  S7_0.2.1            desc_1.4.3          #> [16] lifecycle_1.0.5     compiler_4.5.2      farver_2.1.2        #> [19] textshaping_1.0.4   codetools_0.2-20    htmltools_0.5.9     #> [22] class_7.3-23        sass_0.4.10         yaml_2.3.12         #> [25] prodlim_2025.04.28  pillar_1.11.1       pkgdown_2.2.0       #> [28] jquerylib_0.1.4     MASS_7.3-65         cachem_1.1.0        #> [31] gower_1.0.2         rpart_4.1.24        parallelly_1.46.1   #> [34] lava_1.8.2          tidyselect_1.2.1    digest_0.6.39       #> [37] future_1.68.0       purrr_1.2.0         listenv_0.10.0      #> [40] labeling_0.4.3      splines_4.5.2       fastmap_1.2.0       #> [43] grid_4.5.2          cli_3.6.5           magrittr_2.0.4      #> [46] utf8_1.2.6          survival_3.8-3      future.apply_1.20.1 #> [49] withr_3.0.2         scales_1.4.0        lubridate_1.9.4     #> [52] timechange_0.3.0    rmarkdown_2.30      globals_0.18.0      #> [55] nnet_7.3-20         timeDate_4051.111   ragg_1.5.0          #> [58] evaluate_1.0.5      knitr_1.51          hardhat_1.4.2       #> [61] viridisLite_0.4.2   rlang_1.1.6         Rcpp_1.1.0          #> [64] glue_1.8.0          ipred_0.9-15        jsonlite_2.0.0      #> [67] R6_2.6.1            systemfonts_1.3.1   fs_1.6.6"},{"path":"https://jameshwade.github.io/measure-sec/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James Wade. Author, maintainer.","code":""},{"path":"https://jameshwade.github.io/measure-sec/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wade J (2026). measure.sec: SEC/GPC Analysis Extensions Measure Package. R package version 0.0.0.9000, https://github.com/JamesHWade/measure-sec.","code":"@Manual{,   title = {measure.sec: SEC/GPC Analysis Extensions for the Measure Package},   author = {James Wade},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://github.com/JamesHWade/measure-sec}, }"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"measure.sec","text":"measure.sec R package extends measure package preprocessing analysis steps Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC) data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"features","dir":"","previous_headings":"Overview","what":"Features","title":"measure.sec","text":"Multi-detector support: RI, UV/DAD, MALS, LALS, RALS, DLS, viscometer processing Inter-detector delay correction: Align signals detectors series Molecular weight calculations: Mn, Mw, Mz, dispersity (PDI) Copolymer composition: UV/RI ratio composition analysis Protein SEC: Aggregate fragment quantitation (HMWS/LMWS) Universal calibration: Mark-Houwink parameter-based MW conversion Quality control: System suitability testing (resolution, plate count, asymmetry) Polymer analysis: Branching indices Mark-Houwink parameter estimation","code":""},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"package-workflow","dir":"","previous_headings":"Overview","what":"Package Workflow","title":"measure.sec","text":"SEC Data Analysis Workflow typical SEC analysis workflow processes raw chromatogram data preprocessing, detector-specific signal processing, calibration, molecular weight calculations. Concentration detectors (RI, UV) require calibration curves standards, light scattering detectors (MALS) provide absolute molecular weight directly.","code":""},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"measure.sec","text":"can install development version measure.sec GitHub : Note: measure.sec requires measure package:","code":"# install.packages(\"pak\") pak::pak(\"JamesHWade/measure-sec\") pak::pak(\"JamesHWade/measure\")"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"measure.sec","text":"","code":"library(measure) library(measure.sec) library(recipes)  # Load example triple-detection SEC data data(sec_triple_detect, package = \"measure.sec\")  # Create a processing recipe rec <- recipe(~ ., data = sec_triple_detect) |>   # Convert to measure format   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>    # Correct inter-detector delays   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05)   ) |>    # Apply baseline correction   step_sec_baseline() |>    # Process RI detector with dn/dc   step_sec_ri(dn_dc_column = \"dn_dc\")  # Prep and bake prepped <- prep(rec) result <- bake(prepped, new_data = NULL)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"quality-control-functions","dir":"","previous_headings":"","what":"Quality Control Functions","title":"measure.sec","text":"","code":"# Peak resolution Rs <- measure_sec_resolution(   retention_1 = 8.5,   retention_2 = 10.0,   width_1 = 0.3,   width_2 = 0.35 )  # Plate count N <- measure_sec_plate_count(retention = 10.0, width = 0.25)  # System suitability testing peaks <- data.frame(   name = c(\"dimer\", \"monomer\"),   retention = c(8.5, 10.0),   width = c(0.3, 0.35),   area = c(5, 95) )  sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\") ) print(sst)"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"polymer-analysis-functions","dir":"","previous_headings":"","what":"Polymer Analysis Functions","title":"measure.sec","text":"","code":"# Estimate Mark-Houwink parameters mw <- c(10000, 25000, 50000, 100000, 250000) iv <- c(0.15, 0.28, 0.45, 0.72, 1.2)  mh <- measure_mh_parameters(mw, iv) print(mh) # K = 1.14e-04, a = 0.716  # Calculate branching index g <- measure_branching_index(   mw = mw,   rg = c(8, 12, 18, 28, 45),   reference = data.frame(mw = mw, rg = c(10, 15, 22, 35, 55)),   method = \"g\" )"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"data-export","dir":"","previous_headings":"","what":"Data Export","title":"measure.sec","text":"","code":"# Extract slice-by-slice data slices <- measure_sec_slice_table(result, measures = c(\"ri\", \"mw\"))  # Generate summary table summary <- measure_sec_summary_table(result, sample_id = \"sample_id\")"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"example-dataset","dir":"","previous_headings":"","what":"Example Dataset","title":"measure.sec","text":"package includes sec_triple_detect, synthetic multi-detector SEC dataset : 12 polymer samples (PS standards, PMMA, PEG, copolymers) RI, UV, MALS detector signals Known molecular weights dispersities Sample-specific dn/dc extinction coefficients","code":"data(sec_triple_detect) head(sec_triple_detect)"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"integration-with-measure","dir":"","previous_headings":"","what":"Integration with measure","title":"measure.sec","text":"measure.sec automatically registers measure package load:","code":"library(measure) library(measure.sec)  # View registered SEC steps measure_steps(techniques = \"SEC/GPC\")"},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"learn-more","dir":"","previous_headings":"","what":"Learn More","title":"measure.sec","text":"detailed workflows examples, see package vignettes: Getting Started: Basic concepts first SEC analysis Multi-Detector SEC: Triple detection RI, UV, MALS Protein SEC: Aggregate oligomer analysis biopharmaceuticals Copolymer Analysis: Composition UV/RI ratio System Suitability: QC functions SST testing","code":""},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"measure.sec","text":"Package documentation GitHub Issues","code":""},{"path":"https://jameshwade.github.io/measure-sec/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"measure.sec","text":"Please note measure.sec project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/auto_detect_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Detect Standards in a Data Frame — auto_detect_standards","title":"Auto-Detect Standards in a Data Frame — auto_detect_standards","text":"Scans data frame columns might contain standard names attempts match recognized standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/auto_detect_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-Detect Standards in a Data Frame — auto_detect_standards","text":"","code":"auto_detect_standards(data, name_col = NULL, add_columns = TRUE)"},{"path":"https://jameshwade.github.io/measure-sec/reference/auto_detect_standards.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auto-Detect Standards in a Data Frame — auto_detect_standards","text":"data data frame containing sample information. name_col Name column containing sample names. NULL, attempts auto-detect common column names. add_columns Logical. TRUE, adds matched_standard standard_type columns data frame. FALSE, returns matching results.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/auto_detect_standards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auto-Detect Standards in a Data Frame — auto_detect_standards","text":"add_columns = TRUE, original data frame added columns. FALSE, tibble matching results.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/auto_detect_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Detect Standards in a Data Frame — auto_detect_standards","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detect and add standard columns data <- data.frame(   sample_name = c(\"PS A\", \"Unknown\", \"PMMA B\"),   signal = c(100, 200, 150) ) auto_detect_standards(data) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic Plot for SEC Results — autoplot.sec_results","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"Creates ggplot2 visualization appropriate SEC/GPC analysis results. Automatically selects best plot type based available data, allows explicit selection via type argument.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"","code":"# S3 method for class 'sec_results' autoplot(   object,   type = c(\"auto\", \"chromatogram\", \"mwd\", \"conformation\", \"composition\"),   overlay_mw = TRUE,   detectors = c(\"ri\", \"uv\", \"mals\"),   log_scale = c(\"x\", \"none\", \"y\", \"both\"),   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"object sec_results object created sec_results(). type Type plot create. One : \"auto\": Automatically detect best plot type (default) \"chromatogram\": Basic chromatogram (signal vs time) \"mwd\": Molecular weight distribution \"conformation\": Rg-MW eta-MW scaling plot \"composition\": UV/RI ratio composition plot overlay_mw Logical. chromatogram plots, overlay molecular weight secondary y-axis? Default TRUE MW data available. detectors Character vector detector columns plot multi-detector overlays. Default c(\"ri\", \"uv\", \"mals\"). log_scale Character. Apply log scale axes. Options: \"x\": Log scale x-axis (default MWD plots) \"y\": Log scale y-axis \"\": Log scale axes \"none\": log scaling ... Additional arguments passed underlying plot function.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"type = \"auto\" (default), plot type selected based available data: mw column present: MWD plot multiple detectors: Multi-detector overlay Otherwise: Basic chromatogram resulting ggplot2 object can customized standard ggplot2 functions like + theme_bw() + labs().","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/autoplot.sec_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic Plot for SEC Results — autoplot.sec_results","text":"","code":"if (FALSE) { # \\dontrun{ library(ggplot2)  # Create sec_results object results <- sec_results(processed_sec_data)  # Auto-detect best plot type autoplot(results)  # Specific plot types autoplot(results, type = \"chromatogram\") autoplot(results, type = \"mwd\", show_averages = TRUE) autoplot(results, type = \"conformation\")  # Customize with ggplot2 autoplot(results, type = \"mwd\") +   theme_classic() +   labs(title = \"Molecular Weight Distribution\") } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"Estimates instrumental spreading parameter (sigma) narrow molecular weight standard peak. sigma value can used step_sec_band_broadening() correct band broadening.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"","code":"estimate_sigma(peak, method = c(\"gaussian\", \"fwhm\", \"moments\"))"},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"peak measure_tbl data frame location value columns representing chromatographic peak narrow MW standard. method Method sigma estimation: \"gaussian\" (default): Fit Gaussian extract sigma \"fwhm\": Calculate full width half maximum (sigma = FWHM / 2.355) \"moments\": Calculate second moment peak","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"list components: sigma estimated spreading parameter (Gaussian std dev) tau Exponential tail parameter (EMG model), NA applicable fwhm Full width half maximum asymmetry Peak asymmetry factor (> 1 indicates tailing) method method used estimation","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"spreading parameter sigma represents standard deviation instrumental broadening function, assumed approximately Gaussian. best results, use narrow polydispersity standard (PDI < 1.05) run conditions samples. Method Details: gaussian: Fits Gaussian function peak using nonlinear least squares. accurate symmetric peaks. fwhm: Uses relationship sigma = FWHM / 2.355 Gaussian. Fast robust assumes symmetric peak. moments: Calculates sigma second central moment. Accounts asymmetry sensitive baseline.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/estimate_sigma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Spreading Parameter from Narrow Standard — estimate_sigma","text":"","code":"if (FALSE) { # \\dontrun{ # From a measure_tbl sigma_result <- estimate_sigma(narrow_standard_peak) sigma_result$sigma  # Use in band broadening correction rec <- recipe(~., data = sec_data) |>   step_sec_band_broadening(sigma = sigma_result$sigma) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/get_recognized_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Recognized SEC Calibration Standards — get_recognized_standards","title":"Get Recognized SEC Calibration Standards — get_recognized_standards","text":"Returns list recognized calibration standards matching patterns. central registry standard name recognition.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_recognized_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Recognized SEC Calibration Standards — get_recognized_standards","text":"","code":"get_recognized_standards()"},{"path":"https://jameshwade.github.io/measure-sec/reference/get_recognized_standards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Recognized SEC Calibration Standards — get_recognized_standards","text":"named list names canonical standard names values regex patterns matching normalized sample names.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_recognized_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Recognized SEC Calibration Standards — get_recognized_standards","text":"Standard types supported: PS (Polystyrene): PS , PS B, PS C, PS D, PS 1683 PMMA (Polymethyl methacrylate): PMMA , PMMA B, PMMA C, PMMA D PEG/PEO (Polyethylene glycol/oxide): PEG , PEG B, PEG C, PEG D Pullulan: Pullulan , Pullulan B, Pullulan C, Pullulan D Generic: Standard 1-4 (site-specific, default MW values) Patterns assume input normalized via normalize_standard_name() (lowercase, \"std\" converted \"standard\", separators normalized).","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/get_recognized_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Recognized SEC Calibration Standards — get_recognized_standards","text":"","code":"standards <- get_recognized_standards() names(standards) #>  [1] \"PS 1683\"    \"PS A\"       \"PS B\"       \"PS C\"       \"PS D\"       #>  [6] \"PMMA A\"     \"PMMA B\"     \"PMMA C\"     \"PMMA D\"     \"PEG A\"      #> [11] \"PEG B\"      \"PEG C\"      \"PEG D\"      \"Pullulan A\" \"Pullulan B\" #> [16] \"Pullulan C\" \"Pullulan D\" \"Standard 1\" \"Standard 2\" \"Standard 3\" #> [21] \"Standard 4\""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_sec_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Path to SEC Report Template — get_sec_template","title":"Get Path to SEC Report Template — get_sec_template","text":"Returns file path built-SEC report template.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_sec_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Path to SEC Report Template — get_sec_template","text":"","code":"get_sec_template(template = c(\"standard\", \"detailed\", \"qc\"))"},{"path":"https://jameshwade.github.io/measure-sec/reference/get_sec_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Path to SEC Report Template — get_sec_template","text":"template Template name: \"standard\", \"detailed\", \"qc\".","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_sec_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Path to SEC Report Template — get_sec_template","text":"Character string file path template.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Standard Names — get_standard_names","title":"Get Standard Names — get_standard_names","text":"Returns character vector recognized standard names.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Standard Names — get_standard_names","text":"","code":"get_standard_names()"},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Standard Names — get_standard_names","text":"Character vector canonical standard names.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Standard Names — get_standard_names","text":"","code":"get_standard_names() #>  [1] \"PS 1683\"    \"PS A\"       \"PS B\"       \"PS C\"       \"PS D\"       #>  [6] \"PMMA A\"     \"PMMA B\"     \"PMMA C\"     \"PMMA D\"     \"PEG A\"      #> [11] \"PEG B\"      \"PEG C\"      \"PEG D\"      \"Pullulan A\" \"Pullulan B\" #> [16] \"Pullulan C\" \"Pullulan D\" \"Standard 1\" \"Standard 2\" \"Standard 3\" #> [21] \"Standard 4\""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Standard Type — get_standard_type","title":"Get Standard Type — get_standard_type","text":"Classifies canonical standard name polymer type.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Standard Type — get_standard_type","text":"","code":"get_standard_type(standard_name)"},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Standard Type — get_standard_type","text":"standard_name Character string standard name (canonical form).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Standard Type — get_standard_type","text":"Character string standard type: \"PS\", \"PMMA\", \"PEG\", \"Pullulan\", \"Generic\", \"\".","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/get_standard_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Standard Type — get_standard_type","text":"","code":"get_standard_type(\"PS A\") #> [1] \"PS\" get_standard_type(\"Standard 2\") #> [1] \"Generic\" get_standard_type(\"PMMA C\") #> [1] \"PMMA\""},{"path":"https://jameshwade.github.io/measure-sec/reference/is_standard.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if Sample Names Contain Standards — is_standard","title":"Check if Sample Names Contain Standards — is_standard","text":"Quick check determine sample names match recognized standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/is_standard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if Sample Names Contain Standards — is_standard","text":"","code":"is_standard(sample_names)"},{"path":"https://jameshwade.github.io/measure-sec/reference/is_standard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if Sample Names Contain Standards — is_standard","text":"sample_names Character vector sample names.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/is_standard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if Sample Names Contain Standards — is_standard","text":"Logical vector indicating whether name matches standard.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/is_standard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if Sample Names Contain Standards — is_standard","text":"","code":"is_standard(c(\"PS A\", \"Unknown\", \"PMMA-B\")) #> [1]  TRUE FALSE  TRUE"},{"path":"https://jameshwade.github.io/measure-sec/reference/list_sec_templates.html","id":null,"dir":"Reference","previous_headings":"","what":"List Available SEC Report Templates — list_sec_templates","title":"List Available SEC Report Templates — list_sec_templates","text":"Lists available report templates descriptions.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/list_sec_templates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List Available SEC Report Templates — list_sec_templates","text":"","code":"list_sec_templates()"},{"path":"https://jameshwade.github.io/measure-sec/reference/list_sec_templates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List Available SEC Report Templates — list_sec_templates","text":"tibble template names descriptions.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/list_sec_templates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List Available SEC Report Templates — list_sec_templates","text":"","code":"list_sec_templates() #> # A tibble: 3 × 3 #>   template description                                         formats         #>   <chr>    <chr>                                               <chr>           #> 1 standard Summary table, chromatogram, and MWD plot           html, pdf, docx #> 2 detailed All plots, multi-detector view, optional slice data html, pdf, docx #> 3 qc       System suitability with pass/fail metrics           html, pdf, docx"},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Load SEC Calibration Parameters — load_sec_calibration","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"Loads previously saved SEC calibration parameters use step_sec_conventional_cal(). enables reusing established calibrations without refitting.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"","code":"load_sec_calibration(file)"},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"file Path calibration file (.rds .yaml/.yml).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"sec_calibration object can passed calibration argument step_sec_conventional_cal().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"loaded calibration can used two ways: Direct use: Pass step_sec_conventional_cal(calibration = cal) skip fitting use pre-established calibration. Inspection: Use print() summary() view calibration details.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/load_sec_calibration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load SEC Calibration Parameters — load_sec_calibration","text":"","code":"if (FALSE) { # \\dontrun{ # Load a saved calibration cal <- load_sec_calibration(\"ps_calibration.rds\") print(cal)  # Use in a recipe (no fitting needed) rec <- recipe(~., data = new_samples) |>   step_sec_conventional_cal(calibration = cal) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/match_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Sample Names to Recognized Standards — match_standards","title":"Match Sample Names to Recognized Standards — match_standards","text":"Attempts match sample names recognized calibration standards using pattern matching normalized names.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/match_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Sample Names to Recognized Standards — match_standards","text":"","code":"match_standards(sample_names, standards = NULL, return_all = FALSE)"},{"path":"https://jameshwade.github.io/measure-sec/reference/match_standards.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Sample Names to Recognized Standards — match_standards","text":"sample_names Character vector sample names match. standards Optional named list standards regex patterns. NULL (default), uses get_recognized_standards(). return_all Logical. TRUE, returns matches including non-matches NA. FALSE (default), returns matched entries.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/match_standards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Sample Names to Recognized Standards — match_standards","text":"tibble columns: sample_name: Original sample name normalized_name: Cleaned/normalized name matched_standard: Canonical standard name (NA match) standard_type: Type standard (PS, PMMA, etc.)","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/match_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match Sample Names to Recognized Standards — match_standards","text":"","code":"samples <- c(\"20231215_PS_A\", \"Unknown Sample\", \"Std B\", \"PMMA-C\") match_standards(samples) #> # A tibble: 2 × 4 #>   sample_name   normalized_name matched_standard standard_type #>   <chr>         <chr>           <chr>            <chr>         #> 1 20231215_PS_A ps a            PS A             PS            #> 2 PMMA-C        pmma c          PMMA C           PMMA           # Return all samples including non-matches match_standards(samples, return_all = TRUE) #> # A tibble: 4 × 4 #>   sample_name    normalized_name matched_standard standard_type #>   <chr>          <chr>           <chr>            <chr>         #> 1 20231215_PS_A  ps a            PS A             PS            #> 2 Unknown Sample unknown sample  NA               NA            #> 3 Std B          standard b      NA               NA            #> 4 PMMA-C         pmma c          PMMA C           PMMA"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure.sec-package.html","id":null,"dir":"Reference","previous_headings":"","what":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","title":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","text":"Provides preprocessing analysis recipe steps Size Exclusion Chromatography (SEC) Gel Permeation Chromatography (GPC) data. Includes multi-detector support (RI, UV, MALS), inter-detector delay correction, molecular weight calculations (Mn, Mw, Mz, dispersity), calibration curve fitting. package technique pack 'measure' package.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure.sec-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"measure.sec: SEC/GPC Analysis Extensions for the Measure Package — measure.sec-package","text":"Maintainer: James Wade github@jameshwade.com (ORCID)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"Calculates number branch points per molecule using Zimm-Stockmayer theory, relates branching index (g) branching frequency.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"","code":"measure_branching_frequency(   g,   architecture = c(\"random\", \"star_3\", \"star_4\", \"star_f\", \"comb\"),   arms = NULL,   mw = NULL )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"g Numeric vector branching ratios g = Rg^2(branched) / Rg^2(linear). architecture Branching architecture model: \"random\": Random trifunctional branching (default) \"star_3\": 3-arm star polymer \"star_4\": 4-arm star polymer \"star_f\": f-arm star (requires arms parameter) \"comb\": Comb-like branching arms Number arms star polymers (required \"star_f\"). mw Optional molecular weight vector (length g) calculating total branches sample.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"data frame class branching_frequency containing: g Input branching ratio branches_per_molecule Estimated branch points per molecule branch_density Branches per unit MW (mw provided)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"Zimm-Stockmayer Theory: random trifunctional branching, relationship g average number branch points (n_b) : $$g = \\left[\\left(1 + \\frac{n_b}{7}\\right)^{1/2} + \\frac{4n_b}{9\\pi}\\right]^{-1/2}$$ star polymers f arms: $$g = \\frac{3f - 2}{f^2}$$ Interpretation: g = 1.0: Linear polymer (branching) g ~ 0.5-0.8: Lightly branched g ~ 0.3-0.5: Moderately branched g < 0.3: Highly branched/hyperbranched","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"Zimm, B.H. Stockmayer, W.H. (1949). \"Dimensions Chain Molecules Containing Branches Rings.\" J. Chem. Phys., 17, 1301-1314.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_frequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Branching Frequency from Zimm-Stockmayer Theory — measure_branching_frequency","text":"","code":"# Calculate branching for random trifunctional polymer g_values <- c(0.9, 0.7, 0.5, 0.3) bf <- measure_branching_frequency(g_values) print(bf) #> Branching Frequency Analysis (Zimm-Stockmayer) #> ==================================================  #>  #> Architecture: random #> N samples: 4 #>  #> g ratio range: 0.300 - 0.900 #> Branches/molecule: 1.12 - 57.14 (mean: 19.74) #>  #> # A tibble: 4 × 2 #>       g branches_per_molecule #>   <dbl>                 <dbl> #> 1   0.9                  1.12 #> 2   0.7                  5.12 #> 3   0.5                 15.6  #> 4   0.3                 57.1   # For star polymer with 4 arms bf_star <- measure_branching_frequency(0.625, architecture = \"star_4\")"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Branching Index — measure_branching_index","title":"Calculate Branching Index — measure_branching_index","text":"Calculates branching index (g g') branched polymers comparing properties linear reference polymers molecular weight.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Branching Index — measure_branching_index","text":"","code":"measure_branching_index(   mw,   rg = NULL,   intrinsic_visc = NULL,   reference = \"linear\",   mh_linear = NULL,   rg_linear_fit = NULL,   method = c(\"g\", \"g_prime\", \"both\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Branching Index — measure_branching_index","text":"mw Numeric vector molecular weights branched samples. rg Numeric vector radius gyration values (g ratio). intrinsic_visc Numeric vector intrinsic viscosity values (g'). reference Type reference: either \"linear\" comparison linear polymer theory, data frame containing linear reference data. mh_linear Mark-Houwink parameters linear reference polymer (list K ). Required reference = \"linear\" using g'. rg_linear_fit Rg-MW relationship linear polymer: either model list slope intercept log(Rg) = intercept + slope * log(M). method Branching index type: \"g\": Radius gyration ratio: g = Rg^2(branched) / Rg^2(linear) \"g_prime\": Viscosity ratio: g' = [eta](branched) / [eta](linear) \"\": Calculate g g'","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Branching Index — measure_branching_index","text":"data frame columns: mw Molecular weight g Branching index Rg (calculated) g_prime Branching index viscosity (calculated) branches_per_molecule Estimated branch points (Zimm-Stockmayer)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Branching Index — measure_branching_index","text":"Branching reduces hydrodynamic size polymers compared linear counterparts. quantified branching ratios: Rg-based branching index (g): $$g = \\frac{R_g^2(branched)}{R_g^2(linear)}$$ Viscosity-based branching index (g'): $$g' = \\frac{[\\eta](branched)}{[\\eta](linear)}$$ relationship g g' depends polymer architecture: $$g' = g^\\epsilon$$ epsilon ~ 0.5-1.5 depending branching type. Zimm-Stockmayer Model (random branching): $$g = \\frac{6}{n_b} \\left[ \\frac{1}{2} + \\frac{(2 + n_b)^{1/2} - 1 - n_b/2}{n_b} \\right]$$ n_b number branch points per molecule.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Branching Index — measure_branching_index","text":"","code":"# Calculate branching index from Rg data mw <- c(100000, 200000, 500000) rg_branched <- c(12, 18, 32) rg_linear <- c(15, 22, 40)  # Reference linear polymer  g <- measure_branching_index(   mw = mw,   rg = rg_branched,   reference = data.frame(mw = mw, rg = rg_linear),   method = \"g\" )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Branching Models — measure_branching_model_comparison","title":"Compare Branching Models — measure_branching_model_comparison","text":"Compares experimental branching data theoretical predictions different branching models identify likely architecture.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Branching Models — measure_branching_model_comparison","text":"","code":"measure_branching_model_comparison(   g,   mw,   g_prime = NULL,   models = c(\"random\", \"star\", \"comb\", \"hyperbranched\"),   branch_frequency = NULL )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Branching Models — measure_branching_model_comparison","text":"g Numeric vector experimental g ratios (Rg^2 branched / Rg^2 linear). mw Numeric vector molecular weights (length g). g_prime Optional numeric vector g' ratios (IV branched / IV linear). models Character vector models compare. Default compares : \"random\": Random trifunctional branching (Zimm-Stockmayer) \"star\": Star polymers (variable arms) \"comb\": Comb architecture \"hyperbranched\": Hyperbranched/dendritic branch_frequency fitting: assumed constant branching frequency (branches per 1000 Da). NULL, estimated data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Branching Models — measure_branching_model_comparison","text":"list class branching_model_comparison containing: model_fits Data frame fit statistics model best_model Name best-fitting model predictions Data frame predicted g model experimental Input experimental data","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare Branching Models — measure_branching_model_comparison","text":"Model Equations: Random trifunctional (Zimm-Stockmayer): $$g = \\left[\\left(1 + \\frac{n_b}{7}\\right)^{1/2} + \\frac{4n_b}{9\\pi}\\right]^{-1/2}$$ Star polymer (f arms): $$g = \\frac{3f - 2}{f^2}$$ Comb polymer (n_b branches): $$g \\approx \\frac{1}{1 + 2n_b/3}$$ Hyperbranched (degree branching DB): $$g \\approx \\left(\\frac{1}{1 + DB \\cdot n/2}\\right)^{0.5}$$ Model selection uses residual sum squares AIC-like criteria.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compare Branching Models — measure_branching_model_comparison","text":"Zimm, B.H. Stockmayer, W.H. (1949). J. Chem. Phys., 17, 1301-1314. Burchard, W. (1999). \"Solution Properties Branched Macromolecules.\" Adv. Polym. Sci., 143, 113-194.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_branching_model_comparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Branching Models — measure_branching_model_comparison","text":"","code":"# Compare models for branched polymer data mw <- c(50000, 100000, 200000, 500000) g_exp <- c(0.85, 0.72, 0.58, 0.42)  comparison <- measure_branching_model_comparison(g_exp, mw) print(comparison) #> Branching Model Comparison #> ============================================================  #>  #> Model Fit Summary: #> ------------------------------------------------------------  #>          model  parameter r_squared       rmse       aic #>         random 0.04648146 0.9887283 0.01699313 -17.24806 #>           star 1.11325520 0.9470407 0.03683411 -11.05914 #>           comb 0.00502421 0.9670907 0.02903611 -12.96221 #>  hyperbranched 0.09231394 0.9932768 0.01312403 -19.31498 #> ------------------------------------------------------------  #>  #> Best Model: hyperbranched (lowest AIC) #>   R-squared: 0.9933 #>   RMSE: 0.0131 #>   Parameter: 0.0923 #>  #> Note: Lower AIC indicates better fit with penalty for complexity. #> Consider physical plausibility when selecting the final model."},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_conformation_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Conformation Plot Data — measure_conformation_data","title":"Create Conformation Plot Data — measure_conformation_data","text":"Prepares data Mark-Houwink conformation plots (log([eta]) vs log(M) log(Rg) vs log(M)).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_conformation_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Conformation Plot Data — measure_conformation_data","text":"","code":"measure_conformation_data(mw, y, y_type = c(\"iv\", \"rg\"), fit_line = TRUE)"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_conformation_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Conformation Plot Data — measure_conformation_data","text":"mw Numeric vector molecular weights. y Numeric vector intrinsic viscosity radius gyration. y_type Type y-axis data: \"iv\" intrinsic viscosity \"rg\" radius gyration. fit_line Logical. Include fitted line? Default TRUE.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_conformation_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Conformation Plot Data — measure_conformation_data","text":"data frame suitable plotting columns: log_mw log10(MW) log_y log10(y) mw Original MW values y Original y values","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_conformation_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Conformation Plot Data — measure_conformation_data","text":"","code":"mw <- c(10000, 50000, 100000, 500000) iv <- c(0.15, 0.35, 0.50, 0.95)  plot_data <- measure_conformation_data(mw, iv, y_type = \"iv\")  # Plot with ggplot2 # ggplot(plot_data, aes(log_mw, log_y)) + #   geom_point() + #   geom_smooth(method = \"lm\")"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Mark-Houwink Parameters — measure_mh_parameters","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"Estimates Mark-Houwink K (alpha) parameters intrinsic viscosity molecular weight data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"","code":"measure_mh_parameters(   mw,   intrinsic_visc,   weights = NULL,   mw_range = NULL,   log_fit = TRUE )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"mw Numeric vector molecular weights. intrinsic_visc Numeric vector intrinsic viscosities (length mw). weights Optional numeric vector weights weighted regression. Use concentration signal intensity weights SEC data. mw_range Optional numeric vector length 2 specifying MW range use fitting. Data outside range excluded. log_fit Logical. Perform fit log-log space (recommended)? Default TRUE.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"list class mh_parameters containing: K Mark-Houwink K parameter Mark-Houwink (alpha) exponent r_squared R-squared fit n_points Number data points used mw_range MW range data fit fitted linear model object","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"Mark-Houwink equation relates intrinsic viscosity molecular weight: $$[\\eta] = K \\cdot M^$$ log form: $$\\log([\\eta]) = \\log(K) + \\cdot \\log(M)$$ parameters K depend : Polymer-solvent system Temperature Polymer microstructure (tacticity, branching) Interpretation '' exponent: ~ 0.5: Theta solvent (polymer coil collapsed) ~ 0.5-0.8: Good solvent (typical range) ~ 0.8: Rigid rod extended chain < 0.5: Branched compact structures","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_mh_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Mark-Houwink Parameters — measure_mh_parameters","text":"","code":"# Estimate Mark-Houwink parameters from triple-detection data mw <- c(10000, 25000, 50000, 100000, 250000) iv <- c(0.15, 0.28, 0.45, 0.72, 1.2)  mh <- measure_mh_parameters(mw, iv) print(mh) #> Mark-Houwink Parameters #> ========================================  #>  #> K = 3.8112e-04 #> a = 0.652 #>  #> R-squared: 0.9981 #> Data points: 5 #> MW range: 10000 - 250000 #>  #> Equation: [eta] = K * M^a # K = 0.000114, a = 0.716 (typical for PS in THF)"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"Fits power law relationship radius gyration (Rg) molecular weight (MW) determine polymer conformation.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"","code":"measure_rg_mw_scaling(mw, rg, weights = NULL, mw_range = NULL)"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"mw Numeric vector molecular weights. rg Numeric vector radii gyration (length mw). weights Optional numeric vector weights (e.g., concentration). mw_range Optional numeric vector length 2 specifying MW range fitting.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"list class rg_mw_scaling containing: nu Scaling exponent (slope log-log space) prefactor Prefactor K Rg = K * M^nu r_squared R-squared fit conformation Interpreted polymer conformation n_points Number data points used fit lm fit object","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"Rg-MW relationship follows power law: $$R_g = K \\cdot M^{\\nu}$$ nu (Flory exponent) indicates polymer conformation: Interpretation nu: nu ~ 0.33: Compact/spherical (collapsed globule) nu ~ 0.50: Theta solvent (ideal chain) nu ~ 0.588: Good solvent (swollen coil) nu ~ 1.0: Rigid rod Typical Values: Flexible polymers good solvent: nu = 0.55-0.60 Branched polymers: nu = 0.40-0.50 Proteins (globular): nu = 0.30-0.35 DNA: nu = 0.58-0.60","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"Flory, P.J. (1953). \"Principles Polymer Chemistry.\" Cornell University Press.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_rg_mw_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Rg-MW Scaling Relationship — measure_rg_mw_scaling","text":"","code":"# Fit Rg-MW for a linear polymer mw <- c(10000, 50000, 100000, 500000, 1000000) rg <- c(4.5, 12, 18, 45, 70)  # nm  scaling <- measure_rg_mw_scaling(mw, rg) print(scaling) #> Rg-MW Scaling Analysis #> ========================================  #>  #> Scaling Law: Rg = K * M^nu #>  #> nu (Flory exponent): 0.591 #>   95% CI: [0.574, 0.609] #> K (prefactor): 1.9661e-02 #>  #> Conformation: good solvent (swollen coil) #>  #> R-squared: 0.9997 #> Data points: 5 #> MW range: 10000 - 1000000"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Calculates asymmetry factor () tailing factor (Tf) chromatographic peak.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"","code":"measure_sec_asymmetry(leading, tailing, method = c(\"usp\", \"ep\"))"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"leading Width leading (front) half peak measurement height. tailing Width tailing (back) half peak measurement height. method Asymmetry calculation method: \"usp\" (default): Tailing factor 5% height \"ep\": Asymmetry factor 10% height","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Numeric asymmetry value. Values > 1 indicate tailing, < 1 indicate fronting. Ideal value 1.0.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"Peak asymmetry indicates deviation ideal Gaussian peak shape: USP Tailing Factor (5% height): $$T_f = \\frac{W_{0.05}}{2f}$$ W_0.05 width 5% height f leading half-width. EP Asymmetry Factor (10% height): $$A_s = \\frac{b}{}$$ b tailing half-width leading half-width. Interpretation: = 1.0: Symmetric (ideal) < 0.9 > 1.2: Slight asymmetry (acceptable) < 0.8 > 1.5: Significant asymmetry (investigate) > 2.0: Severe tailing (column/sample issue)","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_asymmetry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peak Asymmetry Factor — measure_sec_asymmetry","text":"","code":"# Calculate USP tailing factor measure_sec_asymmetry(   leading = 0.12,   tailing = 0.15,   method = \"usp\" ) #> [1] 1.125"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":null,"dir":"Reference","previous_headings":"","what":"Column Performance Metrics for SEC — measure_sec_column_performance","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"Calculates comprehensive column performance metrics including HETP, separation range, efficiency parameters.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"","code":"measure_sec_column_performance(   calibration_data,   column_length = 30,   column_diameter = 7.8,   flow_rate = NULL,   particle_size = NULL,   dead_volume = NULL )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"calibration_data data frame containing calibration data columns: retention retention_time: Retention time/volume mw molecular_weight: Molecular weight width: Peak width (optional, plate calculation) column_length Column length cm. Default 30 cm. column_diameter Column inner diameter mm. Default 7.8 mm. flow_rate Flow rate mL/min (optional, linear velocity). particle_size Particle size micrometers (optional, reduced HETP). dead_volume Column dead volume mL (optional).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"list class sec_column_performance containing: separation_range MW range (exclusion limit total permeation) selectivity Slope log(MW) vs retention (mL^-1) hetp Height equivalent theoretical plate (mm) plates_per_meter Theoretical plates per meter reduced_hetp HETP/particle_size (particle_size provided) peak_capacity Estimated peak capacity separation range resolution_factor Resolution per decade MW","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"Key SEC Column Performance Metrics: HETP (Height Equivalent Theoretical Plate): $$HETP = \\frac{L}{N}$$ Reduced HETP (h): $$h = \\frac{HETP}{d_p}$$ Optimal h ~ 2-3 well-packed columns. Selectivity (D): $$D = \\frac{d \\log M}{dV_R}$$ Higher D means better MW resolution. Peak Capacity: $$n_c = 1 + \\frac{\\sqrt{N}}{4} \\ln\\left(\\frac{V_{exclusion}}{V_{total}}\\right)$$ Typical Performance Guidelines: HETP: < 50 um analytical columns Reduced HETP: 2-5 good columns Plates/meter: > 20,000 HPLC SEC","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_column_performance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Column Performance Metrics for SEC — measure_sec_column_performance","text":"","code":"# From calibration standards cal_data <- data.frame(   retention = c(5.2, 6.1, 7.0, 8.2, 9.5, 10.8),   mw = c(1200000, 400000, 100000, 30000, 5000, 580),   width = c(0.4, 0.35, 0.30, 0.28, 0.25, 0.30) )  perf <- measure_sec_column_performance(   cal_data,   column_length = 30,   particle_size = 5 ) print(perf) #> SEC Column Performance #> ==================================================  #>  #> Separation Range: #>   Exclusion limit: 1200000 Da #>   Total permeation: 580 Da #>   Log MW range: 3.32 decades #>  #> Calibration: #>   Selectivity: 0.5801 log(MW)/unit #>   R-squared: 0.9956 #>  #> Column Efficiency: #>   HETP: 0.070 mm (70.4 um) #>   Plates/meter: 14203 #>   Reduced HETP (h): 14.08 #>   Average plates (N): 4261 #>  #> Resolution: #>   Peak capacity: 12.9 #>   Resolution/decade: 15.99 #>  #> Column: 300 x 7.8 mm #> Standards used: 6"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Multiple SEC Samples — measure_sec_compare","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"Compares SEC analysis results across multiple samples, providing summary table key metrics optional overlay plots.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"","code":"measure_sec_compare(   ...,   samples = NULL,   metrics = c(\"mw_averages\", \"mwd\", \"branching\"),   plot = TRUE,   reference = 1,   digits = 2 )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"... Data frames containing SEC results. baked recipe output measure columns (MW, concentration, etc.). samples Character vector sample names. NULL, uses names ... generates sequential names (\"Sample 1\", \"Sample 2\", etc.). metrics Character vector specifying metrics compare. Options: \"mw_averages\": Mn, Mw, Mz, dispersity \"mwd\": Molecular weight distribution overlap \"branching\": Branching metrics (available) Default includes available metrics. plot Logical. Generate MWD comparison plot? Default TRUE. Note: Plot generated \"mwd\" included metrics. reference Integer character. sample use reference percent differences. Default 1 (first sample). digits Integer. Number decimal places numeric values. Default 2. Must non-negative.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"list class sec_comparison containing: summary Tibble comparison metrics samples differences Tibble absolute percent differences vs reference plot ggplot2 object (plot = TRUE \"mwd\" metrics), otherwise NULL samples Character vector sample names reference Name reference sample","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"function useful : Batch--batch comparison Stability studies Process optimization Quality control Input Data Handling: input data frames contain multiple rows (e.g., multiple injections), numeric metrics averaged across rows. single-row data frames (typical processed SEC results), values used directly. function recognizes molecular weight columns either naming convention: prefixed (mw_mn, mw_mw, mw_mz, mw_dispersity) standard (Mn, Mw, Mz, dispersity). Comparison Metrics: MW Averages: Compares Mn, Mw, Mz, dispersity absolute percent differences reference sample. MWD Overlay: Creates overlaid MWD plots showing distribution differences. Useful detecting bimodality, tailing, distribution shifts. Branching: Compares branching index frequency available triple-detection data.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Multiple SEC Samples — measure_sec_compare","text":"","code":"if (FALSE) { # \\dontrun{ # Compare three batches comparison <- measure_sec_compare(   batch1_data,   batch2_data,   batch3_data,   samples = c(\"Batch 1\", \"Batch 2\", \"Batch 3\") )  # View summary table comparison$summary  # View differences from reference comparison$differences  # Display overlay plot comparison$plot  # Compare only MW averages without plot comparison <- measure_sec_compare(   sample_a, sample_b,   metrics = \"mw_averages\",   plot = FALSE ) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Theoretical Plate Count — measure_sec_plate_count","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Calculates number theoretical plates (N) chromatographic peak, measure column efficiency.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"","code":"measure_sec_plate_count(   retention,   width,   width_type = c(\"half_height\", \"baseline\", \"inflection\"),   dead_time = NULL )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"retention Retention time peak. width Peak width. See width_type measurement method. width_type Type peak width measurement: \"half_height\" (default): Width 50% height (W0.5h) \"baseline\": Width baseline tangent lines (Wb) \"inflection\": Width inflection points (Wi) dead_time Column dead time (t0). provided, calculates effective plates (N_eff) using adjusted retention time.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Numeric plate count. Higher values indicate better efficiency.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"Theoretical plate count measures column efficiency: Half-height width (common): $$N = 5.54 \\left(\\frac{t_R}{W_{0.5h}}\\right)^2$$ Baseline width: $$N = 16 \\left(\\frac{t_R}{W_b}\\right)^2$$ dead time correction (effective plates): $$N_{eff} = 5.54 \\left(\\frac{t_R - t_0}{W_{0.5h}}\\right)^2$$ Typical SEC Performance: Analytical SEC columns: 10,000-40,000 plates/meter Preparative columns: 5,000-15,000 plates/meter UHPLC SEC: 50,000+ plates/meter","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_plate_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Theoretical Plate Count — measure_sec_plate_count","text":"","code":"# Calculate plate count for a monomer peak measure_sec_plate_count(   retention = 9.5,   width = 0.25,   width_type = \"half_height\" ) #> [1] 7999.76  # With dead time for effective plates measure_sec_plate_count(   retention = 9.5,   width = 0.25,   dead_time = 3.0 ) #> [1] 3745.04"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mass Recovery — measure_sec_recovery","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Calculates mass recovery (percent injected mass detected) SEC analysis.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mass Recovery — measure_sec_recovery","text":"","code":"measure_sec_recovery(detected_mass, injected_mass, units = \"mg\")"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mass Recovery — measure_sec_recovery","text":"detected_mass Mass detected integration chromatogram. injected_mass Mass injected onto column. units Units mass values. must units.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Numeric recovery percentage (0-100+).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Mass Recovery — measure_sec_recovery","text":"Mass recovery verifies analytical system detecting injected sample: $$\\% Recovery = \\frac{m_{detected}}{m_{injected}} \\times 100$$ Interpretation: 95-105%: Excellent recovery (typical acceptance) 90-95% 105-110%: Acceptable (investigate persistent) < 90%: Low recovery - possible column adsorption, precipitation > 110%: High recovery - calibration issue, interference Common Causes Low Recovery: Sample adsorption column packing Sample precipitation aggregation -column Detector calibration drift Integration baseline errors Sample degradation","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_recovery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mass Recovery — measure_sec_recovery","text":"","code":"# Calculate recovery measure_sec_recovery(   detected_mass = 0.195,   injected_mass = 0.200 ) #> [1] 97.5 # Returns 97.5%"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate SEC Analysis Report — measure_sec_report","title":"Generate SEC Analysis Report — measure_sec_report","text":"Creates comprehensive report SEC analysis results using Quarto templates. Reports can generated HTML, PDF, Word format.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate SEC Analysis Report — measure_sec_report","text":"","code":"measure_sec_report(   data,   template = c(\"standard\", \"detailed\", \"qc\"),   output_format = c(\"html\", \"pdf\", \"docx\"),   output_file = NULL,   title = NULL,   author = \"\",   sample_id = NULL,   include_plots = TRUE,   include_slice_table = FALSE,   specs = NULL,   open = interactive(),   quiet = FALSE )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate SEC Analysis Report — measure_sec_report","text":"data data frame containing SEC results measure columns, typically baked recipe. template Report template use: \"standard\" (default), \"detailed\", \"qc\". See Details. output_format Output format: \"html\" (default), \"pdf\", \"docx\". output_file Path output file. NULL (default), creates file current working directory auto-generated name. title Report title. Default varies template. author Report author. Default empty. sample_id Column name containing sample identifiers. include_plots Logical. Include visualizations? Default TRUE. include_slice_table Logical. Include slice--slice data table? Default FALSE. used \"detailed\" template. specs Named list QC specifications \"qc\" template. See Details. open Logical. Open report generation? Default TRUE interactive sessions. quiet Logical. Suppress Quarto output messages? Default FALSE.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate SEC Analysis Report — measure_sec_report","text":"Invisibly returns path generated report file.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"templates","dir":"Reference","previous_headings":"","what":"Templates","title":"Generate SEC Analysis Report — measure_sec_report","text":"Three report templates available: \"standard\" (default): Molecular weight summary table Chromatogram overlay Molecular weight distribution plot \"detailed\": content standard template Multi-detector overlay Conformation plot (MALS data available) Optional slice data table Analysis metadata \"qc\" (Quality Control): System suitability metrics pass/fail status Plate count, asymmetry, resolution tests Calibration verification Acceptance criteria summary","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"qc-specifications","dir":"Reference","previous_headings":"","what":"QC Specifications","title":"Generate SEC Analysis Report — measure_sec_report","text":"\"qc\" template, can provide custom specifications:","code":"specs = list(   plate_count_min = 10000,   asymmetry_min = 0.8,   asymmetry_max = 1.5,   resolution_min = 1.5,   recovery_min = 95,   recovery_max = 105 )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"requirements","dir":"Reference","previous_headings":"","what":"Requirements","title":"Generate SEC Analysis Report — measure_sec_report","text":"Quarto must installed system quarto R package must installed PDF output, LaTeX distribution required","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate SEC Analysis Report — measure_sec_report","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process SEC data processed <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_conventional_cal(standards = ps_standards) |>   step_sec_mw_averages() |>   prep() |>   bake(new_data = NULL)  # Generate standard HTML report measure_sec_report(processed)  # Generate detailed PDF report measure_sec_report(   processed,   template = \"detailed\",   output_format = \"pdf\",   title = \"Polymer Characterization Results\",   author = \"Lab Analyst\" )  # Generate QC report with custom specifications measure_sec_report(   sec_system_suitability,   template = \"qc\",   specs = list(plate_count_min = 15000) ) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peak Resolution — measure_sec_resolution","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Calculates resolution two chromatographic peaks using USP EP formula.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peak Resolution — measure_sec_resolution","text":"","code":"measure_sec_resolution(   retention_1,   retention_2,   width_1,   width_2,   width_type = c(\"baseline\", \"half_height\", \"tangent\"),   method = c(\"usp\", \"ep\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peak Resolution — measure_sec_resolution","text":"retention_1 Retention time first peak (earlier eluting). retention_2 Retention time second peak (later eluting). width_1 Peak width first peak. See width_type units. width_2 Peak width second peak. width_type Type peak width measurement: \"baseline\" (default): Width baseline (Wb) \"half_height\": Width half height (W0.5h) \"tangent\": Width tangent lines inflection points method Resolution formula use: \"usp\" (default): Rs = 2(t2 - t1) / (w1 + w2) \"ep\": Rs = 1.18(t2 - t1) / (w1_0.5h + w2_0.5h)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Numeric resolution value. Rs > 1.5 indicates baseline separation.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peak Resolution — measure_sec_resolution","text":"Resolution quantifies degree separation adjacent peaks: USP Formula (baseline width): $$R_s = \\frac{2(t_2 - t_1)}{W_{b1} + W_{b2}}$$ EP Formula (half-height width): $$R_s = \\frac{1.18(t_2 - t_1)}{W_{0.5h,1} + W_{0.5h,2}}$$ Interpretation: Rs < 1.0: Peaks overlap significantly Rs = 1.0: ~94% separation (4 sigma) Rs = 1.5: Baseline separation (~99.7%) Rs > 2.0: Complete separation gap","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_resolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peak Resolution — measure_sec_resolution","text":"","code":"# Calculate resolution between monomer and dimer measure_sec_resolution(   retention_1 = 8.2,   # dimer (elutes first in SEC)   retention_2 = 9.5,   # monomer   width_1 = 0.4,   width_2 = 0.5 ) #> [1] 2.888889"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"Extracts point--point (slice) data SEC analysis results, creating long-format table suitable export analysis.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"","code":"measure_sec_slice_table(   data,   measures = NULL,   sample_id = NULL,   include_location = TRUE,   pivot = FALSE )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"data data frame containing SEC results measure columns. measures Character vector measure column names include. NULL, includes measure columns found. sample_id Column name containing sample identifiers. NULL, uses row numbers. include_location Logical. Include location (time/volume) column? Default TRUE. pivot Logical. Pivot measures wide format (one column per measure)? Default FALSE (long format).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"tibble slice--slice data: sample_id Sample identifier slice Slice index (1, 2, 3, ...) location Elution time volume measure Measure column name (pivot = FALSE) value Signal value (pivot = FALSE) <measure_names> Individual measure columns (pivot = TRUE)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"function extracts raw slice data processed SEC chromatograms, making easy : Export CSV/Excel external analysis Create custom plots Perform slice-level calculations Compare samples point--point Typical Slice Data Columns: Retention time/volume (location) Concentration (RI UV) Molecular weight (calibration MALS) Intrinsic viscosity (viscometer) Radius gyration (MALS angles) Composition (UV/RI ratio)","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_slice_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Slice-by-Slice SEC Data — measure_sec_slice_table","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process SEC data prepped <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   prep() |>   bake(new_data = NULL)  # Extract slice table (long format) slices <- measure_sec_slice_table(prepped, measures = \"ri\")  # Extract slice table (wide format) slices_wide <- measure_sec_slice_table(   prepped,   measures = c(\"ri\", \"mw\"),   pivot = TRUE )  # Export to CSV write.csv(slices, \"sec_slices.csv\", row.names = FALSE) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":null,"dir":"Reference","previous_headings":"","what":"System Suitability Test for SEC — measure_sec_suitability","title":"System Suitability Test for SEC — measure_sec_suitability","text":"Performs comprehensive system suitability testing SEC analysis, evaluating resolution, plate count, asymmetry, quality metrics.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"System Suitability Test for SEC — measure_sec_suitability","text":"","code":"measure_sec_suitability(   data = NULL,   peaks,   reference_peaks = NULL,   injected_mass = NULL,   criteria = NULL,   column_length = NULL )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"System Suitability Test for SEC — measure_sec_suitability","text":"data data frame tibble containing chromatogram data minimum retention times peak parameters. peaks data frame peak information. Must contain columns: retention: Peak retention time width: Peak width (half height unless specified) area: Peak area (recovery calculation) height: Peak height (optional, asymmetry raw data reference_peaks Character vector peak names use resolution calculation (e.g., c(\"dimer\", \"monomer\")). injected_mass Injected mass recovery calculation (optional). criteria list acceptance criteria. Default uses common biopharmaceutical criteria. column_length Column length cm (plates per meter calculation).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"System Suitability Test for SEC — measure_sec_suitability","text":"list class sec_suitability containing: results Data frame calculated metrics pass/fail status passed Logical indicating criteria passed summary Character summary results criteria Criteria used evaluation","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"System Suitability Test for SEC — measure_sec_suitability","text":"System suitability testing (SST) verifies chromatographic system performing adequately , , sample analysis. Standard SEC SST Parameters: Resolution: Rs >= 1.5 critical pair Plate count: N >= specified minimum Tailing factor: 0.8 <= Tf <= 1.5 Mass recovery: 95-105% Retention time RSD: <= 1.0% Peak area RSD: <= 2.0% Regulatory References: USP <621> Chromatography ICH Q2(R1) Validation EP 2.2.46 Chromatographic Separation Techniques","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_suitability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"System Suitability Test for SEC — measure_sec_suitability","text":"","code":"if (FALSE) { # \\dontrun{ # Define peaks from integration results peaks <- data.frame(   name = c(\"aggregate\", \"dimer\", \"monomer\", \"fragment\"),   retention = c(7.2, 8.5, 9.8, 11.5),   width = c(0.3, 0.25, 0.28, 0.35),   area = c(2.1, 5.3, 89.2, 3.4) )  # Run system suitability sst <- measure_sec_suitability(   peaks = peaks,   reference_peaks = c(\"dimer\", \"monomer\"),   injected_mass = 0.200,   column_length = 30 )  print(sst) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate SEC Summary Table — measure_sec_summary_table","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"Creates summary table SEC analysis results key metrics sample.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"","code":"measure_sec_summary_table(   data,   mw_col = NULL,   include_mw = TRUE,   include_fractions = TRUE,   include_purity = TRUE,   sample_id = NULL,   additional_cols = NULL,   digits = 2 )"},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"data data frame containing SEC results. mw_col Column name containing molecular weight averages (list column Mn, Mw, Mz, dispersity). include_mw Logical. Include molecular weight averages? Default TRUE. include_fractions Logical. Include MW fractions available? Default TRUE. include_purity Logical. Include purity metrics (HMWS, monomer, LMWS) available? Default TRUE. sample_id Column name sample identifiers. additional_cols Character vector additional columns include summary. digits Number decimal places numeric columns. Default 2.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"tibble one row per sample containing: sample_id Sample identifier Mn Number-average molecular weight Mw Weight-average molecular weight Mz Z-average molecular weight dispersity Polydispersity index (Mw/Mn) purity_hmws Percent high MW species (available) purity_monomer Percent monomer (available) purity_lmws Percent low MW species (available)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"function creates publication-ready summary table SEC results. automatically detects includes available metrics. Typical Summary Metrics: Molecular weight averages: Mn, Mw, Mz Dispersity (PDI): Mw/Mn Purity metrics: %HMWS, %Monomer, %LMWS MW fractions: % /cutoffs Recovery: % mass balance","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/measure_sec_summary_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate SEC Summary Table — measure_sec_summary_table","text":"","code":"if (FALSE) { # \\dontrun{ # Generate summary after SEC processing summary_tbl <- measure_sec_summary_table(   processed_data,   sample_id = \"sample_name\" )  # Print formatted table print(summary_tbl)  # Export to Excel writexl::write_xlsx(summary_tbl, \"sec_summary.xlsx\") } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/normalize_standard_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize Standard Names for Matching — normalize_standard_name","title":"Normalize Standard Names for Matching — normalize_standard_name","text":"Normalizes sample standard names improve matching : Converting lowercase Replacing separators (-, _) spaces Removing date prefixes (YYYYMMDD, YYYY-MM-DD, etc.) Removing common lab/vendor identifiers Normalizing \"std\" variations \"standard\" Cleaning whitespace","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/normalize_standard_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize Standard Names for Matching — normalize_standard_name","text":"","code":"normalize_standard_name(name)"},{"path":"https://jameshwade.github.io/measure-sec/reference/normalize_standard_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize Standard Names for Matching — normalize_standard_name","text":"name Character vector names normalize.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/normalize_standard_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize Standard Names for Matching — normalize_standard_name","text":"Character vector normalized names.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/normalize_standard_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize Standard Names for Matching — normalize_standard_name","text":"","code":"normalize_standard_name(\"20231215_PS_A\") #> [1] \"ps a\" normalize_standard_name(\"Std B\") #> [1] \"standard b\" normalize_standard_name(\"Phillips PS-C\") #> [1] \"ps c\" normalize_standard_name(c(\"DOW_PMMA_A\", \"2023-01-15 StdD\")) #> [1] \"pmma a\"     \"standard d\""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick SEC Plot — plot_sec","title":"Quick SEC Plot — plot_sec","text":"Creates automatic plot appropriate SEC analysis results. Dispatches appropriate plot type based available data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick SEC Plot — plot_sec","text":"","code":"plot_sec(   data,   type = c(\"auto\", \"chromatogram\", \"mwd\", \"multidetector\", \"conformation\"),   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick SEC Plot — plot_sec","text":"data data frame containing SEC results measure columns. type Type plot create. One : \"auto\": Automatically detect (default) \"chromatogram\": Basic chromatogram \"mwd\": Molecular weight distribution \"multidetector\": Multi-detector overlay \"conformation\": Rg-MW eta-MW plot ... Additional arguments passed underlying plot function.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick SEC Plot — plot_sec","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quick SEC Plot — plot_sec","text":"type = \"auto\" (default), function chooses plot type based available data: MW column present: MWD plot multiple detectors: Multi-detector overlay Otherwise: Basic chromatogram convenience wrapper dispatches specific plot functions: plot_sec_chromatogram(), plot_sec_mwd(), plot_sec_multidetector(), plot_sec_conformation().","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quick SEC Plot — plot_sec","text":"","code":"if (FALSE) { # \\dontrun{ library(ggplot2)  # Auto-detect plot type plot_sec(processed_sec_data)  # Specific plot type plot_sec(processed_sec_data, type = \"mwd\") } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SEC Calibration Curve — plot_sec_calibration","title":"Plot SEC Calibration Curve — plot_sec_calibration","text":"Creates calibration curve plot SEC calibration data prepped recipe conventional calibration.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SEC Calibration Curve — plot_sec_calibration","text":"","code":"plot_sec_calibration(   data,   retention_col = \"retention_time\",   mw_col = \"log_mp\",   show_residuals = FALSE,   show_r_squared = TRUE,   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SEC Calibration Curve — plot_sec_calibration","text":"data Either: data frame calibration standards retention log_mw columns prepped recipe containing conventional calibration step retention_col Name retention time/volume column. Default \"retention_time\". mw_col Name log MW column. Default \"log_mp\". show_residuals Logical. Show residual plot ? Default FALSE. show_r_squared Logical. Show R-squared value? Default TRUE. ... Additional arguments passed ggplot2::geom_point().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SEC Calibration Curve — plot_sec_calibration","text":"ggplot2 object (patchwork plots show_residuals = TRUE).","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_calibration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot SEC Calibration Curve — plot_sec_calibration","text":"","code":"if (FALSE) { # \\dontrun{ # Plot calibration from standards data plot_sec_calibration(sec_ps_standards)  # With residuals panel plot_sec_calibration(sec_ps_standards, show_residuals = TRUE) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SEC Chromatogram — plot_sec_chromatogram","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"Creates chromatogram plot SEC data showing detector signal vs elution time/volume.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"","code":"plot_sec_chromatogram(   data,   measures = NULL,   sample_id = NULL,   x_label = \"Elution Time (min)\",   y_label = \"Signal\",   normalize = FALSE,   facet_by = c(\"none\", \"measure\", \"sample\"),   color_by = c(\"sample\", \"measure\"),   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"data data frame containing SEC results measure columns, tibble measure_sec_slice_table(). measures Character vector measure column names plot. NULL, plots measure columns found. sample_id Column name containing sample identifiers. NULL, attempts auto-detect uses row numbers. x_label Label x-axis. Default \"Elution Time (min)\". y_label Label y-axis. Default \"Signal\". normalize Logical. Normalize signals 0-1 range comparison? Default FALSE. facet_by facet plot. One : \"none\": single plot (default) \"measure\": Separate panel per detector/measure \"sample\": Separate panel per sample color_by map color aesthetic. One \"sample\" (default) \"measure\". ... Additional arguments passed ggplot2::geom_line().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"fundamental SEC visualization showing raw processed chromatographic data. Works : Processed recipe output (data frames measure_list columns) Slice tables measure_sec_slice_table()","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_chromatogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot SEC Chromatogram — plot_sec_chromatogram","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process SEC data processed <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline(measures = \"ri\") |>   prep() |>   bake(new_data = NULL)  # Basic chromatogram plot_sec_chromatogram(processed, measures = \"ri\")  # Normalized overlay of multiple samples plot_sec_chromatogram(processed, measures = \"ri\", normalize = TRUE)  # Faceted by sample plot_sec_chromatogram(processed, facet_by = \"sample\") } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SEC Composition Distribution — plot_sec_composition","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"Creates composition plot showing copolymer blend composition function molecular weight elution time.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"","code":"plot_sec_composition(   data,   composition_col = \"composition_a\",   x_axis = c(\"mw\", \"retention\"),   mw_col = \"mw\",   sample_id = NULL,   show_average = TRUE,   component_names = NULL,   show_distribution = TRUE,   show_points = FALSE,   y_limits = c(0, 1),   log_mw = TRUE,   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"data data frame containing SEC results composition data, typically step_sec_composition(). composition_col Name composition measure column. Default \"composition_a\". contain values 0 1. x_axis Variable x-axis: \"mw\" (molecular weight, default) \"retention\" (elution time). mw_col Name molecular weight column. Default \"mw\". sample_id Column name containing sample identifiers. show_average Logical. Show average composition line? Default TRUE. component_names Named character vector component labels. E.g., c(= \"Styrene\", b = \"Acrylate\"). Default shows \"Component \" \"Component B\". show_distribution Logical. Show composition distribution lines? Default TRUE. show_points Logical. Show individual data points? Default FALSE. y_limits Numeric vector length 2 y-axis limits. Default c(0, 1) fraction scale. log_mw Logical. Use log scale MW x-axis? Default TRUE x_axis = \"mw\". ... Additional arguments passed ggplot2::geom_line().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"Composition plots essential characterizing copolymers blends: Uniform copolymers: Horizontal line across MW values indicates consistent composition throughout distribution. Compositional drift: Slope indicates composition varies chain length, common batch polymerization monomer ratios change time. Blend separation: Multiple distinct compositions indicate blend separation block copolymer structure. plot works output step_sec_composition() calculates weight fraction UV/RI detector signals known response factors.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_composition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot SEC Composition Distribution — plot_sec_composition","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure) library(ggplot2)  # Process copolymer data with composition calculation processed <- recipe(~., data = sec_copolymer) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_254_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     component_a_uv = 1.0,     component_a_ri = 0.185,     component_b_uv = 0.01,     component_b_ri = 0.084,     output_col = \"styrene_frac\"   ) |>   step_sec_conventional_cal(standards = ps_standards) |>   prep() |>   bake(new_data = NULL)  # Basic composition plot vs MW plot_sec_composition(   processed,   composition_col = \"styrene_frac\" )  # Composition vs retention time with custom component names plot_sec_composition(   processed,   composition_col = \"styrene_frac\",   x_axis = \"retention\",   component_names = c(a = \"Styrene\", b = \"Acrylate\") )  # Customize appearance plot_sec_composition(processed, composition_col = \"styrene_frac\") +   theme_bw() +   labs(title = \"Styrene-Acrylate Copolymer Composition\") } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SEC Conformation Data — plot_sec_conformation","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"Creates conformation plots showing structure-MW relationships multi-detector SEC data (Mark-Houwink plots, Rg-MW scaling).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"","code":"plot_sec_conformation(   data,   type = c(\"rg_mw\", \"eta_mw\", \"rh_mw\"),   mw_col = \"mw\",   y_col = NULL,   sample_id = NULL,   show_fit = TRUE,   show_exponent = TRUE,   compare_linear = NULL,   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"data data frame containing SEC results MW conformation data (Rg, intrinsic viscosity). type Type conformation plot: \"rg_mw\": Radius gyration vs molecular weight (default) \"eta_mw\": Intrinsic viscosity vs molecular weight \"rh_mw\": Hydrodynamic radius vs molecular weight mw_col Name molecular weight column. Default \"mw\". y_col Name y-axis column. NULL, auto-detected based type. sample_id Column name containing sample identifiers. show_fit Logical. Show power-law fit line? Default TRUE. show_exponent Logical. Annotate slope/exponent plot? Default TRUE. compare_linear Data frame linear reference polymer branching comparison. structure main data. ... Additional arguments passed ggplot2::geom_point().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"Conformation plots reveal polymer architecture: Rg-MW (radius gyration): Log-log slope indicates conformation: 0.33: Compact sphere 0.5-0.6: Random coil (linear polymer good solvent) 1.0: Rigid rod Branched polymers show reduced Rg MW compared linear. eta-MW (Mark-Houwink): relationship [eta] = K * M^: K Mark-Houwink parameters approximately 0.5-0.8 typical polymers Branched polymers show lower [eta] MW","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_conformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot SEC Conformation Data — plot_sec_conformation","text":"","code":"if (FALSE) { # \\dontrun{ # Rg-MW plot from MALS data plot_sec_conformation(processed_data, type = \"rg_mw\")  # Mark-Houwink plot plot_sec_conformation(processed_data, type = \"eta_mw\")  # Compare branched to linear reference plot_sec_conformation(   branched_data,   compare_linear = linear_reference ) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"Creates overlay plot multiple SEC detectors, optionally normalized aligned.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"","code":"plot_sec_multidetector(   data,   detectors,   sample_id = NULL,   samples = NULL,   normalize = TRUE,   x_label = \"Elution Time (min)\",   facet = FALSE,   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"data data frame containing SEC results multiple detector measure columns. detectors Character vector detector column names include. Common values: c(\"ri\", \"uv\", \"mals\", \"visc\"). sample_id Column name containing sample identifiers. NULL, plots samples auto-detects. samples Character vector specific sample IDs plot. NULL, plots samples. normalize Logical. Normalize detector 0-1 range comparison? Default TRUE. x_label Label x-axis. Default \"Elution Time (min)\". facet Logical. Create separate panel sample? Default FALSE (overlay). ... Additional arguments passed ggplot2::geom_line().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"Multi-detector overlay plots essential : Verifying detector alignment delay correction Identifying composition drift copolymers (UV/RI differences) Detecting aggregates (MALS response higher expected RI) Checking baseline issues across detectors normalize = TRUE (default), detector signal scaled 0-1 range, making easy compare peak shapes positions across detectors different response magnitudes.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_multidetector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Multi-Detector SEC Overlay — plot_sec_multidetector","text":"","code":"if (FALSE) { # \\dontrun{ # Multi-detector overlay for single sample plot_sec_multidetector(   processed_data,   detectors = c(\"ri\", \"uv\", \"mals\"),   samples = \"PMMA-1\" )  # Faceted by sample plot_sec_multidetector(   processed_data,   detectors = c(\"ri\", \"uv\"),   facet = TRUE ) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Molecular Weight Distribution — plot_sec_mwd","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"Creates molecular weight distribution (MWD) plot showing differential cumulative distribution.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"","code":"plot_sec_mwd(   data,   mw_col = \"mw\",   concentration_col = NULL,   sample_id = NULL,   type = c(\"differential\", \"cumulative\", \"both\"),   show_averages = TRUE,   log_mw = TRUE,   x_label = NULL,   y_label = NULL,   ... )"},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"data data frame containing SEC results calibrated MW data. mw_col Name molecular weight measure column. Default \"mw\". concentration_col Name concentration/signal column used weighting. NULL, uses first available measure column. sample_id Column name containing sample identifiers. type Type distribution plot: \"differential\": dW/d(log M) vs log M (default) \"cumulative\": Cumulative weight fraction vs log M \"\": faceted plot show_averages Logical. Show vertical lines Mn, Mw, Mz? Default TRUE. Requires columns present data. log_mw Logical. Use log10(MW) x-axis? Default TRUE. x_label Label x-axis. Default auto-generated based log_mw. y_label Label y-axis. Default auto-generated based type. ... Additional arguments passed ggplot2::geom_line().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"ggplot2 object.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"MWD plot standard way visualize polymer molecular weight distributions. differential distribution (dW/d log M) shows weight fraction polymer molecular weight. show_averages = TRUE, vertical dashed lines added : Mn (number-average): leftmost Mw (weight-average): middle Mz (z-average): rightmost","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/plot_sec_mwd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Molecular Weight Distribution — plot_sec_mwd","text":"","code":"if (FALSE) { # \\dontrun{ # After SEC processing with calibration plot_sec_mwd(processed_data)  # Cumulative distribution plot_sec_mwd(processed_data, type = \"cumulative\")  # Without MW average lines plot_sec_mwd(processed_data, show_averages = FALSE) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/required_pkgs.step_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"Returns packages required use step.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/required_pkgs.step_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"","code":"# S3 method for class 'step_sec_aggregates' required_pkgs(x, ...)  # S3 method for class 'step_sec_band_broadening' required_pkgs(x, ...)  # S3 method for class 'step_sec_baseline' required_pkgs(x, ...)  # S3 method for class 'step_sec_broad_standard' required_pkgs(x, ...)  # S3 method for class 'step_sec_composition' required_pkgs(x, ...)  # S3 method for class 'step_sec_concentration' required_pkgs(x, ...)  # S3 method for class 'step_sec_conventional_cal' required_pkgs(x, ...)  # S3 method for class 'step_sec_dad' required_pkgs(x, ...)  # S3 method for class 'step_sec_detector_delay' required_pkgs(x, ...)  # S3 method for class 'step_sec_dls' required_pkgs(x, ...)  # S3 method for class 'step_sec_exclude_regions' required_pkgs(x, ...)  # S3 method for class 'step_sec_flow_marker' required_pkgs(x, ...)  # S3 method for class 'step_sec_integration_window' required_pkgs(x, ...)  # S3 method for class 'step_sec_intrinsic_visc' required_pkgs(x, ...)  # S3 method for class 'step_sec_lals' required_pkgs(x, ...)  # S3 method for class 'step_sec_mals' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_averages' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_distribution' required_pkgs(x, ...)  # S3 method for class 'step_sec_mw_fractions' required_pkgs(x, ...)  # S3 method for class 'step_sec_oligomer' required_pkgs(x, ...)  # S3 method for class 'step_sec_peaks_deconvolve' required_pkgs(x, ...)  # S3 method for class 'step_sec_peaks_detect' required_pkgs(x, ...)  # S3 method for class 'step_sec_protein' required_pkgs(x, ...)  # S3 method for class 'step_sec_rals' required_pkgs(x, ...)  # S3 method for class 'step_sec_ri' required_pkgs(x, ...)  # S3 method for class 'step_sec_universal_cal' required_pkgs(x, ...)  # S3 method for class 'step_sec_uv' required_pkgs(x, ...)  # S3 method for class 'step_sec_uv_ri_ratio' required_pkgs(x, ...)  # S3 method for class 'step_sec_viscometer' required_pkgs(x, ...)"},{"path":"https://jameshwade.github.io/measure-sec/reference/required_pkgs.step_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"x recipe step object. ... currently used.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/required_pkgs.step_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Required Packages for SEC Steps — required_pkgs.step_sec_aggregates","text":"character vector package names.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Save SEC Calibration Parameters — save_sec_calibration","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"Extracts calibration parameters prepped recipe saves file later reuse. allows calibrations established applied future analyses without re-fitting.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"","code":"save_sec_calibration(   prepped_recipe,   file,   step_number = NULL,   metadata = NULL,   overwrite = FALSE )"},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"prepped_recipe prepped recipe containing trained calibration step (e.g., step_sec_conventional_cal). file Path save calibration file. File extension determines format: .rds RDS format (default), .yaml .yml YAML format. step_number Integer. step extract calibration . NULL (default), finds first calibration step automatically. metadata Optional named list additional metadata include (e.g., instrument, column, analyst, date). overwrite Logical. TRUE, overwrite existing file. Default FALSE.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"Invisibly returns calibration object saved.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"saved calibration includes: Calibration fit coefficients polynomial degree Calibration range (valid elution range) Fit diagnostics (R², RMSE, per-standard results) Original standards data Settings (fit_type, extrapolation, log_output) Timestamp version information Optional user-provided metadata RDS format preserves R objects exactly recommended uses. YAML format human-readable useful documentation version control.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/save_sec_calibration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save SEC Calibration Parameters — save_sec_calibration","text":"","code":"if (FALSE) { # \\dontrun{ # Create and prep a calibration recipe ps_standards <- data.frame(   retention = c(12.5, 13.2, 14.1, 15.0, 16.2, 17.5),   log_mw = c(6.0, 5.5, 5.0, 4.5, 4.0, 3.5) )  rec <- recipe(~., data = sample_data) |>   step_sec_conventional_cal(standards = ps_standards, fit_type = \"cubic\") |>   prep()  # Save calibration for later use save_sec_calibration(   rec,   \"ps_calibration.rds\",   metadata = list(     column = \"PLgel 5um Mixed-C\",     instrument = \"Agilent 1260\",     analyst = \"JW\"   ) ) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":null,"dir":"Reference","previous_headings":"","what":"Branched Polymer SEC Data — sec_branched","title":"Branched Polymer SEC Data — sec_branched","text":"synthetic dataset containing SEC chromatograms linear, branched, star polymers, designed demonstrating branching analysis using multi-detector SEC.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branched Polymer SEC Data — sec_branched","text":"","code":"sec_branched"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Branched Polymer SEC Data — sec_branched","text":"tibble 5,608 rows 10 columns: sample_id Character. Sample identifier (e.g., \"Linear-50K\") elution_time Numeric. Elution time minutes ri_signal Numeric. Refractive index detector signal visc_signal Numeric. Viscometer detector signal mals_signal Numeric. Multi-angle light scattering signal topology Character. Polymer topology: \"linear\", \"branched\", \"star\" mw Numeric. Weight-average molecular weight Da branching_index Numeric. Branching index g' (1.0 linear) intrinsic_visc Numeric. Intrinsic viscosity mL/g rg Numeric. Radius gyration nm","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Branched Polymer SEC Data — sec_branched","text":"Synthetic data generated package testing examples.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Branched Polymer SEC Data — sec_branched","text":"dataset includes polyethylene-like samples three topologies: Linear polymers (g' = 1.0) 50K, 100K, 200K MW Branched polymers (g' = 0.55-0.75) MW range Star polymers (g' = 0.50-0.60) 50K, 100K MW Key Observation: molecular weight, branched polymers smaller hydrodynamic volume elute LATER linear counterparts. basis branching analysis comparing SEC retention absolute MW MALS. Branching Index (g'): g' = \\([\\eta]_{branched}\\) / \\([\\eta]_{linear}\\) MW Values less 1.0 indicate branching. Lower values mean compact (branched) structures. Typical Workflow: Apply step_sec_mals absolute MW Apply step_sec_viscometer intrinsic viscosity Use measure_branching_index calculate g' Plot Mark-Houwink relationship compare topologies","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_branched.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branched Polymer SEC Data — sec_branched","text":"","code":"data(sec_branched)  # Compare topologies unique(sec_branched[, c(\"sample_id\", \"topology\", \"mw\", \"branching_index\")]) #> # A tibble: 8 × 4 #>   sample_id   topology     mw branching_index #>   <chr>       <chr>     <dbl>           <dbl> #> 1 Linear-50K  linear    50000            1    #> 2 Linear-100K linear   100000            1    #> 3 Linear-200K linear   200000            1    #> 4 Branch-50K  branched  50000            0.75 #> 5 Branch-100K branched 100000            0.65 #> 6 Branch-200K branched 200000            0.55 #> 7 Star-50K    star      50000            0.6  #> 8 Star-100K   star     100000            0.5   # Plot linear vs branched at same MW if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    sec_branched |>     filter(mw == 100000) |>     ggplot(aes(elution_time, ri_signal, color = topology)) +     geom_line() +     labs(       x = \"Elution Time (min)\",       y = \"RI Signal\",       title = \"100K MW: Linear vs Branched vs Star\",       subtitle = \"Branched polymers elute later (smaller Vh)\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"Comprehensive calibration standard data SEC/GPC analysis, containing polystyrene PMMA narrow standards certificate values, retention data, Mark-Houwink parameters. Based commercial standard kits.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"","code":"sec_calibration_standards"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"tibble 26 rows 19 columns: standard_name Character. Standard identifier (e.g., \"PS-67500\", \"PMMA-30300\") polymer_type Character. Either \"polystyrene\" \"pmma\" kit_name Character. Commercial kit name reference mp Numeric. Peak molecular weight Da (commonly used calibration) mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn), typically 1.02-1.05 mp_uncertainty Numeric. Relative uncertainty Mp (e.g., 0.05 = 5%) log_mp Numeric. log10(Mp) calibration curve fitting log_mw Numeric. log10(Mw) log_mn Numeric. log10(Mn) retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL k_value Numeric. Mark-Houwink K constant mL/g a_value Numeric. Mark-Houwink exponent (alpha) intrinsic_viscosity Numeric. Intrinsic viscosity mL/g log_hydrodynamic_vol Numeric. log10(M * [eta]) universal calibration dn_dc Numeric. Refractive index increment mL/g notes Character. Special notes (e.g., near exclusion limit)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"Synthetic data based typical commercial narrow standards (e.g., Agilent EasiVial, PSS ReadyCal) realistic retention times PLgel Mixed-C columns THF 1.0 mL/min.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"dataset enables several key calibration workflows: Conventional Calibration: Use retention_time (retention_volume) log_mp step_sec_conventional_cal build calibration curve. Universal Calibration: Use log_hydrodynamic_vol vs retention polymer-independent calibration. Mark-Houwink parameters (k_value, a_value) enable conversion polymers. Quality Assessment: mp_uncertainty values (typical certificates) enable uncertainty propagation calibration. Dispersity values confirm standards suitably narrow. Polymer Types: 16 polystyrene standards (162 Da 3,150,000 Da) 10 PMMA standards (602 Da 1,190,000 Da) Mark-Houwink Parameters (THF, 35°C): Polystyrene: K = 0.000141 mL/g, = 0.700 PMMA: K = 0.000128 mL/g, = 0.690","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_calibration_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC Calibration Standards - Complete Dataset — sec_calibration_standards","text":"","code":"library(dplyr) data(sec_calibration_standards)  # View the polystyrene standards sec_calibration_standards |>   filter(polymer_type == \"polystyrene\") |>   select(standard_name, mp, log_mp, retention_time) #> # A tibble: 16 × 4 #>    standard_name      mp log_mp retention_time #>    <chr>           <dbl>  <dbl>          <dbl> #>  1 PS-3150000    3150000   6.50           11.2 #>  2 PS-1870000    1870000   6.27           11.6 #>  3 PS-1090000    1090000   6.04           12.1 #>  4 PS-630000      630000   5.80           12.6 #>  5 PS-430000      430000   5.63           13.2 #>  6 PS-216000      216000   5.33           13.8 #>  7 PS-120000      120000   5.08           14.3 #>  8 PS-67500        67500   4.83           15.0 #>  9 PS-33500        33500   4.53           15.5 #> 10 PS-19800        19800   4.30           16.1 #> 11 PS-9680          9680   3.99           16.7 #> 12 PS-5030          5030   3.70           17.4 #> 13 PS-2970          2970   3.47           17.9 #> 14 PS-1050          1050   3.02           18.9 #> 15 PS-580            580   2.76           19.4 #> 16 PS-162            162   2.21           20.8  # Compare PS and PMMA at similar MW - PMMA elutes later (smaller Rh) sec_calibration_standards |>   filter(mp > 60000 & mp < 80000) |>   select(standard_name, polymer_type, mp, retention_time) #> # A tibble: 2 × 4 #>   standard_name polymer_type    mp retention_time #>   <chr>         <chr>        <dbl>          <dbl> #> 1 PMMA-67700    pmma         67700           14.8 #> 2 PS-67500      polystyrene  67500           15.0  # Prepare standards for conventional calibration ps_cal <- sec_calibration_standards |>   filter(polymer_type == \"polystyrene\") |>   select(retention = retention_time, log_mw = log_mp)"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":null,"dir":"Reference","previous_headings":"","what":"Copolymer SEC Data for Composition Analysis — sec_copolymer","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"synthetic dataset containing SEC chromatograms styrene-acrylate copolymers varying compositions, designed demonstrating UV/RI ratio analysis composition determination.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"","code":"sec_copolymer"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"tibble 4,206 rows 8 columns: sample_id Character. Sample identifier (e.g., \"Copoly-20S\") elution_time Numeric. Elution time minutes ri_signal Numeric. Refractive index detector signal uv_254_signal Numeric. UV detector signal 254 nm styrene_fraction Numeric. Styrene content (0-1) mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn) description Character. Sample description","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"Synthetic data generated package testing examples.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"dataset includes 6 samples spanning full composition range: Pure polyacrylate (0% styrene) - UV absorption 20%, 40%, 60%, 80% styrene copolymers Pure polystyrene (100% styrene) - strong UV absorption UV/RI Ratio Analysis: UV signal 254 nm selective styrene units, RI signal responds total mass. UV/RI ratio across chromatogram reveals composition function molecular weight, enabling detection compositional drift. Typical Workflow: Load data convert measure format Apply step_sec_uv_ri_ratio calculate ratios Calibrate ratio composition using homopolymer standards Plot composition vs molecular weight","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_copolymer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copolymer SEC Data for Composition Analysis — sec_copolymer","text":"","code":"data(sec_copolymer)  # View composition range unique(sec_copolymer[, c(\"sample_id\", \"styrene_fraction\")]) #> # A tibble: 6 × 2 #>   sample_id  styrene_fraction #>   <chr>                 <dbl> #> 1 Copoly-20S              0.2 #> 2 Copoly-40S              0.4 #> 3 Copoly-60S              0.6 #> 4 Copoly-80S              0.8 #> 5 PS-Homo                 1   #> 6 PA-Homo                 0    # Plot RI vs UV for different compositions if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   ggplot(sec_copolymer, aes(elution_time)) +     geom_line(aes(y = ri_signal, color = \"RI\")) +     geom_line(aes(y = uv_254_signal, color = \"UV 254nm\")) +     facet_wrap(~sample_id) +     labs(x = \"Elution Time (min)\", y = \"Signal\", color = \"Detector\") +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC PMMA Calibration Standards — sec_pmma_standards","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"Poly(methyl methacrylate) narrow molecular weight standards SEC/GPC calibration. convenient subset sec_calibration_standards containing PMMA standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"","code":"sec_pmma_standards"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"tibble 10 rows 12 columns: standard_name Character. Standard identifier (e.g., \"PMMA-67700\") mp Numeric. Peak molecular weight Da log_mp Numeric. log10(Mp) calibration curve fitting retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn) mp_uncertainty Numeric. Relative uncertainty Mp k_value Numeric. Mark-Houwink K constant (0.000128 mL/g) a_value Numeric. Mark-Houwink exponent (0.690) dn_dc Numeric. Refractive index increment (0.084 mL/g)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"Synthetic data based typical commercial narrow PMMA standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"PMMA standards useful : Calibrating PMMA acrylate samples Validating universal calibration comparing PS vs PMMA curves Demonstrating polymer-specific hydrodynamic volume differences equivalent molecular weight, PMMA smaller hydrodynamic volume PS THF, PMMA standards elute later PS MW. demonstrates conventional calibration polymer-specific. Universal Calibration Validation: plotted log(M * [eta]) vs retention time, PS PMMA fall curve, confirming universal calibration valid column.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_pmma_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC PMMA Calibration Standards — sec_pmma_standards","text":"","code":"data(sec_pmma_standards) data(sec_ps_standards)  # Compare PS and PMMA calibration curves if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    bind_rows(     sec_ps_standards |> mutate(polymer = \"PS\"),     sec_pmma_standards |> mutate(polymer = \"PMMA\")   ) |>     ggplot(aes(retention_time, log_mp, color = polymer)) +     geom_point(size = 3) +     geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), se = FALSE) +     labs(       x = \"Retention Time (min)\",       y = expression(log[10](M[p])),       title = \"PS vs PMMA Calibration Curves\",       subtitle = \"PMMA elutes later at same MW (smaller hydrodynamic volume)\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":null,"dir":"Reference","previous_headings":"","what":"Protein SEC Data with Aggregates — sec_protein","title":"Protein SEC Data with Aggregates — sec_protein","text":"synthetic dataset containing SEC chromatograms monoclonal antibody (mAb) various stress conditions, showing monomer, dimer, higher-order aggregates, fragments.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Protein SEC Data with Aggregates — sec_protein","text":"","code":"sec_protein"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Protein SEC Data with Aggregates — sec_protein","text":"tibble 6,255 rows 9 columns: sample_id Character. Sample identifier (e.g., \"mAb-Reference\") elution_time Numeric. Elution time minutes uv_280_signal Numeric. UV detector signal 280 nm uv_214_signal Numeric. UV detector signal 214 nm description Character. Sample treatment description monomer_pct Numeric. Known monomer percentage dimer_pct Numeric. Known dimer percentage hmw_pct Numeric. Known high molecular weight aggregate percentage fragment_pct Numeric. Known fragment percentage","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Protein SEC Data with Aggregates — sec_protein","text":"Synthetic data generated package testing examples.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Protein SEC Data with Aggregates — sec_protein","text":"dataset simulates typical mAb (~150 kDa) various conditions: Reference standard (>98% monomer) Heat-stressed samples (40°C 1-2 weeks) Aged sample (12-month stability) Freeze-thaw stressed sample Species Present: High molecular weight (HMW) aggregates (~600 kDa) Dimer (~300 kDa) Monomer (~150 kDa) Fragments (~50 kDa, Fab-like) Typical Workflow: Load data apply baseline correction Use step_sec_aggregates identify quantify species Calculate percent area species Compare acceptance criteria","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_protein.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Protein SEC Data with Aggregates — sec_protein","text":"","code":"data(sec_protein)  # View sample conditions unique(sec_protein[, c(\"sample_id\", \"description\", \"monomer_pct\")]) #> # A tibble: 5 × 3 #>   sample_id       description         monomer_pct #>   <chr>           <chr>                     <dbl> #> 1 mAb-Reference   Reference standard         98.5 #> 2 mAb-Stressed-1  Heat stress 40C 1wk        94   #> 3 mAb-Stressed-2  Heat stress 40C 2wk        88   #> 4 mAb-Aged        12 month stability         96   #> 5 mAb-Freeze-Thaw 5x freeze-thaw             95.5  # Plot stressed vs reference if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    sec_protein |>     filter(sample_id %in% c(\"mAb-Reference\", \"mAb-Stressed-2\")) |>     ggplot(aes(elution_time, uv_280_signal, color = sample_id)) +     geom_line() +     labs(       x = \"Elution Time (min)\",       y = \"UV 280 nm Signal\",       title = \"Protein SEC: Reference vs Stressed\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC Polystyrene Calibration Standards — sec_ps_standards","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Polystyrene narrow molecular weight standards SEC/GPC conventional calibration. convenient subset sec_calibration_standards containing polystyrene standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"","code":"sec_ps_standards"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"tibble 16 rows 12 columns: standard_name Character. Standard identifier (e.g., \"PS-67500\") mp Numeric. Peak molecular weight Da log_mp Numeric. log10(Mp) calibration curve fitting retention_time Numeric. Peak retention time minutes retention_volume Numeric. Peak retention volume mL mn Numeric. Number-average molecular weight Da mw Numeric. Weight-average molecular weight Da dispersity Numeric. Polydispersity index (Mw/Mn) mp_uncertainty Numeric. Relative uncertainty Mp k_value Numeric. Mark-Houwink K constant (0.000141 mL/g) a_value Numeric. Mark-Houwink exponent (0.700) dn_dc Numeric. Refractive index increment (0.185 mL/g)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Synthetic data based typical commercial narrow PS standards.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"Polystyrene widely used SEC calibration standard due : Availability narrow dispersity grades across wide MW range Well-characterized Mark-Houwink parameters common solvents Strong UV absorption dual detection Good solubility stability 16 standards span 162 Da 3,150,000 Da, covering typical analytical SEC columns. Standards pre-sorted descending molecular weight (elution order). Usage step_sec_conventional_cal:","code":"library(dplyr) standards <- sec_ps_standards |>   select(retention = retention_time, log_mw = log_mp)  recipe(~., data = my_data) |>   step_sec_conventional_cal(standards = standards, fit_type = \"cubic\")"},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_ps_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC Polystyrene Calibration Standards — sec_ps_standards","text":"","code":"data(sec_ps_standards)  # Quick look at the calibration range range(sec_ps_standards$mp) #> [1]     162 3150000 range(sec_ps_standards$retention_time) #> [1] 11.150 20.787  # Plot calibration curve if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   ggplot(sec_ps_standards, aes(retention_time, log_mp)) +     geom_point(size = 3) +     geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), se = FALSE) +     labs(       x = \"Retention Time (min)\",       y = expression(log[10](M[p])),       title = \"PS Calibration Curve (Cubic Fit)\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":null,"dir":"Reference","previous_headings":"","what":"Raw Multi-Detector SEC Data — sec_raw_multidetector","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"dataset containing raw SEC chromatograms RI, UV, MALS detector signals corrected inter-detector delay. Designed teaching triple detection workflows raw data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"","code":"sec_raw_multidetector"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"tibble approximately 48,000 rows 12 columns: sample_id Character. Sample identifier description Character. Sample description mw Numeric. Known weight-average MW Da dispersity Numeric. Known dispersity dn_dc Numeric. Refractive index increment mL/g ext_coef Numeric. UV extinction coefficient time_min Numeric. Elution time minutes ri_mv Numeric. RI detector signal millivolts uv_au Numeric. UV detector signal absorbance units mals_mv Numeric. MALS detector signal millivolts delay_uv_ml Numeric. True UV detector delay mL (negative = RI) delay_mals_ml Numeric. True MALS detector delay mL (positive = RI)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"Synthetic data generated package tutorials.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"dataset simulates raw multi-detector SEC data inter-detector delay correction. detectors physically separated flow path, peaks appear different times detector. Detector Configuration: UV detector 0.08 mL RI (peaks appear earlier) MALS detector 0.18 mL RI (peaks appear later) RI reference detector (delay = 0) Samples Included: PS-DelayStd: Narrow PS standard determining delays Sample-1: PS sample strong UV absorption Sample-2: PMMA sample weak UV Sample-3: Copolymer sample Tutorial Workflow: Load raw multi-detector data Use delay standard determine inter-detector offsets Apply step_sec_detector_delay align signals Process step_sec_mals absolute MW","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_multidetector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raw Multi-Detector SEC Data — sec_raw_multidetector","text":"","code":"data(sec_raw_multidetector)  # View sample information unique(sec_raw_multidetector[, c(\"sample_id\", \"description\", \"mw\")]) #> # A tibble: 4 × 3 #>   sample_id   description                           mw #>   <chr>       <chr>                              <dbl> #> 1 PS-DelayStd Narrow PS for delay determination 100000 #> 2 Sample-1    PS sample with UV absorption       75000 #> 3 Sample-2    PMMA sample (weak UV)             150000 #> 4 Sample-3    Copolymer sample                   45000  # Plot delay standard showing detector offset (peaks not aligned) if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)   library(tidyr)    sec_raw_multidetector |>     filter(sample_id == \"PS-DelayStd\") |>     select(time_min, ri_mv, uv_au, mals_mv) |>     # Normalize for comparison     mutate(       ri_norm = ri_mv / max(ri_mv),       uv_norm = uv_au / max(uv_au),       mals_norm = mals_mv / max(mals_mv)     ) |>     select(time_min, RI = ri_norm, UV = uv_norm, MALS = mals_norm) |>     pivot_longer(-time_min, names_to = \"detector\", values_to = \"signal\") |>     ggplot(aes(time_min, signal, color = detector)) +     geom_line() +     labs(       x = \"Time (min)\",       y = \"Normalized Signal\",       title = \"Raw Multi-Detector Data (Before Delay Correction)\",       subtitle = \"Note: Peaks are NOT aligned - UV leads, MALS lags\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":null,"dir":"Reference","previous_headings":"","what":"Raw SEC Calibration Standards — sec_raw_standards","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"dataset containing raw SEC chromatograms polystyrene narrow standards realistic noise, baseline drift, injection artifacts. Designed mimic data exported directly SEC instruments tutorial purposes.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"","code":"sec_raw_standards"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"tibble approximately 130,000 rows 6 columns: standard_name Character. Standard identifier (e.g., \"PS-67500\") mp Numeric. Peak molecular weight Da certificate log_mp Numeric. log10(Mp) calibration curve fitting dispersity Numeric. Polydispersity index certificate time_min Numeric. Elution time minutes ri_mv Numeric. RI detector signal millivolts (raw, unprocessed)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"Synthetic data generated package tutorials.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"dataset represents \"raw\" data come SEC instrument, processing. Key characteristics include: Realistic Signal Features: Gaussian noise detector signal Slow baseline drift temperature fluctuations Injection artifacts start run Peak tailing typical SEC columns Standards Included: 12 polystyrene narrow standards spanning 580 Da 930,000 Da, covering typical analytical SEC range. Standards based commercial kit values. Typical Tutorial Workflow: Load raw data inspect quality Apply baseline correction step_sec_baseline Identify peak retention times Build calibration curve step_sec_conventional_cal","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_standards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raw SEC Calibration Standards — sec_raw_standards","text":"","code":"data(sec_raw_standards)  # View available standards unique(sec_raw_standards[, c(\"standard_name\", \"mp\", \"dispersity\")]) #> # A tibble: 12 × 3 #>    standard_name     mp dispersity #>    <chr>          <dbl>      <dbl> #>  1 PS-580           580       1.06 #>  2 PS-1270         1270       1.04 #>  3 PS-2960         2960       1.03 #>  4 PS-5970         5970       1.02 #>  5 PS-9680         9680       1.02 #>  6 PS-19600       19600       1.02 #>  7 PS-33500       33500       1.02 #>  8 PS-67500       67500       1.02 #>  9 PS-135000     135000       1.01 #> 10 PS-270000     270000       1.01 #> 11 PS-495000     495000       1.02 #> 12 PS-930000     930000       1.02  # Plot a single standard (shows noise and baseline) if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    sec_raw_standards |>     filter(standard_name == \"PS-67500\") |>     ggplot(aes(time_min, ri_mv)) +     geom_line() +     labs(       x = \"Time (min)\",       y = \"RI Signal (mV)\",       title = \"Raw PS-67500 Standard\",       subtitle = \"Note baseline drift and noise\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":null,"dir":"Reference","previous_headings":"","what":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"dataset containing raw SEC chromatograms polymer samples known true molecular weight values validation. Includes challenging cases like bimodal distributions high molecular weight aggregates.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"","code":"sec_raw_unknowns"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"tibble approximately 65,000 rows 8 columns: sample_id Character. Sample identifier description Character. Sample description type true_mw Numeric. Known weight-average MW Da (NA bimodal) true_mn Numeric. Known number-average MW Da true_mz Numeric. Known z-average MW Da true_dispersity Numeric. Known dispersity (Mw/Mn) time_min Numeric. Elution time minutes ri_mv Numeric. RI detector signal millivolts (raw)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"Synthetic data generated package tutorials.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"dataset provides unknown samples known \"true\" MW values, enabling validation complete SEC workflow raw data final results. Sample Types: Unknown-: Broad distribution (dispersity ~2.0) Unknown-B: Medium dispersity (~1.3) Unknown-C: Narrow distribution (~1.1) accuracy check Unknown-Bimodal: Two-peak mixture (50K + 200K) Unknown-HMW: high MW (~1.5M) aggregate shoulder Unknown-LMW: Low MW oligomers (~3.5K) Educational Value: Students can compare calculated MW values true values validate analysis workflow understand sources error.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_raw_unknowns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raw SEC Unknown Samples with Known Molecular Weights — sec_raw_unknowns","text":"","code":"data(sec_raw_unknowns)  # View sample information unique(sec_raw_unknowns[,   c(\"sample_id\", \"description\", \"true_mw\", \"true_dispersity\")]) #> # A tibble: 6 × 4 #>   sample_id       description                   true_mw true_dispersity #>   <chr>           <chr>                           <dbl>           <dbl> #> 1 Unknown-A       Broad distribution PMMA-like    45000            2.05 #> 2 Unknown-B       Medium dispersity PS-like      125000            1.32 #> 3 Unknown-C       Narrow distribution reference   82000            1.09 #> 4 Unknown-Bimodal Bimodal mixture (50K + 200K)       NA           NA    #> 5 Unknown-HMW     Very high MW with aggregates  1500000            1.25 #> 6 Unknown-LMW     Low MW oligomer region           3500            1.25  # Plot the bimodal sample if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   library(dplyr)    sec_raw_unknowns |>     filter(sample_id == \"Unknown-Bimodal\") |>     ggplot(aes(time_min, ri_mv)) +     geom_line() +     labs(       x = \"Time (min)\",       y = \"RI Signal (mV)\",       title = \"Bimodal Distribution\",       subtitle = \"Mixture of 50K and 200K components\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Create SEC Results Object — sec_results","title":"Create SEC Results Object — sec_results","text":"Constructor sec_results class, wraps processed SEC/GPC data enables ggplot2's autoplot() functionality automatic visualization.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create SEC Results Object — sec_results","text":"","code":"sec_results(data, sample_id = NULL)"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create SEC Results Object — sec_results","text":"data data frame containing processed SEC results measure columns. Typically output bake() prepped SEC recipe. sample_id Optional. Column name containing sample identifiers. NULL, auto-detection attempted.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create SEC Results Object — sec_results","text":"object class sec_results (inherits tbl_df).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create SEC Results Object — sec_results","text":"sec_results class provides unified interface SEC/GPC data enables: Automatic plot selection via autoplot() Integration ggplot2 theming Summary statistics access Expected Data Structure: input data contain measure columns (list columns location value components). Common measure columns include: ri, uv, mals - Detector signals mw - Molecular weight calibration concentration - Concentration profile intrinsic_visc - Intrinsic viscosity rg - Radius gyration","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create SEC Results Object — sec_results","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure) library(ggplot2)  # Process SEC data processed <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline(measures = \"ri\") |>   step_sec_conventional_cal(standards = ps_standards) |>   prep() |>   bake(new_data = NULL)  # Wrap as sec_results results <- sec_results(processed, sample_id = \"sample_id\")  # Use autoplot for automatic visualization autoplot(results) autoplot(results, type = \"mwd\") autoplot(results, type = \"chromatogram\", normalize = TRUE) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":null,"dir":"Reference","previous_headings":"","what":"System Suitability Test Data — sec_system_suitability","title":"System Suitability Test Data — sec_system_suitability","text":"synthetic dataset containing SEC system suitability test (SST) runs showing column degradation time, useful QC testing demonstrating column performance metrics.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"System Suitability Test Data — sec_system_suitability","text":"","code":"sec_system_suitability"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"System Suitability Test Data — sec_system_suitability","text":"tibble 10,005 rows 7 columns: run_id Character. Run identifier (e.g., \"SST-Day0\") elution_time Numeric. Elution time minutes ri_signal Numeric. Refractive index detector signal column_age_days Numeric. Column age days expected_plate_count Numeric. Expected theoretical plate count expected_asymmetry Numeric. Expected peak asymmetry factor expected_resolution Numeric. Expected resolution peaks","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"System Suitability Test Data — sec_system_suitability","text":"Synthetic data generated package testing examples.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"System Suitability Test Data — sec_system_suitability","text":"dataset simulates SST runs using two polystyrene standards (50K 100K MW) measured different column ages (0, 30, 60, 90, 120 days). Column Degradation Effects: column ages, typical degradation patterns include: Decreased plate count (broader peaks) Increased asymmetry (tailing) Decreased resolution peaks QC Metrics Available: Use QC functions calculate verify: measure_sec_plate_count - Theoretical plates measure_sec_asymmetry - Peak asymmetry measure_sec_resolution - Peak resolution measure_sec_suitability - Combined SST check Typical Workflow: Load daily SST run Calculate QC metrics Compare specifications Track trends time","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_system_suitability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"System Suitability Test Data — sec_system_suitability","text":"","code":"data(sec_system_suitability)  # View column age progression unique(sec_system_suitability[,   c(\"run_id\", \"column_age_days\", \"expected_plate_count\")]) #> # A tibble: 5 × 3 #>   run_id     column_age_days expected_plate_count #>   <chr>                <dbl>                <dbl> #> 1 SST-Day0                 0                45000 #> 2 SST-Day30               30                43000 #> 3 SST-Day60               60                40000 #> 4 SST-Day90               90                36000 #> 5 SST-Day120             120                32000  # Plot degradation over time if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)    ggplot(sec_system_suitability, aes(elution_time, ri_signal, color = run_id)) +     geom_line() +     labs(       x = \"Elution Time (min)\",       y = \"RI Signal\",       title = \"System Suitability: Column Degradation Over Time\"     ) +     theme_minimal() }"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-Detector SEC Data — sec_triple_detect","title":"Multi-Detector SEC Data — sec_triple_detect","text":"synthetic dataset containing multi-detector Size Exclusion Chromatography (SEC) data 12 polymer samples realistic signal characteristics.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-Detector SEC Data — sec_triple_detect","text":"","code":"sec_triple_detect"},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Multi-Detector SEC Data — sec_triple_detect","text":"tibble 24,012 rows 11 columns: sample_id Character. Unique sample identifier (e.g., \"PS-10K\", \"PMMA-Low\") sample_type Character. Either \"standard\" (narrow dispersity calibrants) \"sample\" polymer_type Character. Polymer type: \"polystyrene\", \"pmma\", \"peg\", \"copolymer\" elution_time Numeric. Elution time minutes (5-25 min range) ri_signal Numeric. Refractive index detector signal (reference detector) uv_signal Numeric. UV detector signal 280 nm mals_signal Numeric. Multi-angle light scattering detector signal known_mw Numeric. True weight-average molecular weight (Mw) g/mol known_dispersity Numeric. True dispersity (Mw/Mn) dn_dc Numeric. Refractive index increment mL/g extinction_coef Numeric. UV extinction coefficient mL/(mg*cm)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Multi-Detector SEC Data — sec_triple_detect","text":"Synthetic data generated package testing examples.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multi-Detector SEC Data — sec_triple_detect","text":"dataset includes realistic features commonly encountered SEC analysis: Sample Composition: 5 polystyrene standards (1K 500K MW, narrow dispersity ~1.01-1.05) 3 PMMA samples (25K 200K MW, broader dispersity 1.8-2.2) 2 PEG samples (5K 20K MW, low dispersity ~1.1-1.15) 2 copolymer samples (40K 80K MW, intermediate dispersity 1.5-1.7) Multi-Detector Features: Inter-detector volume delays: UV 0.05 mL RI, MALS 0.15 mL RI Different detector responses based polymer chemistry PEG UV response (extinction_coef = 0) MALS signal scales MW absolute MW determination Signal Characteristics: Gaussian noise appropriate detector Slight baseline drift Log-normal peak shapes tailing Typical SEC Workflow: 1 . Convert measure format step_measure_input_long 2. Correct inter-detector delays step_sec_detector_delay 3. Apply baseline correction step_sec_baseline 4. Process detectors step_sec_ri step_sec_uv 5. Convert concentration step_sec_concentration 6. Calculate MW averages step_sec_mw_averages","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/sec_triple_detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-Detector SEC Data — sec_triple_detect","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure) library(measure.sec)  # Load the dataset data(sec_triple_detect)  # View sample distribution table(sec_triple_detect$polymer_type)  # Plot RI chromatograms for polystyrene standards library(ggplot2) sec_triple_detect |>   dplyr::filter(polymer_type == \"polystyrene\") |>   ggplot(aes(elution_time, ri_signal, color = sample_id)) +   geom_line() +   labs(x = \"Elution Time (min)\", y = \"RI Signal\", color = \"Sample\")  # Process with SEC recipe rec <- recipe(~ ., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline(measures = \"ri\") |>   step_sec_ri(dn_dc_column = \"dn_dc\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"step_sec_aggregates() creates specification recipe step quantifies high molecular weight species (HMWS/aggregates), monomers, low molecular weight species (LMWS/fragments) protein SEC chromatograms.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"","code":"step_sec_aggregates(   recipe,   measures = NULL,   monomer_start = NULL,   monomer_end = NULL,   method = c(\"tallest\", \"manual\"),   hmws_threshold = 0.001,   include_main_peak = TRUE,   output_prefix = \"purity_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_aggregates\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. monomer_start Start monomer peak region (location units, typically minutes). NULL, automatically determined. monomer_end End monomer peak region. NULL, automatically determined. method Method peak boundary detection monomer_start monomer_end NULL: \"tallest\" (default): Uses tallest peak monomer \"manual\": Requires explicit boundaries hmws_threshold Minimum fraction monomer height consider HMWS signal. Default 0.001 (0.1%). , signal considered baseline. include_main_peak Logical. Include main peak boundaries output? Default TRUE. output_prefix Prefix output columns. Default \"purity_\". Creates columns: {prefix}hmws, {prefix}monomer, {prefix}lmws. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"updated recipe new columns containing aggregate percentages: purity_hmws Percent high molecular weight species (aggregates) purity_monomer Percent monomer (main peak) purity_lmws Percent low molecular weight species (fragments) purity_main_start Start main peak region (include_main_peak) purity_main_end End main peak region (include_main_peak)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"Aggregate analysis critical biopharmaceutical characterization: HMWS (High Molecular Weight Species): Elute monomer peak. Includes dimers, trimers, higher-order aggregates. Monomer: main therapeutic protein peak. LMWS (Low Molecular Weight Species): Elute monomer peak. Includes fragments, clips, degradation products. Calculation Method: $$\\% HMWS = \\frac{A_{HMWS}}{A_{total}} \\times 100$$ $$\\% Monomer = \\frac{A_{monomer}}{A_{total}} \\times 100$$ $$\\% LMWS = \\frac{A_{LMWS}}{A_{total}} \\times 100$$ represents integrated peak areas. Regulatory Importance: ICH Q6B requires aggregate content specification USP <129> provides guidance aggregate testing Typical acceptance: HMWS < 5%, Monomer > 95%","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"accurate results: Baseline correct chromatogram first Ensure proper column resolution (especially dimer separation) Use UV detection 280 nm (214 nm higher sensitivity)","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify Protein Aggregates and Fragments in SEC — step_sec_aggregates","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Analyze mAb aggregate content rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_aggregates(     monomer_start = 8.5,     monomer_end = 10.5   ) |>   prep()  # Automatic peak detection rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_aggregates(method = \"tallest\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":null,"dir":"Reference","previous_headings":"","what":"Band Broadening Correction for SEC — step_sec_band_broadening","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"step_sec_band_broadening() creates specification recipe step corrects axial dispersion (band broadening) SEC chromatograms. improves accuracy molecular weight distribution measurements.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"","code":"step_sec_band_broadening(   recipe,   measures = NULL,   method = c(\"tung\", \"emg\"),   sigma = NULL,   calibration_peak = NULL,   tau = NULL,   iterations = 1,   damping = 0.5,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_band_broadening\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"recipe recipe object. measures Character vector measure column names process. NULL, measure columns processed. method Correction method. One : \"tung\" (default): Tung's linear correction \"emg\": Exponentially Modified Gaussian deconvolution sigma Spreading parameter (standard deviation instrumental broadening function) units location axis (typically minutes mL). NULL, must provide calibration_peak. calibration_peak measure_tbl data frame location value columns representing narrow standard peak used estimate sigma. tau Exponential time constant EMG method. NULL EMG method, estimated calibration_peak. iterations Number iterations iterative correction. Default 1 Tung's method (single pass). Higher values may improve correction can introduce instability. damping Damping factor (0-1) prevent -correction instability. Default 0.5. Lower values conservative. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Band broadening SEC occurs due : Axial diffusion elution Non-ideal column packing Extra-column volume (tubing, connections, detector cell) causes: Artificially broadened peaks Underestimated Mn (number-average MW) Overestimated dispersity (Mw/Mn) Tung's Method (default): observed chromatogram F(V) related true distribution W(V) : $$F(V) = \\int W(V') G(V - V') dV'$$ G Gaussian spreading function standard deviation sigma. Tung's linear correction approximates: $$W(V) \\approx F(V) - \\sigma^2 \\frac{d^2 F(V)}{dV^2}$$ EMG Method: Models band broadening convolution Exponentially Modified Gaussian, better handles asymmetric peak shapes caused tailing. Sigma Determination: spreading parameter sigma determined narrow molecular weight standard (e.g., polystyrene PDI < 1.05). Use estimate_sigma() calculate sigma standard.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Correction applied signal, molecular weight values Large corrections (> 50% change peak width) may indicate unreliable sigma poor chromatographic conditions step preserves area curve (mass conservation)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"Tung, L. H. (1966). Method calculating molecular weight distribution function gel permeation chromatograms. Journal Applied Polymer Science, 10(3), 375-385.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_band_broadening.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Band Broadening Correction for SEC — step_sec_band_broadening","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Using a known sigma value rec <- recipe(~., data = sec_data) |>   step_measure_input_long(signal, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_band_broadening(sigma = 0.05) |>   prep()  # Estimating sigma from a narrow standard narrow_std <- estimate_sigma(narrow_standard_peak) rec <- recipe(~., data = sec_data) |>   step_measure_input_long(signal, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_band_broadening(sigma = narrow_std$sigma) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Baseline Correction — step_sec_baseline","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"step_sec_baseline() creates specification recipe step applies baseline correction optimized Gel Permeation Chromatography (GPC) Size Exclusion Chromatography (SEC) data. method estimates baseline interpolating baseline regions start end chromatogram.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"","code":"step_sec_baseline(   recipe,   measures = NULL,   left_frac = 0.05,   right_frac = 0.05,   method = \"linear\",   rf_span = 2/3,   rf_maxit = c(20, 20),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_baseline\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"recipe recipe object. step added sequence operations recipe. measures optional character vector measure column names process. NULL (default), measure columns (columns class measure_list) processed. left_frac Fraction points beginning use left baseline region. Default 0.05 (first 5% data points). used method = \"rf\". right_frac Fraction points end use right baseline region. Default 0.05 (last 5% data points). used method = \"rf\". method Method baseline estimation. One : \"linear\" (default): Linear interpolation left right means \"median\": Uses median baseline regions (robust outliers) \"spline\": Smooth spline baseline regions \"rf\": Robust local regression (IDPmisc::rfbaseline). Best complex baselines curvature drift. use left_frac/right_frac. rf_span Span parameter RF baseline (used method = \"rf\"). numeric value 0 1 specifying fraction points used local regression. Default 2/3. Higher values produce smoother baselines. rf_maxit Maximum iterations RF baseline (used method = \"rf\"). numeric vector length 2 specifying max iterations two stages robust fitting. Default c(20, 20). role used step since new variables created. trained logical indicate quantities preprocessing estimated. skip logical. step skipped recipe baked? id character string unique step identify .","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"GPC/SEC chromatograms typically distinct baseline regions beginning end polymer elutes. step leverages characteristic : Identifying baseline regions start end chromatogram Computing representative baseline value region (mean median) Interpolating values estimate full baseline Subtracting estimated baseline signal left_frac right_frac parameters control much chromatogram considered \"baseline\". Choose values : Include flat, signal-free regions Exclude polymer peaks system peaks large enough average noise Unlike general-purpose baseline methods like ALS polynomial fitting, approach specifically designed characteristic shape GPC/SEC chromatograms computationally fast. selectors supplied step function. data internal format produced measure::step_measure_input_wide() measure::step_measure_input_long().","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"tidy() step, tibble columns terms, left_frac, right_frac, method, id returned.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_baseline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Baseline Correction — step_sec_baseline","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # SEC baseline correction with default settings rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   prep()  # Using median method for robustness to outliers rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline(left_frac = 0.1, right_frac = 0.1, method = \"median\") |>   prep()  # Using RF baseline for complex baseline shapes rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline(method = \"rf\", rf_span = 0.5) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":null,"dir":"Reference","previous_headings":"","what":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"step_sec_broad_standard() creates specification recipe step fits calibration curve using polydisperse (broad) molecular weight standard known Mn Mw values.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"","code":"step_sec_broad_standard(   recipe,   measures = NULL,   broad_standard = NULL,   known_mn = NULL,   known_mw = NULL,   fit_type = c(\"linear\", \"quadratic\"),   method = c(\"hamielec\", \"integral\"),   reference_mwd = NULL,   integration_range = NULL,   extrapolation = c(\"warn\", \"none\"),   output_col = \"mw\",   log_output = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_broad_standard\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"recipe recipe object. measures Character vector measure columns apply calibration . NULL, uses measure columns. broad_standard data frame containing broad standard chromatogram: location (time, volume, retention, elution_time, elution_volume): Elution position value (signal, response, intensity, ri, uv): Detector response known_mn Known number-average molecular weight (Mn) Daltons. known_mw Known weight-average molecular weight (Mw) Daltons. fit_type Type calibration curve: \"linear\" (default): log10(M) = C1 + C2*V (classic Hamielec) \"quadratic\": log10(M) = C1 + C2V + C3V^2 method Calibration method: \"hamielec\" (default): Optimize match Mn Mw \"integral\": Use cumulative MWD matching (requires reference_mwd) reference_mwd Optional data frame integral method containing known cumulative molecular weight distribution broad standard: mw: Molecular weight values (Daltons) cumulative: Cumulative weight fraction (0 1) Required method = \"integral\". Can obtained standard's certificate analysis determined light scattering/viscometry. integration_range Optional numeric vector c(min, max) specifying elution range use broad standard. NULL, auto-detects peak region. extrapolation handle data outside calibration range: \"warn\" (default): Extrapolate warn \"none\": Return NA --range values output_col Name output molecular weight column. Default \"mw\". log_output Logical. TRUE (default), output column contains log10(MW). FALSE, output contains MW Daltons. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"step implements broad standard calibration methods SEC/GPC, use single polydisperse standard known molecular weight averages instead multiple narrow standards. Hamielec Method: Based Balke, Hamielec, LeClair, Pearce (1969). original method assumes linear calibration relationship, though implementation also supports quadratic extension better fit wide MW ranges: $$\\log_{10}(M) = C_1 + C_2 \\cdot V$$ algorithm simultaneously optimizes coefficients C1 C2 (C3 quadratic fits) using Nelder-Mead optimization minimize squared relative errors calculated known Mn Mw values. Integral/Cumulative Match Method: integral method matches entire cumulative MWD shape rather just Mn Mw. requires reference cumulative distribution (reference_mwd) typically obtained standard's certificate measured light scattering/viscometry. algorithm optimizes calibration coefficients minimize sum squared differences calculated reference cumulative distributions. method robust Hamielec uses full distribution shape, just two moments. particularly useful standard's MWD shape well-characterized. Use Broad Standard Calibration: QC labs running polymer type repeatedly narrow standards available polymer well-characterized -house reference material Provides \"absolute\" molecular weights polymer type Limitations: Results valid polymers similar hydrodynamic behavior Linear calibration may fit well wide MW ranges Requires well-characterized broad standard (accurate Mn Mw) Integral method requires full cumulative MWD data","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"Balke, S.T., Hamielec, .E., LeClair, B.P., Pearce, S.L. (1969). Gel permeation chromatography. Industrial & Engineering Chemistry Product Research Development, 8(1), 54-57.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_broad_standard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broad Standard Calibration for SEC/GPC — step_sec_broad_standard","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  data(sec_triple_detect)  # Create broad standard chromatogram data broad_std <- data.frame(   time = seq(10, 20, by = 0.1),   signal = dnorm(seq(10, 20, by = 0.1), mean = 15, sd = 1.5) )  # Apply broad standard calibration rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(     ri_signal,     location = vars(elution_time),     col_name = \"ri\"   ) |>   step_sec_baseline() |>   step_sec_broad_standard(     broad_standard = broad_std,     known_mn = 50000,     known_mw = 150000   ) |>   prep()  # Check calibration results tidy(rec, number = 3) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"step_sec_composition() creates specification recipe step calculates weight fraction components copolymer blend using UV RI detector signals known response factors.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"","code":"step_sec_composition(   recipe,   uv_col = NULL,   ri_col = NULL,   component_a_uv,   component_a_ri,   component_b_uv,   component_b_ri,   output_col = \"composition_a\",   min_signal = 0.01,   clip = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_composition\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"recipe recipe object. uv_col Name UV detector measure column. ri_col Name RI detector measure column. component_a_uv UV response factor component (extinction coefficient mL/(mg*cm) relative units). component_a_ri RI response factor component (dn/dc mL/g relative units). component_b_uv UV response factor component B. component_b_ri RI response factor component B. output_col Name output composition column. Default \"composition_a\". Contains weight fraction component (0-1). min_signal Minimum signal threshold (fraction max) composition set NA. Default 0.01. clip Logical. Clip composition values [0, 1] range? Default TRUE. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"two-component system, detector signals : $$UV = \\varepsilon_A \\cdot c_A + \\varepsilon_B \\cdot c_B$$ $$RI = (dn/dc)_A \\cdot c_A + (dn/dc)_B \\cdot c_B$$ c_A c_B concentrations components B. weight fraction component calculated solving system: $$w_A = \\frac{R_{obs} - R_B}{R_A - R_B}$$ R_obs observed UV/RI ratio, R_A, R_B ratios pure components (e/dn/dc). Common Applications: Styrene-acrylate copolymers (styrene UV-active) Block copolymers different chromophore content PEGylated proteins (protein 280nm, PEG UV-transparent) Polymer blends known compositions Example Response Factors: Polystyrene: UV (254nm) ~ 1.0, dn/dc ~ 0.185 PMMA: UV (254nm) ~ 0.01, dn/dc ~ 0.084 PEG: UV (280nm) ~ 0, dn/dc ~ 0.135 Proteins: UV (280nm) ~ 1.0, dn/dc ~ 0.185","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"Response factors must consistent units. absolute values matter long ratios correct pure components.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_composition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Copolymer Composition from Detector Signals — step_sec_composition","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Styrene-MMA copolymer composition rec <- recipe(~., data = copolymer_data) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_composition(     uv_col = \"uv\",     ri_col = \"ri\",     component_a_uv = 1.0,    # Styrene (UV-active)     component_a_ri = 0.185,  # Styrene dn/dc     component_b_uv = 0.01,   # MMA (weak UV)     component_b_ri = 0.084,  # MMA dn/dc     output_col = \"styrene_fraction\"   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Detector Signal to Concentration — step_sec_concentration","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"step_sec_concentration() creates specification recipe step converts detector signals absolute concentration values using calibration factors injection parameters.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"","code":"step_sec_concentration(   recipe,   measures = NULL,   detector = c(\"ri\", \"uv\", \"auto\"),   injection_volume = NULL,   injection_mass = NULL,   sample_concentration = NULL,   flow_rate = 1,   concentration_units = \"mg/mL\",   normalize_to_mass = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_concentration\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"recipe recipe object. measures Character vector detector column names convert. NULL, convert measure columns. detector Type detector signal converted: \"ri\": Refractive index detector (assumes dn/dc normalized) \"uv\": UV detector (assumes extinction coefficient normalized) \"auto\": Attempt detect column names injection_volume Injection volume uL. Required absolute concentration calculation. injection_mass Injected mass mg. Alternative using sample_concentration injection_volume. sample_concentration Sample concentration mg/mL. Used injection_volume calculate injected mass. flow_rate Flow rate mL/min peak area calculations. concentration_units Output concentration units. Default \"mg/mL\". normalize_to_mass Logical. TRUE, normalize chromatogram total area equals injected mass. Default TRUE. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"step converts detector response (dn/dc extinction coefficient normalization) absolute concentration. conversion uses known injected mass normalize chromatogram area: $$c(t) = \\frac{S(t) \\times m_{inj}}{\\int S(t) \\times F \\times dt}$$ : S(t) normalized detector signal m_inj injected mass F flow rate Workflow concentration determination: Baseline correct chromatogram Apply detector-specific normalization (dn/dc extinction coefficient) Apply step known injection parameters Result: concentration elution point","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_concentration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Detector Signal to Concentration — step_sec_concentration","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Convert RI signal to concentration rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(     detector = \"ri\",     injection_volume = 100,        # uL     sample_concentration = 2.0,    # mg/mL     flow_rate = 1.0                # mL/min   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"step_sec_conventional_cal() creates specification recipe step fits calibration curve narrow molecular weight standards applies convert elution time/volume molecular weight.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"","code":"step_sec_conventional_cal(   recipe,   measures = NULL,   standards = NULL,   calibration = NULL,   fit_type = c(\"cubic\", \"quadratic\", \"linear\", \"fifth\", \"gam\"),   extrapolation = c(\"warn\", \"none\", \"linear\"),   output_col = \"mw\",   log_output = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_conventional_cal\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"recipe recipe object. measures Character vector measure columns apply calibration . NULL, uses measure columns. standards data frame containing calibration standards columns: location (time, volume, retention): Elution position log_mw (mw): Molecular weight (log-transformed mw) Required unless calibration provided. calibration pre-loaded calibration object load_sec_calibration(). provided, skips fitting uses saved calibration directly. Takes precedence standards. fit_type Type fit calibration curve: \"cubic\" (default): Third-order polynomial \"quadratic\": Second-order polynomial \"linear\": First-order (linear) fit \"fifth\": Fifth-order polynomial \"gam\": Generalized Additive Model cubic splines (requires mgcv) extrapolation handle data outside calibration range: \"warn\" (default): Extrapolate warn \"none\": Return NA --range values \"linear\": Use linear extrapolation boundaries output_col Name output molecular weight column. Default \"mw\". log_output Logical. TRUE (default), output column contains log10(MW). FALSE, output contains MW Daltons. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"step performs conventional (also called relative) SEC calibration using narrow dispersity standards known molecular weight. calibration curve relates elution position log(MW): $$\\log_{10}(M) = f(V_e)$$ f polynomial function V_e elution volume time. Calibration Curve Fitting: calibration fit using orthogonal polynomials numerical stability. least 3 standards required cubic fits, 4 quadratic, etc. Important Considerations: Standards bracket MW range interest Calibration polymer-specific (different polymers different hydrodynamic volumes MW) cross-polymer comparisons, use universal calibration instead (step_sec_universal_cal) Fit Quality Metrics: tidy() method returns calibration coefficients R-squared values assessing fit quality. R² > 0.999 typical good calibrations.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_conventional_cal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conventional Calibration for SEC Using Narrow Standards — step_sec_conventional_cal","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Create calibration standards data ps_standards <- data.frame(   retention = c(12.5, 13.2, 14.1, 15.0, 16.2, 17.5),   log_mw = c(6.0, 5.5, 5.0, 4.5, 4.0, 3.5) )  # Apply conventional calibration rec <- recipe(~., data = polymer_data) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_conventional_cal(     standards = ps_standards,     fit_type = \"cubic\"   ) |>   prep()  # Check calibration quality tidy(rec, number = 3) } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":null,"dir":"Reference","previous_headings":"","what":"Diode Array Detector Processing for SEC — step_sec_dad","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"step_sec_dad() creates specification recipe step processes diode array detector (DAD) signals across multiple wavelengths. can apply wavelength-specific extinction coefficients optionally compute ratios reference wavelength.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"","code":"step_sec_dad(   recipe,   measures = NULL,   wavelengths = c(254, 280, 220),   extinction_coefs = NULL,   reference_wavelength = NULL,   output_prefix = \"uv\",   path_length = 1,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_dad\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"recipe recipe object. measures Character vector DAD/UV measure columns. NULL, step searches measure columns containing \"dad\" \"uv\". wavelengths Numeric vector wavelengths (nm) aligned measures. NULL, attempts parse wavelengths measures names. extinction_coefs Extinction coefficients wavelength. Accepts named numeric vector (names wavelengths), unnamed vector aligned wavelengths, data frame columns wavelength extinction_coef. reference_wavelength Optional wavelength used denominator ratio calculations. output_prefix Prefix used name output columns (e.g., uv_254). path_length Path length flow cell cm. Default 1.0. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"wavelength, signal can normalized using Beer-Lambert law: $$= \\varepsilon \\times c \\times l$$ absorbance (AU), epsilon extinction coefficient, l path length. reference_wavelength provided, step additionally creates ratio columns wavelength vs reference.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diode Array Detector Processing for SEC — step_sec_dad","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_254, location = vars(elution_time), col_name = \"uv_254\") |>   step_measure_input_long(uv_280, location = vars(elution_time), col_name = \"uv_280\") |>   step_sec_dad(     measures = c(\"uv_254\", \"uv_280\"),     wavelengths = c(254, 280),     extinction_coefs = c(`254` = 1.2, `280` = 1.0),     reference_wavelength = 280   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"step_sec_detector_delay() creates specification recipe step corrects volume delays detectors multi-detector SEC systems.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"","code":"step_sec_detector_delay(   recipe,   reference = NULL,   targets = NULL,   delay_volumes = NULL,   delay_times = NULL,   flow_rate = 1,   method = c(\"shift\", \"interpolate\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_detector_delay\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"recipe recipe object. reference Character name reference detector column (typically RI). detectors aligned reference. targets Character vector detector column names shift. NULL, measure columns except reference shifted. delay_volumes Named numeric vector delay volumes mL. Names match target column names. Positive values indicate detector sees sample reference. delay_times Named numeric vector delay times minutes. Alternative delay_volumes. Requires flow_rate specified. flow_rate Flow rate mL/min. Required using delay_times. method Method shifting signals: \"shift\" (default): Simple index shift (fastest, slight edge effects) \"interpolate\": Linear interpolation (smoother, preserves signal shape) role used step. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"multi-detector SEC systems, detectors connected series separated tubing. causes detector see analyte different times. accurate molecular weight calculations combine signals multiple detectors (e.g., RI + MALS absolute MW), delays must corrected. Typical detector order delays: UV detector: Often first, minimal delay RI detector: Common reference detector MALS detector: Often 0.1-0.3 mL delay RI Viscometer: May 0.2-0.5 mL delay Determining delay volumes: Inject narrow standard record detector signals Measure time offset peak maxima Convert volume: delay_volume = time_offset × flow_rate","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_detector_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Correct Inter-Detector Volume Delays — step_sec_detector_delay","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Correct UV and MALS signals relative to RI rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   step_sec_detector_delay(     reference = \"ri\",     delay_volumes = c(uv = -0.05, mals = 0.15)   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic Light Scattering Processing for SEC — step_sec_dls","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"step_sec_dls() creates specification recipe step processes dynamic light scattering (DLS) correlation data estimate diffusion coefficient hydrodynamic radius (Rh).","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"","code":"step_sec_dls(   recipe,   measures = NULL,   temperature = 25,   viscosity = NULL,   laser_wavelength = 633,   angle = 90,   solvent_ri = 1.333,   rg_col = \"rg\",   output_cols = c(\"rh\", \"diffusion_coef\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_dls\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"recipe recipe object. measures Character vector DLS measure columns. NULL, step searches measure columns containing \"dls\" \"corr\". temperature Temperature degrees Celsius. viscosity Solvent viscosity mPa*s. NULL, uses water approximation based temperature. laser_wavelength Laser wavelength nm. Default 633. angle Scattering angle degrees. Default 90. solvent_ri Solvent refractive index. Default 1.333 (water). rg_col Optional Rg measure column MALS Rg/Rh ratio. output_cols Output column names Rh diffusion coefficient. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"DLS correlation function g2(tau) approximated : $$g2(\\tau) = 1 + \\beta e^{-2 \\Gamma \\tau}$$ Gamma decay rate. diffusion coefficient calculated D = Gamma / q^2 q determined scattering angle wavelength. Rh obtained Stokes-Einstein equation.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_dls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic Light Scattering Processing for SEC — step_sec_dls","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(dls_corr, location = vars(lag_time), col_name = \"dls\") |>   step_sec_dls(measures = \"dls\", temperature = 25, viscosity = 0.89) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Region Exclusion — step_sec_exclude_regions","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"step_sec_exclude_regions() creates specification recipe step marks regions exclusion analysis. Excluded regions can solvent peaks, artifacts, flow markers, features included baseline fitting molecular weight integration.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"","code":"step_sec_exclude_regions(   recipe,   measures = NULL,   regions = NULL,   purpose = c(\"both\", \"baseline\", \"integration\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_exclude_regions\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"recipe recipe object. step added sequence operations recipe. measures optional character vector measure column names process. NULL (default), measure columns processed. regions data frame tibble specifying regions exclude. Must contain columns start end (x-axis values defining region). Optional columns: reason (character describing excluded), sample_id (sample-specific exclusions). purpose Character. exclusions apply : \"baseline\": Exclude baseline fitting \"integration\": Exclude MW integration \"\" (default): Exclude baseline fitting integration role used step since new variables created. trained logical indicate quantities preprocessing estimated. skip logical. step skipped recipe baked? id character string unique step identify .","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"updated version recipe new step added sequence existing operations. .excluded_regions column added containing exclusion information sample.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"Excluded regions stored list column .excluded_regions element tibble columns: start: Start excluded region (x-axis value) end: End excluded region (x-axis value) purpose: exclusion applies reason: Optional description region excluded Sample-specific exclusions: regions data frame includes sample_id column, exclusions can applied specific samples. Rows without sample_id (sample_id = NA) applied globally samples. Common uses: Solvent peaks elute end chromatogram System peaks artifacts specific retention times Flow marker peaks used retention time correction Air bubbles transient artifacts","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"tidy() step, tibble columns terms, n_regions, purpose, id returned.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_exclude_regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Region Exclusion — step_sec_exclude_regions","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Exclude a single region (solvent peak at end) exclusions <- tibble::tibble(   start = 18.5,   end = 20.0,   reason = \"Solvent peak\" )  rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_exclude_regions(regions = exclusions) |>   prep()  # Exclude multiple regions exclusions <- tibble::tibble(   start = c(8.0, 18.5),   end = c(9.0, 20.0),   reason = c(\"Void volume\", \"Solvent peak\") )  rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_exclude_regions(regions = exclusions, purpose = \"integration\") |>   prep()  # Sample-specific exclusions exclusions <- tibble::tibble(   start = c(18.5, 15.0),   end = c(20.0, 16.0),   sample_id = c(NA, \"sample_2\"),  # NA = global, specific sample_id = per-sample   reason = c(\"Solvent peak\", \"Artifact in sample_2\") )  rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_exclude_regions(regions = exclusions) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"step_sec_flow_marker() creates specification recipe step detects flow marker peak (typically toluene small molecule) applies linear correction align retention times/volumes across runs.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"","code":"step_sec_flow_marker(   recipe,   measures = NULL,   marker_range = NULL,   target_volume = NULL,   auto_detect = TRUE,   min_peak_height = NULL,   store_correction = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_flow_marker\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"recipe recipe object. measures Character vector measure column names correct. NULL, uses measure columns. marker_range Numeric vector length 2 specifying expected elution range c(min, max) flow marker peak expected. Required unless auto_detect = TRUE expected_volume specified. target_volume target elution volume align flow marker . NULL (default), uses first value marker_range. auto_detect Logical. TRUE, automatically detect flow marker peak within marker_range. FALSE, uses peak maximum within range. Default TRUE. min_peak_height Minimum peak height (signal units) valid flow marker detection. Peaks threshold ignored. Default NULL (minimum). store_correction Logical. TRUE, stores correction factor column named flow_marker_correction. Default TRUE. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"Flow marker correction compensates small variations flow rate runs. flow marker small molecule (often toluene) elutes near total permeation volume provides reference point alignment. Correction Algorithm: Find flow marker peak maximum within marker_range Calculate shift: correction = observed_volume - target_volume Apply linear correction: corrected_volume = original_volume - correction Auto-Detection: auto_detect = TRUE, step uses second-derivative analysis find sharpest peak specified range, typically flow marker. robust simply finding maximum signal. Prerequisites: applied calibration MW calculations Best applied baseline correction","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_flow_marker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flow Marker Correction for SEC/GPC — step_sec_flow_marker","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply flow marker correction with known range rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri, location = vars(elution_volume)) |>   step_sec_baseline() |>   step_sec_flow_marker(     marker_range = c(18, 20),     target_volume = 18.5   ) |>   step_sec_conventional_cal(standards = ps_standards) |>   prep()  # Auto-detect flow marker with default target (first value of range) rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri, location = vars(elution_volume)) |>   step_sec_flow_marker(marker_range = c(18, 20)) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Integration Window — step_sec_integration_window","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"step_sec_integration_window() creates specification recipe step defines integration window (start end x-axis bounds) molecular weight calculations. step adds .integration_window column downstream steps like step_sec_mw_averages() can use.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"","code":"step_sec_integration_window(   recipe,   measures = NULL,   start = NULL,   end = NULL,   auto_detect = TRUE,   signal_threshold = 0.01,   extend_beyond_cal = 0.5,   calibration_range = NULL,   min_window_width = 1,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_integration_window\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"recipe recipe object. step added sequence operations recipe. measures optional character vector measure column names process. NULL (default), measure columns processed. start Numeric. Start integration window (x-axis value, e.g., mL). NULL auto_detect = TRUE, determined automatically data. end Numeric. End integration window (x-axis value, e.g., mL). NULL auto_detect = TRUE, determined automatically data. auto_detect Logical. TRUE (default), automatically determine window bounds data start end NULL. signal_threshold Numeric 0 1. auto-detecting, fraction maximum signal use threshold defining significant signal region. Default 0.01 (1% max). extend_beyond_cal Numeric. Fraction calibration range extend beyond maximum calibration point capturing low MW species. Default 0.5 (50% extension). used calibration info available via calibration_range. calibration_range Optional numeric vector c(min, max) specifying calibration range x-axis units. provided, auto-detection respects bounds applies extend_beyond_cal. min_window_width Numeric. Minimum window width ensure valid integration. Default 1.0 (1 mL SEC). role used step since new variables created. trained logical indicate quantities preprocessing estimated. skip logical. step skipped recipe baked? id character string unique step identify .","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"updated version recipe new step added sequence existing operations. .integration_window column added containing tibble start end sample.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"integration window defines x-axis region used molecular weight calculations. SEC/GPC, typically corresponds elution volume. Auto-detection algorithm: Find significant signal region (signal_threshold max) Extend slightly beyond signal boundaries calibration_range provided, constrain start calibration minimum Allow extension extend_beyond_cal beyond calibration maximum capture low MW species Ensure minimum window width Output format: .integration_window column contains list tibbles, one per row, columns: start: Start integration window end: End integration window","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"tidy() step, tibble columns terms, start, end, auto_detect, id returned.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_integration_window.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Integration Window — step_sec_integration_window","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Auto-detect integration window rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_integration_window() |>   prep()  # Explicit window bounds rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_integration_window(start = 8.0, end = 18.0) |>   prep()  # With calibration constraints rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_integration_window(     calibration_range = c(9.0, 16.0),     extend_beyond_cal = 0.5   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"step_sec_intrinsic_visc() creates specification recipe step calculates intrinsic viscosity ([eta]) specific viscosity concentration elution point.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"","code":"step_sec_intrinsic_visc(   recipe,   specific_visc_col = NULL,   concentration_col = NULL,   output_col = \"intrinsic_visc\",   min_concentration = 1e-06,   units = c(\"dL/g\", \"mL/g\"),   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_intrinsic_visc\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"recipe recipe object. specific_visc_col Name specific viscosity measure column (step_sec_viscometer()). concentration_col Name concentration measure column. output_col Name intrinsic viscosity output column. Default \"intrinsic_visc\". min_concentration Minimum concentration threshold intrinsic viscosity set NA. Default 1e-6 mg/mL. units Output units intrinsic viscosity. Default \"dL/g\". Common alternatives \"mL/g\" (multiply 100). role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"updated recipe new step added, containing intrinsic viscosity elution point.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"Intrinsic viscosity defined limit reduced viscosity infinite dilution: $$[\\eta] = \\lim_{c \\0} \\frac{\\eta_{sp}}{c}$$ SEC, elution slice low concentration, approximation [eta] = eta_sp / c valid. Applications Intrinsic Viscosity: Universal Calibration: log([eta] * M) linear retention volume, allowing calibration transfer polymer types Mark-Houwink Equation: [eta] = K * M^, K polymer- solvent-specific constants Branching Analysis: g' = [eta]_branched / [eta]_linear provides information long-chain branching Polymer Conformation: scaling exponent [eta] vs M reveals chain conformation (coil, rod, sphere) Typical Intrinsic Viscosity Values (dL/g): Polystyrene THF (MW 100k): ~0.5 PEG water (MW 10k): ~0.2 Proteins: 0.03-0.05 (globular), 0.2-1.0 (denatured)","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_intrinsic_visc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Intrinsic Viscosity for SEC — step_sec_intrinsic_visc","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate intrinsic viscosity rec <- recipe(~., data = sec_visc_data) |>   step_measure_input_long(dp_signal, location = vars(elution_time), col_name = \"dp\") |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_viscometer(dp_col = \"dp\") |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_intrinsic_visc(     specific_visc_col = \"specific_visc\",     concentration_col = \"ri\"   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":null,"dir":"Reference","previous_headings":"","what":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"step_sec_lals() creates specification recipe step processes low-angle light scattering (LALS) signals absolute molecular weight.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"","code":"step_sec_lals(   recipe,   measures = NULL,   concentration_col = NULL,   angle = 7,   laser_wavelength = 670,   dn_dc = NULL,   solvent_ri = 1.333,   optical_constant = NULL,   calibration_constant = NULL,   output_mw = \"mw_lals\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_lals\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"recipe recipe object. measures Character vector LALS measure columns. NULL, step searches measure columns containing \"lals\". concentration_col Name concentration measure column (step_sec_concentration() similar). angle Detection angle degrees (must < 20 LALS). laser_wavelength Laser wavelength nm. dn_dc Refractive index increment (mL/g). Required unless optical_constant provided. solvent_ri Solvent refractive index. Default 1.333 (water). optical_constant Optional optical constant K; overrides dn/dc. calibration_constant LALS instrument calibration constant. NULL, results relative units. output_mw Name molecular weight output column. min_signal Minimum signal threshold (fraction max) MW set NA. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"LALS provides absolute MW using low-angle detector (e.g., ~7 degrees). assumes P(theta) ~ 1 small particles accurate angular dependence minimal. use LALS vs MALS: LALS: Preferred smaller molecules (Rg < ~10 nm) multi-angle data available. Single-angle measurement faster simpler determine Rg. MALS: Required large molecules angular dependence significant. Provides Mw Rg extrapolation zero angle.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_lals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Low-Angle Light Scattering Processing for SEC — step_sec_lals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(lals_signal, location = vars(elution_time), col_name = \"lals\") |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_lals(measures = \"lals\", concentration_col = \"ri\", dn_dc = 0.185) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"step_sec_mals() creates specification recipe step processes multi-angle light scattering (MALS) detector signals determine absolute molecular weight radius gyration elution slice.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"","code":"step_sec_mals(   recipe,   mals_col = NULL,   concentration_col = NULL,   dn_dc = NULL,   dn_dc_column = NULL,   wavelength = 658,   solvent_ri = 1.333,   angles = 90,   formalism = c(\"zimm\", \"debye\", \"berry\"),   calibration_constant = NULL,   output_mw = \"mw_mals\",   output_rg = \"rg\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mals\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"recipe recipe object. mals_col Name MALS detector measure column. single-angle detectors (RALS/LALS), signal needed. concentration_col Name concentration measure column (step_sec_concentration() similar). dn_dc Refractive index increment (mL/g). Required absolute MW. dn_dc_column Column containing sample-specific dn/dc values. wavelength Laser wavelength nm. Default 658 (common MALS). solvent_ri Solvent refractive index. Default 1.333 (water). Common values: water = 1.333, THF = 1.407, toluene = 1.497. angles Numeric vector detection angles degrees. single-angle detectors, provide just one value (e.g., 90 RALS). Default assumes 90-degree detector. formalism Angular extrapolation method multi-angle data: \"zimm\" (default), \"debye\", \"berry\". calibration_constant MALS instrument calibration constant. NULL, results relative units. Obtain toluene standard calibration. output_mw Name molecular weight output column. Default \"mw_mals\". output_rg Name radius gyration output column. Default \"rg\". calculated multiple angles provided. min_signal Minimum signal threshold (fraction max) MW set NA. Default 0.01. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"updated recipe new step added, containing absolute MW (optionally Rg) elution point.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"Light scattering provides absolute molecular weight without calibration standards. fundamental relationship : $$\\frac{K \\cdot c}{R(\\theta)} = \\frac{1}{M_w} \\cdot P(\\theta) + 2A_2 c$$ : K optical constant c concentration R(theta) excess Rayleigh ratio Mw weight-average molecular weight P(theta) particle scattering function A2 second virial coefficient optical constant K calculated : $$K = \\frac{4\\pi^2 n_0^2 (dn/dc)^2}{N_A \\lambda^4}$$ Formalisms Angular Extrapolation: Zimm: Kc/R vs sin^2(theta/2) - best random coils Debye: Kc/R vs sin^2(theta/2) - similar Zimm Berry: sqrt(Kc/R) vs sin^2(theta/2) - better large particles Single-Angle vs Multi-Angle: Single angle (RALS/LALS): Provides Mw , assumes P(theta) ~ 1 Multi-angle (MALS): Provides Mw Rg angular dependence","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"Accurate results require: Known accurate dn/dc value Calibrated instrument (calibration_constant toluene) Accurate concentration RI detector Clean baseline aligned detectors","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-Angle Light Scattering Processing for SEC — step_sec_mals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Single-angle (90 degree) light scattering rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(mals_signal, location = vars(elution_time), col_name = \"mals\") |>   step_sec_baseline() |>   step_sec_ri(dn_dc = 0.185) |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_mals(     mals_col = \"mals\",     concentration_col = \"ri\",     dn_dc = 0.185,     wavelength = 658,     angles = 90   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"step_sec_mw_averages() creates specification recipe step calculates molecular weight averages size exclusion chromatography data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"","code":"step_sec_mw_averages(   recipe,   measures = NULL,   calibration = NULL,   integration_range = NULL,   output_cols = c(\"mn\", \"mw\", \"mz\", \"mp\", \"dispersity\"),   include_uncertainty = FALSE,   calibration_error = NULL,   prefix = \"mw_\",   role = \"predictor\",   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_averages\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"recipe recipe object. measures optional character vector measure column names. calibration Calibration method converting x-axis log(MW). Can : NULL (default): Assumes x-axis already log10(MW) numeric vector length 2: Linear calibration c(slope, intercept) log10(MW) = slope * x + intercept \"auto\": Estimate data range (assumes typical polymer range) integration_range Optional numeric vector c(min, max) specifying x-axis range integration. NULL, uses full range. output_cols Character vector metrics calculate. Default includes : c(\"mn\", \"mw\", \"mz\", \"mp\", \"dispersity\"). include_uncertainty Logical. TRUE, calculates outputs uncertainty estimates MW averages. Requires calibration_error specified. Default FALSE. calibration_error Calibration error (RMSE) log10(MW) units uncertainty propagation. Required include_uncertainty = TRUE. Can obtained tidy() output step_sec_conventional_cal(). prefix Prefix output column names. Default \"mw_\". role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"step calculates standard molecular weight averages SEC/GPC data: detector signal assumed proportional weight concentration. RI detection, typically valid. UV detection, response factors may need applied first. Uncertainty Propagation: include_uncertainty = TRUE, step calculates uncertainty estimates based calibration error propagation. uncertainties account : Calibration curve fit error (RMSE log10 MW units) MW distribution width effects different averages propagation follows: Mn uncertainty enhanced wide distributions (sensitive low MW) Mw uncertainty equals relative calibration error Mz uncertainty enhanced high MW sensitivity Dispersity uncertainty error propagation Mw/Mn Prerequisites: Data baseline corrected X-axis represent retention time/volume log(MW) Integration limits exclude solvent peaks","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_averages.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Molecular Weight Averages for SEC/GPC — step_sec_mw_averages","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Assuming x-axis is already calibrated to log10(MW) rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_averages() |>   prep()  # With uncertainty propagation (calibration_error from tidy() of calibration step) rec_with_unc <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_averages(     include_uncertainty = TRUE,     calibration_error = 0.02  # RMSE in log10(MW)   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"step_sec_mw_distribution() creates specification recipe step generates molecular weight distribution curves SEC/GPC data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"","code":"step_sec_mw_distribution(   recipe,   measures = NULL,   type = c(\"differential\", \"cumulative\", \"both\"),   calibration = NULL,   n_points = 100L,   mw_range = NULL,   normalize = TRUE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_distribution\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"recipe recipe object. measures optional character vector measure column names. type Type distribution generate: \"differential\" (default): dW/d(log M) differential distribution \"cumulative\": Cumulative weight fraction distribution \"\": Generate distributions calibration Calibration method converting x-axis log(MW). See step_sec_mw_averages() details. n_points Number points output distribution. Default 100. NULL, uses original data resolution. mw_range Optional numeric vector c(min, max) specifying MW range output distribution. NULL, uses range data. normalize Logical. differential distribution normalized integrate 1? Default TRUE. role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"step transforms raw chromatogram standard MW distribution representations: Differential Distribution (dW/d(log M)): weight fraction per unit log(MW). representation preferred area curve represents weight fraction MW range. Cumulative Distribution: cumulative weight fraction low high MW. Values range 0 1. output replaces .measures column distribution data, location contains log10(MW) values value contains distribution values.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Molecular Weight Distribution Curve — step_sec_mw_distribution","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Generate differential MW distribution rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_distribution(type = \"differential\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"step_sec_mw_fractions() creates specification recipe step calculates weight fractions specified molecular weight cutoffs.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"","code":"step_sec_mw_fractions(   recipe,   measures = NULL,   cutoffs = c(1000, 10000, 1e+05),   calibration = NULL,   integration_range = NULL,   prefix = \"frac_\",   role = \"predictor\",   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_mw_fractions\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"recipe recipe object. measures optional character vector measure column names. cutoffs Numeric vector MW cutoff values. cutoff, step calculates weight fraction value. calibration Calibration method converting x-axis log(MW). See step_sec_mw_averages() details. integration_range Optional numeric vector c(min, max) specifying x-axis range integration. NULL, uses full range. prefix Prefix output column names. Default \"frac_\". role Role generated columns. Default \"predictor\". trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"cutoff value C, step calculates: frac_below_C: Weight fraction MW < C frac_above_C: Weight fraction MW >= C fractions sum 1.0 useful characterizing polymer distributions. Common cutoffs include: 1000 Da oligomer content 10000 Da low MW fraction 100000 Da high MW fraction","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_mw_fractions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Molecular Weight Fractions for SEC/GPC — step_sec_mw_fractions","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate fractions at multiple cutoffs rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_wide(starts_with(\"signal_\")) |>   step_sec_baseline() |>   step_sec_mw_fractions(cutoffs = c(1000, 10000, 100000)) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":null,"dir":"Reference","previous_headings":"","what":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"step_sec_oligomer() creates specification recipe step identifies quantifies individual oligomeric species (monomer, dimer, trimer, etc.) protein SEC chromatograms.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"","code":"step_sec_oligomer(   recipe,   measures = NULL,   monomer_mw = NULL,   peak_detection = c(\"auto\", \"manual\"),   peaks = NULL,   species = c(\"monomer\", \"dimer\", \"trimer\", \"hmw\", \"lmw\"),   mw_tolerance = 0.15,   mw_column = NULL,   min_area_pct = 0.1,   output_prefix = \"oligo_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_oligomer\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. monomer_mw Expected monomer molecular weight Da. Required species assignment. Typical range: 10,000 - 1,000,000 Da proteins. peak_detection Method peak detection: \"auto\" (default): Automatic peak detection using derivative analysis \"manual\": Use peaks specified peaks argument peaks manual mode, list data frame peak definitions. peak start end retention times. species Character vector species identify. Default includes \"monomer\", \"dimer\", \"trimer\", \"hmw\", \"lmw\". mw_tolerance Tolerance MW-based species assignment fraction. Default 0.15 (15%). peak assigned \"dimer\" MW within 15% 2x monomer MW. mw_column Optional name molecular weight measure column (MALS LALS). provided, uses MW species assignment; otherwise uses retention time patterns. min_area_pct Minimum peak area percentage report. Peaks threshold grouped \"\". Default 0.1 (0.1%). output_prefix Prefix output columns. Default \"oligo_\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"updated recipe new columns: oligo_monomer_pct Percent monomer oligo_dimer_pct Percent dimer oligo_trimer_pct Percent trimer oligo_hmw_pct Percent high molecular weight (> trimer) oligo_lmw_pct Percent low molecular weight (fragments) oligo_species_count Number detected species oligo_monomer_mw Observed monomer MW (mw_column provided) oligo_dimer_mw Observed dimer MW (mw_column provided)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"step extends step_sec_aggregates() providing detailed species identification rather just HMWS/monomer/LMWS classification. Species Assignment: Monomer: MW within mw_tolerance monomer_mw Dimer: MW within mw_tolerance 2x monomer_mw Trimer: MW within mw_tolerance 3x monomer_mw HMW: MW > 3x monomer_mw LMW: MW < monomer_mw (fragments, clips) Peak Detection: using \"auto\" detection, peaks identified using: Signal derivative analysis Local maxima identification Valley detection peak boundaries Without MW Data: MW column available, species assigned based retention time: Largest peak assumed monomer Earlier-eluting peaks HMW/oligomers Later-eluting peaks LMW/fragments","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"best results: Provide monomer_mw accurate species assignment Use MALS/LALS data MW-based assignment Ensure good chromatographic resolution species","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_oligomer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oligomeric Species Analysis for Protein SEC — step_sec_oligomer","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Analyze IgG oligomers (monomer MW ~150 kDa) rec <- recipe(~., data = igg_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_baseline() |>   step_sec_oligomer(monomer_mw = 150000) |>   prep()  # With MALS-derived MW for accurate assignment rec <- recipe(~., data = igg_mals_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_mals() |>   step_sec_oligomer(monomer_mw = 150000, mw_column = \"mw_mals\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"step_sec_peaks_deconvolve() creates specification recipe step resolves overlapping peaks SEC/GPC chromatograms using curve fitting. thin wrapper around measure::step_measure_peaks_deconvolve() SEC-optimized defaults.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"","code":"step_sec_peaks_deconvolve(   recipe,   model = \"emg\",   optimizer = \"auto\",   max_iter = 500L,   quality_threshold = 0.9,   smart_init = TRUE,   constrain_positions = TRUE,   peaks_col = \".peaks\",   measures_col = \".measures\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_peaks_deconvolve\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"recipe recipe object. step added sequence operations recipe. model Peak model use: \"emg\" (default): Exponentially Modified Gaussian, recommended SEC chromatograms peak tailing \"gaussian\": Symmetric Gaussian, well-behaved symmetric peaks \"bigaussian\": Bi-Gaussian flexible asymmetry EMG default chromatographic peaks typically exhibit tailing due mass transfer kinetics column effects. optimizer Optimization method: \"auto\" (default): Selects based problem complexity \"lbfgsb\": L-BFGS-B (fast, local optimization) \"multistart\": Multiple starts robustness \"nelder_mead\": Derivative-free simplex method max_iter Maximum iterations optimization. Default 500. quality_threshold Minimum R-squared accept fit. Default 0.9 (stricter base measure default 0.8 analytical quality). smart_init Logical. Use smart initialization based peak properties. Default TRUE. Highly recommended SEC data. constrain_positions Logical. Enforce peak centers maintain relative ordering optimization. Default TRUE. peaks_col Name peaks column. Default \".peaks\". measures_col Name measures column containing chromatogram. Default \".measures\" often \"ri\", \"uv\", etc. SEC workflows. role used step. trained logical indicate step trained. skip logical. step skipped baking? id character string unique step.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"updated version recipe new step added. .peaks column updated : Refined peak parameters curve fitting fit_r_squared: R-squared overall fit area: Integrated area fitted curve (analytical integration)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"Peak deconvolution essential SEC/GPC analysis peaks overlap, common : Bimodal molecular weight distributions Aggregate/monomer/fragment species protein SEC Copolymer component separation EMG Model (Default): Exponentially Modified Gaussian (EMG) ideal SEC accounts characteristic tailing observed chromatographic peaks: $$EMG(x) = h \\cdot \\exp(\\sigma^2/(2\\tau^2) + (c-x)/\\tau) \\cdot   \\Phi((x-c)/\\sigma - \\sigma/\\tau)$$ \\(h\\) height, \\(c\\) center, \\(\\sigma\\) Gaussian width, \\(\\tau\\) exponential decay parameter (tailing). Quality Assessment: quality_threshold parameter sets minimum acceptable R-squared fits. default 0.9 stricter base measure default, appropriate quantitative analytical work.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"tidy() step, tibble columns model, optimizer, quality_threshold, id returned.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_deconvolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Peak Deconvolution — step_sec_peaks_deconvolve","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # SEC peak deconvolution with EMG model (default) rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_peaks_detect() |>   step_sec_peaks_deconvolve() |>   prep()  # Use Gaussian model for symmetric peaks rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_peaks_detect() |>   step_sec_peaks_deconvolve(model = \"gaussian\") |>   prep()  # Use multistart optimizer for complex multi-peak scenarios rec <- recipe(~., data = sec_data) |>   step_measure_input_long(ri_signal, location = vars(elution_volume)) |>   step_sec_peaks_detect() |>   step_sec_peaks_deconvolve(optimizer = \"multistart\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":null,"dir":"Reference","previous_headings":"","what":"SEC/GPC Peak Detection — step_sec_peaks_detect","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"step_sec_peaks_detect() creates specification recipe step detects peaks SEC/GPC chromatography data. default algorithm finderskeepers, uses LOESS smoothing Iterative Soft Thresholding (IST) changepoint analysis automatic threshold detection.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"","code":"step_sec_peaks_detect(   recipe,   measures = NULL,   algorithm = \"finderskeepers\",   min_height = 1,   min_distance = 0,   loess_span = 0.01,   ist_points = 50L,   ist_nonlinearity = 5,   snr_threshold = FALSE,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_peaks_detect\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"recipe recipe object. step added sequence operations recipe. measures optional character vector measure column names process. NULL (default), measure columns (columns class measure_list) processed. algorithm Peak detection algorithm. Currently \"finderskeepers\" (default) supported. SEC-optimized algorithm uses LOESS smoothing Iterative Soft Thresholding changepoint detection. algorithms, use measure::step_measure_peaks_detect() directly. min_height Minimum peak height. \"finderskeepers\", minimum height baseline. algorithms snr_threshold = TRUE, interpreted signal--noise ratio. Default 1. min_distance Minimum distance peaks location units (e.g., mL). used non-finderskeepers algorithms. Default 0. loess_span LOESS smoothing span finderskeepers. value 0 1 controlling smoothness fit. Default 0.01 (minimal smoothing preserve peak shapes). ist_points Number threshold levels Iterative Soft Thresholding. Default 50. Higher values give finer threshold resolution. ist_nonlinearity Nonlinearity parameter IST threshold spacing. Default 5. Higher values concentrate thresholds near baseline. snr_threshold Logical. non-finderskeepers algorithms, TRUE, min_height interpreted signal--noise ratio. Default FALSE. role used step since new variables created. trained logical indicate quantities preprocessing estimated. skip logical. step skipped recipe baked? id character string unique step identify .","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"updated version recipe new step added sequence existing operations. new .peaks column added containing detected peaks sample.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"finderskeepers algorithm specifically designed SEC/GPC data: 1 . LOESS smoothing: Applies local polynomial regression reduce noise preserving peak shapes (controlled loess_span) 2. Iterative Soft Thresholding (IST): Creates series thresholds nonlinear spacing detect changes peak structure 3. Changepoint detection: Uses changepoint::cpt.mean() automatically determine optimal threshold peak/baseline separation 4. Peak boundary detection: Identifies peak start, apex, end points approach robust baseline drift varying peak heights, making well-suited polymer SEC chromatograms. Peak properties stored: peak_id: Integer identifier location: X-axis position peak apex (elution volume) height: Peak height baseline left_base, right_base: X-axis positions peak boundaries area: Initially NA; use measure::step_measure_peaks_integrate() calculate","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"tidying","dir":"Reference","previous_headings":"","what":"Tidying","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"tidy() step, tibble columns terms, algorithm, min_height, id returned.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_peaks_detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEC/GPC Peak Detection — step_sec_peaks_detect","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # SEC peak detection with finderskeepers (default) rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time)) |>   step_sec_peaks_detect() |>   prep()  # Adjust sensitivity with min_height rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time)) |>   step_sec_peaks_detect(min_height = 5) |>   prep()  # Adjust LOESS smoothing for noisy data rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time)) |>   step_sec_peaks_detect(loess_span = 0.05) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":null,"dir":"Reference","previous_headings":"","what":"Protein SEC Analysis Workflow — step_sec_protein","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"step_sec_protein() creates specification recipe step provides streamlined workflow protein SEC analysis, combining baseline correction, aggregate quantitation, optionally oligomer analysis single step.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"","code":"step_sec_protein(   recipe,   measures = NULL,   type = c(\"native\", \"denaturing\"),   monomer_mw = NULL,   monomer_start = NULL,   monomer_end = NULL,   extinction_coef = NULL,   aggregate_threshold = 0.001,   baseline_method = c(\"linear\", \"median\", \"spline\"),   baseline_left_frac = 0.05,   baseline_right_frac = 0.05,   include_oligomer = NULL,   output_prefix = \"protein_\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_protein\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"recipe recipe object. measures Character vector measure columns analyze. NULL, analyzes measure columns. type Analysis type: \"native\" (default): Native conditions (aqueous buffer, non-denaturing) \"denaturing\": Denaturing conditions (e.g., SDS guanidine) monomer_mw Expected monomer molecular weight Da. Required oligomer analysis include_oligomer = TRUE. monomer_start Start monomer peak region (location units). NULL, automatically determined. monomer_end End monomer peak region. NULL, automatically determined. extinction_coef Extinction coefficient UV-based concentration. NULL, signal remains raw units. aggregate_threshold Minimum fraction signal report aggregate/fragment. Default 0.001 (0.1%). baseline_method Method baseline correction. One \"linear\" (default), \"median\", \"spline\". baseline_left_frac Fraction chromatogram start baseline. Default 0.05. baseline_right_frac Fraction chromatogram end baseline. Default 0.05. include_oligomer Logical. Include detailed oligomer analysis? Default TRUE monomer_mw provided. output_prefix Prefix output columns. Default \"protein_\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"updated recipe new columns: protein_hmws_pct Percent high molecular weight species protein_monomer_pct Percent monomer protein_lmws_pct Percent low molecular weight species protein_main_start Start main peak region protein_main_end End main peak region include_oligomer = TRUE monomer_mw provided: protein_monomer_oligo_pct Percent monomer (oligomer analysis) protein_dimer_pct Percent dimer protein_trimer_pct Percent trimer protein_hmw_oligo_pct Percent HMW oligomers protein_lmw_oligo_pct Percent fragments protein_species_count Number detected species","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"step provides convenient \"one-stop\" workflow protein SEC analysis, suitable biopharmaceutical characterization. combines: Baseline correction: SEC-optimized linear median baseline Aggregate quantitation: HMWS/monomer/LMWS percentages Oligomer analysis (optional): Detailed species identification Native vs Denaturing: Native: Preserves quaternary structure; use oligomer analysis Denaturing: Disrupts non-covalent interactions; use covalent aggregate detection Regulatory Context: Aggregate analysis critical biopharmaceutical characterization: ICH Q6B requires aggregate content specification USP <129> provides guidance aggregate testing Typical specifications: HMWS < 5%, Monomer > 95% Control: advanced analysis custom workflows, use individual steps: step_sec_baseline() baseline correction step_sec_uv() UV signal processing step_sec_aggregates() HMWS/monomer/LMWS step_sec_oligomer() detailed species analysis","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_protein.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Protein SEC Analysis Workflow — step_sec_protein","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Basic protein SEC workflow rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(monomer_mw = 150000) |>   prep()  # Native mAb analysis with oligomer detection rec <- recipe(~., data = mab_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(     type = \"native\",     monomer_mw = 150000,     extinction_coef = 1.4,     include_oligomer = TRUE   ) |>   prep()  # Denaturing conditions (SDS-SEC) rec <- recipe(~., data = sds_sec_data) |>   step_measure_input_long(uv280, location = vars(time), col_name = \"uv\") |>   step_sec_protein(type = \"denaturing\", monomer_mw = 150000) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":null,"dir":"Reference","previous_headings":"","what":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"step_sec_rals() creates specification recipe step processes right-angle light scattering (RALS) signals absolute molecular weight.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"","code":"step_sec_rals(   recipe,   measures = NULL,   concentration_col = NULL,   angle = 90,   laser_wavelength = 670,   dn_dc = NULL,   solvent_ri = 1.333,   optical_constant = NULL,   calibration_constant = NULL,   output_mw = \"mw_rals\",   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_rals\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"recipe recipe object. measures Character vector RALS measure columns. NULL, step searches measure columns containing \"rals\". concentration_col Name concentration measure column (step_sec_concentration() similar). angle Detection angle degrees. Default 90. laser_wavelength Laser wavelength nm. dn_dc Refractive index increment (mL/g). Required unless optical_constant provided. solvent_ri Solvent refractive index. Default 1.333 (water). optical_constant Optional optical constant K; overrides dn/dc. calibration_constant RALS instrument calibration constant. NULL, results relative units. output_mw Name molecular weight output column. min_signal Minimum signal threshold (fraction max) MW set NA. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"RALS provides absolute MW using 90-degree detector. accurate smaller molecules angular dependence minimal (Rg << lambda/20).","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_rals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right-Angle Light Scattering Processing for SEC — step_sec_rals","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(rals_signal, location = vars(elution_time), col_name = \"rals\") |>   step_sec_concentration(detector = \"ri\", injection_mass = 0.2, flow_rate = 1.0) |>   step_sec_rals(measures = \"rals\", concentration_col = \"ri\", dn_dc = 0.185) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":null,"dir":"Reference","previous_headings":"","what":"RI Detector Processing for SEC — step_sec_ri","title":"RI Detector Processing for SEC — step_sec_ri","text":"step_sec_ri() creates specification recipe step processes refractive index (RI) detector signals SEC analysis, including application dn/dc (refractive index increment) values.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RI Detector Processing for SEC — step_sec_ri","text":"","code":"step_sec_ri(   recipe,   measures = NULL,   dn_dc = NULL,   dn_dc_column = NULL,   instrument_constant = 1,   output_col = NULL,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_ri\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RI Detector Processing for SEC — step_sec_ri","text":"recipe recipe object. measures Character vector RI detector column names process. NULL, look columns containing \"ri\" name. dn_dc Refractive index increment (mL/g). Can : single numeric value applied samples NULL skip dn/dc normalization (signal remains detector units) dn_dc_column Character name column containing sample-specific dn/dc values. Overrides dn_dc provided. instrument_constant RI detector instrument constant. Default 1.0 (adjustment). converts raw detector response refractive index units. output_col Name output column. Default modify place. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RI Detector Processing for SEC — step_sec_ri","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RI Detector Processing for SEC — step_sec_ri","text":"refractive index (RI) detector common concentration detector SEC/GPC. detector response proportional product concentration dn/dc: $$RI_{signal} = K \\times c \\times (dn/dc)$$ : K instrument constant c concentration (mg/mL) dn/dc refractive index increment (mL/g) Common dn/dc values (water 25°C, 633 nm): Polystyrene THF: 0.185 mL/g PMMA THF: 0.084 mL/g PEG water: 0.135 mL/g Proteins: ~0.185 mL/g DNA: ~0.170 mL/g","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_ri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RI Detector Processing for SEC — step_sec_ri","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply fixed dn/dc value rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_ri(dn_dc = 0.185) |>   prep()  # Use sample-specific dn/dc from a column rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_sec_ri(dn_dc_column = \"dn_dc\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Universal Calibration for SEC — step_sec_universal_cal","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"step_sec_universal_cal() creates specification recipe step applies universal calibration determine molecular weight intrinsic viscosity retention data.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"","code":"step_sec_universal_cal(   recipe,   measures = NULL,   calibration = NULL,   calibration_col = NULL,   intrinsic_visc_col = NULL,   K_sample,   a_sample,   K_standard = 0.000114,   a_standard = 0.716,   output_col = \"mw_universal\",   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_universal_cal\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"recipe recipe object. measures Character vector measure columns apply calibration . NULL, uses measure columns. calibration calibration object data frame containing universal calibration curve (log([eta]M) vs retention). calibration_col calibration column name data, specify . intrinsic_visc_col Column containing intrinsic viscosity values. Required converting polymer types. K_sample Mark-Houwink K parameter sample polymer. a_sample Mark-Houwink (alpha) exponent sample polymer. K_standard Mark-Houwink K calibration standard polymer. Default 0.000114 (polystyrene THF). a_standard Mark-Houwink calibration standard. Default 0.716 (polystyrene THF). output_col Name output molecular weight column. Default \"mw_universal\". role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"updated recipe molecular weight calculated via universal calibration.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"Universal calibration based principle polymers hydrodynamic volume elute retention time, regardless chemical structure. hydrodynamic volume proportional [eta]M: $$V_h \\propto [\\eta] \\cdot M$$ Universal Calibration Curve: $$\\log([\\eta] \\cdot M)_{sample} = \\log([\\eta] \\cdot M)_{standard}$$ retention volume, using Mark-Houwink equations: $$[\\eta] = K \\cdot M^$$ can solve sample MW: $$M_{sample} = \\left(\\frac{K_{std} \\cdot M_{std}^{1+a_{std}}}{K_{sample}}\\right)^{\\frac{1}{1+a_{sample}}}$$ Mark-Houwink Parameters (THF, 25C): Polystyrene: K = 0.000114, = 0.716 PMMA: K = 0.000128, = 0.690 Polyisoprene: K = 0.000251, = 0.728 Polybutadiene: K = 0.000457, = 0.693","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"Universal calibration requires: Known Mark-Houwink parameters standard sample Calibration narrow standards (typically polystyrene) solvent temperature measurements absolute MW determination, consider using MALS detection instead.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_universal_cal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Universal Calibration for SEC — step_sec_universal_cal","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply universal calibration to convert PS calibration to PMMA rec <- recipe(~., data = pmma_data) |>   step_measure_input_long(ri, location = vars(time), col_name = \"ri\") |>   step_sec_baseline() |>   step_sec_universal_cal(     calibration = ps_calibration,     K_sample = 0.000128,      # PMMA     a_sample = 0.690,     K_standard = 0.000114,    # PS (default)     a_standard = 0.716   ) |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":null,"dir":"Reference","previous_headings":"","what":"UV Detector Processing for SEC — step_sec_uv","title":"UV Detector Processing for SEC — step_sec_uv","text":"step_sec_uv() creates specification recipe step processes UV detector signals SEC analysis, including application extinction coefficients concentration determination.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UV Detector Processing for SEC — step_sec_uv","text":"","code":"step_sec_uv(   recipe,   measures = NULL,   extinction_coef = NULL,   extinction_column = NULL,   wavelength = 280,   path_length = 1,   output_col = NULL,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_uv\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UV Detector Processing for SEC — step_sec_uv","text":"recipe recipe object. measures Character vector UV detector column names process. NULL, look columns containing \"uv\" name. extinction_coef Extinction coefficient mL/(mgcm) L/(gcm). Can : single numeric value applied samples NULL skip normalization (signal remains AU) extinction_column Character name column containing sample-specific extinction coefficients. Overrides extinction_coef provided. wavelength UV detection wavelength nm. documentation . path_length Path length flow cell cm. Default 1.0. output_col Name output column. Default modify place. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"UV Detector Processing for SEC — step_sec_uv","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"UV Detector Processing for SEC — step_sec_uv","text":"UV detector measures absorbance according Beer-Lambert law: $$= \\varepsilon \\times c \\times l$$ : absorbance (AU) epsilon molar extinction coefficient mL/(mg*cm) c concentration (mg/mL) l path length (cm) step can convert UV absorbance concentration-proportional signals dividing extinction coefficient path length. Common UV applications SEC: Proteins 280 nm (aromatic amino acids) Nucleic acids 260 nm Conjugated polymers UV-active end groups labels UV vs RI concentration: UV sensitive chromophore-containing analytes UV response depends chemical composition (may vary MW) RI universal less sensitive accurate MW, combine detectors","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"UV Detector Processing for SEC — step_sec_uv","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Apply fixed extinction coefficient rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_uv(extinction_coef = 1.0, wavelength = 280) |>   prep()  # Use sample-specific extinction coefficients rec <- recipe(~., data = sec_triple_detect) |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_uv(extinction_column = \"ext_coef\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"step_sec_uv_ri_ratio() creates specification recipe step calculates ratio UV RI detector signals elution point. ratio useful detecting compositional heterogeneity copolymers conjugates.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"","code":"step_sec_uv_ri_ratio(   recipe,   uv_col = NULL,   ri_col = NULL,   output_col = \"uv_ri_ratio\",   min_signal = 0.01,   smooth = TRUE,   smooth_window = 5,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_uv_ri_ratio\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"recipe recipe object. uv_col Name UV detector measure column. ri_col Name RI detector measure column. output_col Name output ratio column. Default \"uv_ri_ratio\". min_signal Minimum signal threshold (fraction max) ratio set NA. Default 0.01 (1%). Prevents noisy ratios baseline. smooth Logical. Apply smoothing ratio? Default TRUE. smooth_window Window size smoothing (number points). Default 5. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"updated recipe new step added.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"UV/RI ratio provides information chemical composition across molecular weight distribution: $$Ratio(t) = \\frac{UV(t)}{RI(t)} = \\frac{\\varepsilon \\cdot c(t)}{(dn/dc) \\cdot c(t) \\cdot K}$$ Since concentration cancels , ratio reflects relative detector response factors, depend chemical composition. Applications: Copolymer composition drift molecular weight Block copolymer characterization PEGylation analysis (protein-PEG conjugates) Detection chemical heterogeneity End-group analysis UV labels Interpretation: Constant ratio: Uniform composition across MW Increasing ratio MW: chromophore higher MW species Decreasing ratio MW: Less chromophore higher MW species","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"UV RI signals baseline-corrected properly aligned (using step_sec_detector_delay()) calculating ratio.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_uv_ri_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate UV/RI Ratio for Composition Analysis — step_sec_uv_ri_ratio","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Calculate UV/RI ratio for copolymer rec <- recipe(~., data = sec_copolymer) |>   step_measure_input_long(ri_signal, location = vars(elution_time), col_name = \"ri\") |>   step_measure_input_long(uv_signal, location = vars(elution_time), col_name = \"uv\") |>   step_sec_detector_delay(reference = \"ri\", delay_volumes = c(uv = 0.05)) |>   step_sec_baseline() |>   step_sec_uv_ri_ratio(uv_col = \"uv\", ri_col = \"ri\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential Viscometer Processing for SEC — step_sec_viscometer","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"step_sec_viscometer() creates specification recipe step processes differential viscometer signals calculate specific viscosity elution point.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"","code":"step_sec_viscometer(   recipe,   dp_col = NULL,   ip_col = NULL,   output_col = \"specific_visc\",   viscometer_constant = 1,   min_signal = 0.01,   role = NA,   trained = FALSE,   skip = FALSE,   id = recipes::rand_id(\"sec_viscometer\") )"},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"recipe recipe object. dp_col Name differential pressure (DP) measure column. ip_col Name inlet pressure (IP) measure column. NULL, assumes single-capillary viscometer DP directly proportional specific viscosity. output_col Name specific viscosity output column. Default \"specific_visc\". viscometer_constant Instrument calibration constant. Default 1.0. Obtain viscosity standard calibration. min_signal Minimum signal threshold (fraction max) viscosity set NA. Default 0.01. role Role generated columns. trained Logical indicating step trained. skip Logical. step skipped baking? id Unique step identifier.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"updated recipe new step added, containing specific viscosity elution point.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"Differential viscometers measure pressure difference sample reference capillary determine solution viscosity. specific viscosity calculated differential pressure (DP) inlet pressure (IP): $$\\eta_{sp} = \\frac{4 \\cdot DP}{IP - 2 \\cdot DP}$$ single-capillary viscometers IP available: $$\\eta_{sp} = K \\cdot DP$$ K calibration constant. Viscometry SEC: Provides specific viscosity MW slice Combined concentration gives intrinsic viscosity [eta] Used universal calibration: log([eta] * M) vs retention Essential branching analysis (g' = [eta]_branched / [eta]_linear)","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"intrinsic viscosity calculation, use step_sec_intrinsic_visc() step.","code":""},{"path":[]},{"path":"https://jameshwade.github.io/measure-sec/reference/step_sec_viscometer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential Viscometer Processing for SEC — step_sec_viscometer","text":"","code":"if (FALSE) { # \\dontrun{ library(recipes) library(measure)  # Process differential viscometer data rec <- recipe(~., data = sec_visc_data) |>   step_measure_input_long(dp_signal, location = vars(elution_time), col_name = \"dp\") |>   step_measure_input_long(ip_signal, location = vars(elution_time), col_name = \"ip\") |>   step_sec_baseline() |>   step_sec_viscometer(dp_col = \"dp\", ip_col = \"ip\") |>   prep() } # }"},{"path":"https://jameshwade.github.io/measure-sec/reference/tidy.step_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"tidy() method returns tibble information step parameters.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/tidy.step_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"","code":"# S3 method for class 'step_sec_aggregates' tidy(x, ...)  # S3 method for class 'step_sec_band_broadening' tidy(x, ...)  # S3 method for class 'step_sec_baseline' tidy(x, ...)  # S3 method for class 'step_sec_broad_standard' tidy(x, ...)  # S3 method for class 'step_sec_composition' tidy(x, ...)  # S3 method for class 'step_sec_concentration' tidy(x, ...)  # S3 method for class 'step_sec_conventional_cal' tidy(x, ...)  # S3 method for class 'step_sec_dad' tidy(x, ...)  # S3 method for class 'step_sec_detector_delay' tidy(x, ...)  # S3 method for class 'step_sec_dls' tidy(x, ...)  # S3 method for class 'step_sec_exclude_regions' tidy(x, ...)  # S3 method for class 'step_sec_flow_marker' tidy(x, ...)  # S3 method for class 'step_sec_integration_window' tidy(x, ...)  # S3 method for class 'step_sec_intrinsic_visc' tidy(x, ...)  # S3 method for class 'step_sec_lals' tidy(x, ...)  # S3 method for class 'step_sec_mals' tidy(x, ...)  # S3 method for class 'step_sec_mw_averages' tidy(x, ...)  # S3 method for class 'step_sec_mw_distribution' tidy(x, ...)  # S3 method for class 'step_sec_mw_fractions' tidy(x, ...)  # S3 method for class 'step_sec_oligomer' tidy(x, ...)  # S3 method for class 'step_sec_peaks_deconvolve' tidy(x, ...)  # S3 method for class 'step_sec_peaks_detect' tidy(x, ...)  # S3 method for class 'step_sec_protein' tidy(x, ...)  # S3 method for class 'step_sec_rals' tidy(x, ...)  # S3 method for class 'step_sec_ri' tidy(x, ...)  # S3 method for class 'step_sec_universal_cal' tidy(x, ...)  # S3 method for class 'step_sec_uv' tidy(x, ...)  # S3 method for class 'step_sec_uv_ri_ratio' tidy(x, ...)  # S3 method for class 'step_sec_viscometer' tidy(x, ...)"},{"path":"https://jameshwade.github.io/measure-sec/reference/tidy.step_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"x recipe step object. ... currently used.","code":""},{"path":"https://jameshwade.github.io/measure-sec/reference/tidy.step_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy Methods for SEC Steps — tidy.step_sec_aggregates","text":"tibble step information.","code":""}]
